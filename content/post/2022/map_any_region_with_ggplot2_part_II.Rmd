---
author: "M. Teodoro Tenango"
title: "Map any region in the world with R - Part II: Obtaining the coordinates"
image: ""
draft: true
date: 2022-11-04
description: "Part II of making maps of any region in the world with R using ggplot2 and maps packages"
tags: ["R maps", "ggplot2", "Code Visuals", "R functions"]
categories: ["R"]
archives: ["2022"]
---

## Scope of this post

This is the second part of the series of post to create a map of any region of the world with R.

We are creating maps of data showing changes over a span of time for different countries and pointing at all kinds of cities. That basically means that we need to **map any region of the world with R**. Today there are all kinds of packages and techniques to do that. I will share the strategy I used with [ggplot2](https://cran.r-project.org/web/packages/ggplot2/index.html) and [maps](https://cran.r-project.org/web/packages/maps/index.html) packages, using support of [Open Street Map](https://www.openstreetmap.org/) to obtain the coordinates of cities and finally making it interactive with [shiny](https://shiny.rstudio.com/). The project is quite long for a single post, so my idea is to split it into a few smaller blog posts. So far, the list is a follows:

1. [The basic map](https://blog.rwhitedwarf.com/post/map_any_region_with_ggplot2_part_i/)
2. **Web scrapping with nominatim open street maps**
3. Maps with cities
4. Dynamic maps in time
5. Making a single script for fast replication
6. Making the code interactive in a shiny app
	
It is my way to share the how-to of one of the projects I am most proud of, and at the same time to give back to the R community in hopes that it can help somebody else.

I hope you all enjoy it. Feel free to leave any kind of comment and/or question at the end.

# Open Street Maps and Nominatim

> A simple query
> ```{r osm_general_query}
> library('RJSONIO')
> 
> site <- ("http://nominatim.openstreetmap.org/search?city=Texcoco&limit=9&format=json")
> (result <- fromJSON(site))
> ```

We start with [Open Street Map](https://www.openstreetmap.org/) and its API [nominatim](https://nominatim.openstreetmap.org/ui/about.html). In the piece of code above we can see how to perform a simple query for one city. It is basically the url of nominatim supplemented at the end by the search details: since our main target are cities, we open the search with city using `?city=Texcoco`, in this case I aimed for a city with only few results. Next we are limiting the amount of results to 9 with `&limit=9` and finally requesting the results in format JSON. 

We could basically copy the string that we are passing to `site` and paste it in the web browser to see the results directly there. Feel free to change the city `Texcoco` to any other city, and play a bit more with the rest of the parameters. Particularly have a look at what happens when you remove the `&format=json` part or when you exchange `json` for any other abstract string like `csv` or other non-recognized format. 

> A more specific query
> ```{r osm_specific_query}
> city <- 'San%20Francisco'
> state <- '&state=California'
> country <- '&countrycodes=US'
> start.nominatim <- "http://nominatim.openstreetmap.org/search?city="
> end.nominatim <- "&format=json"
> 
> site <- paste0(start.nominatim, city, country, state, end.nominatim)
> (result <- fromJSON(site))
> ```

If you explore OSM and nominatim a bit you will see that we can add search arguments using `&` followed by the argument we want (i.e., `state`), the symbol equal `=` and the argument. In my example above you can see how we are specifying the State and Country of our query. Additionally it is important to know how to pass spaces in a name, for example, San Francisco will be passed as `San%20Francisco`. 

With this basic information in mind and knowing that the package `RJSONIO` helps us to retrieve the data from the JSON api into an R friendly format, we can easily prepare a function to search for any city quickly, provided a few extra details like a region, state or county, and especially important, the country (try searching for cities like London or Prague without providing a country, you might be surprised of how many cities exist in the world with such names). 

```{r coords_from_city}
coords_from_city <- function(City,
                             CountryTwoLetter,
                             Region = NULL,
                             State = NULL,
                             County = NULL){
    require('RJSONIO')
    CityCoded <- gsub(' ','%20',City) #remove space for URLs
    CountryCoded <- paste("&countrycodes=", CountryTwoLetter, sep = '')
    if(!missing(State)){
        State <- paste("&state=", gsub(' ','%20',State), sep = '')
    }
    if(!missing(County)){
        County <- paste("&county=", gsub(' ','%20',County), sep = '')
    }
    if(!missing(Region)){
        Region <- paste("&region=", gsub(' ','%20',Region), sep = '')
    }
    ## get data
    url <- paste(
        "http://nominatim.openstreetmap.org/search?city="
      , CityCoded
      , CountryCoded
      , State
      , County
      , Region
      , "&limit=9&format=json"
      , sep="")
    x <- fromJSON(url)
    ## retrieve coords
    if(is.vector(x)){
            message(paste('Found', x[[1]]$display_name))
            lon <- x[[1]]$lon
            lat <- x[[1]]$lat
            osm_name <- x[[1]]$display_name
            coords <- data.frame('lon' = lon, 'lat' = lat, 'osm_name' = osm_name)
    }
    ## When x is not a vector
    else{
        message(paste('No results found for', City, CountryTwoLetter))
        coords <- data.frame('lon' = NA, 'lat' = NA)
    }
    ## return a df
    coords
}
```

My function `coords_from_city` is very primitive but it gets the job done. The reason for that is that when we first developed it we started searching for cities in European countries which are small and usually have unique languages so, names of the cities were not repeated per a given country, so the country name and the city was enough for most of it. But when we started focusing in bigger countries more parameters such as `state`, `county` and `region` started being used, so we started adding `if` commands here and there and the final function stayed in this primitive state. However I am sure you could easily think of a way to pass less parameters or make the function simpler knowing that each parameter has to be preceded by `&` and followed by`=` plus the parameter's value. An important detail to know is that often, providing values to `state` or `region` parameters returns similar results, this is particularly useful in countries where no states are used or other forms of organization are present.

The function returns a data frame that we will use later to create a table with all of our results. Since we are interested in creating maps, we only need the coordinates expressed in latitude and longitude parameters. In case the query is not found, it fills the values with `NA`'s, which later we'll use to keep track of what was found and what wasn't. We are also keeping the values inside `osm_name` which provides enough information to tell the user useful details regarding the search results, including the country of the city found, and other details like state or region. 

# Keeping the info in a database


```{r webscrap_to_sqlite}
webscrap_to_sqlite <- function(db.name,
                               dat,
                               city = 'City',
                               country = 'Country',
                               region = NULL,
                               state = NULL,
                               county = NULL)
{
    #require(tidyverse)
    require(RSQLite)
    df_len <- length(dat[[city]])
    ## Connect to db and table
    con <- dbConnect(drv=SQLite(), dbname=db.name)
    dbExecute(conn = con,
                "CREATE TABLE IF NOT EXISTS orgs
                    (ID INTEGER UNIQUE,
                     City TEXT, osm_name TEXT,
                     lon REAL,lat REAL)")
    ## -- Iteration to web-scrap data -- ##
    ccount <- 0
    ## For loop to webscrapping
    for(i in 1:df_len){
        print(paste('Entry', i))
        ## Check if the city details are already there
        searched.city <- dbGetQuery(conn = con,
                                    paste0("SELECT * FROM orgs WHERE City = '",
                                           dat[[city]][i],
                                           "' LIMIT 1"))
        ## If so, get them
        if(nrow(searched.city) != 0){
            message(paste0(dat[[city]][i], " already in DB!"))
            coords <- data.frame(osm_name = searched.city$osm_name,
                                 lon = searched.city$lon,
                                 lat = searched.city$lat)
        }
        ## Else, do the webscrap
        else{
            ## Else
            if(missing(region) & missing(county) & missing(state)){
                coords <- coords_from_city(dat[[city]][i],
                                           dat[[country]][i])
            }
            if(!missing(region)){
                coords <- coords_from_city(dat[[city]][i],
                                           dat[[country]][i],
                                           Region = dat[[region]][i])
            }
            if(!missing(state)){
                coords <- coords_from_city(dat[[city]][i],
                                           dat[[country]][i],
                                           State = dat[[state]][i])
            }
            if(!missing(county)){
                coords <- coords_from_city(dat[[city]][i],
                                           dat[[country]][i],
                                           County = dat[[county]][i])
            }
            if(!missing(county) & !missing(state)){
                coords <- coords_from_city(dat[[city]][i],
                                           dat[[country]][i],
                                           State = dat[[state]][i],
                                           County = dat[[county]][i])
            }
        }
        ## DB send query ONLY if coords were found
        if(is.na(coords$lon[1])){
            ccount <- ccount + 1
        }
        else{
            sq <- dbExecute(con, 'INSERT OR IGNORE INTO orgs
                             (ID, City, osm_name, lon, lat)
                             VALUES (?, ?, ?, ?, ?);',
                        list(dat[['ID']][i], dat[[city]][i],
                             coords$osm_name, coords$lon[1], coords$lat[1]))
        }
        print(paste('Completed', (i/df_len)*100, '%'))
    }
    ## Close db
    dbDisconnect(con)
    message(paste("WEB SCRAP FOR COORDINATES SEARCH FINISHED.",
                ccount, "ENTRIES NOT FOUND"))
}
```

# Missing data


```{r compare_db_data}
compare_db_data <- function(db.file, dat){
    require(tidyverse)
    require(RSQLite)
    if(is.character(dat)){
        if(grepl('.csv', dat, fixed = T)){
            tib <- read_csv(dat)
        }
        else{
            stop("Incorrect file format for data")
        }
    }
    else if(is.data.frame(dat)){
        tib <- dat
    }
    else{
        stop("Incorrect data format")
    }
    con <- dbConnect(drv=RSQLite::SQLite(), dbname = db.file)
    db <- as_tibble(dbReadTable(con, "orgs"))
    dbDisconnect(con)
    filtered <- filter(tib, !(as.character(ID) %in%
                              as.character(db$ID)))
    filtered
}
```


```{r add_coords_manually}
add_coords_manually <- function(csv_file, db.name,
                                city, osm_name, lat, lon){
    require(tidyverse)
    require(RSQLite)
    csv_dat <- read_csv(csv_file)
    csv_len <- length(csv_dat$ID)
    con <- dbConnect(drv=RSQLite::SQLite(), dbname=db.name)
    for(i in 1:csv_len){
        dbSendQuery(con, 'INSERT OR IGNORE INTO orgs
                      (ID, City, osm_name, lon, lat)
                      VALUES (?, ?, ?, ?, ?);',
                    list(csv_dat[['ID']][i],
                         csv_dat[[city]][i],
                         csv_dat[[osm_name]][i],
                         csv_dat[[lat]][i],
                         csv_dat[[lon]][i]))
    }
    dbDisconnect(con)
    print(paste(csv_len, 'inserted'))
}
```
