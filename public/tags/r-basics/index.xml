<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>R basics on R with White Dwarf</title>
    <link>https://blog.rwhitedwarf.com/tags/r-basics/</link>
    <description>Recent content in R basics on R with White Dwarf</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Tue, 29 Nov 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.rwhitedwarf.com/tags/r-basics/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>EDA de datos de INEGI</title>
      <link>https://blog.rwhitedwarf.com/es/post/2022/eda_inegi_datos/</link>
      <pubDate>Tue, 29 Nov 2022 00:00:00 +0000</pubDate>
      
      <guid>https://blog.rwhitedwarf.com/es/post/2022/eda_inegi_datos/</guid>
      <description>&lt;h2 id=&#34;introducción&#34;&gt;Introducción&lt;/h2&gt;
&lt;p&gt;El análisis exploratorio de datos (EDA en inglés, &amp;ldquo;Exploratory Data
Analysis&amp;rdquo;) es una de las herramientas más útiles en varias áreas
de análisis de datos. El concepto de EDA ha sido utilizado
popularmente en los últimos años para referirse a los procesos de
exploración primaria de un grupo de datos. Por lo tanto, no existe
una fórmula o receta para realizar una exploración, sea general o
exhaustiva. Una exploración correcta depende de las habilidades del analista tanto
para entender los datos como para utilizar las herramientas
adecuadas. Este post no pretende ser una explicación detallada
de como realizar un EDA, más bien intento compartir una de mis
experiencias haciendo haciendo ayuda de la programación funcional.&lt;/p&gt;
&lt;p&gt;La información que presento aquí son los resultados del primer
EDA que realicé cuando decidí cambiar mi carrera hacía el análisis
de datos. Es una serie de datos obtenidos del Instituto Nacional
de Estadística, Geografía e Informática de México, contiene información sobre
la cantidad, expresada en miles de dolares, de las exportaciones por año de
cada estado. Me pareció un ejemplo adecuado ya que yo no tengo
mucho conocimiento en economía o exportación, por lo tanto este
ejemplo no contiene ningún análisis numérico detallado o complicado,
si no mas bien una exploración general de los datos obtenidos.
Los datos han sido tomados de la pagina oficial de &lt;a href=&#34;https://www.inegi.org.mx/&#34; target=&#34;_blank&#34;&gt;INEGI&lt;/a&gt; en formato
de excel. El INEGI es una de las bases de datos más importantes de México,
su web contiene bases de datos públicas en temas de geografía y
estadística. Si estas buscando datos para practicar tus habilidades
en R o como analista de datos te recomiendo darle un vistazo.
Aquí presento una versión de los datos que yo mismo he arreglado para
su uso en R, los cuales pueden ser descargados en formato CSV
desde mi repositorio de github &lt;a href=&#34;https://github.com/teotenn/INEGI-export&#34; target=&#34;_blank&#34;&gt;INEGI-export&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://blog.rwhitedwarf.com/post/2022/EDA_INEGI_data/INEGI.jpg&#34; alt=&#34;INEGI&#34; /&gt;
&lt;/p&gt;
&lt;p&gt;El proceso de EDA resulta útil no sólo para profesionales analistas
de datos, si no en un amplio rango de actividades para conocer y
entender los datos que se manejan. En muchos casos los análisis de
datos incluyen complicadas fórmula matemáticas en grandes series
numéricas que no son entendidas, simplemente procesadas y reducidas
a pequeños números que representan algo, como medias, rangos,
estadísticos, etc. El análisis exploratorio de datos nos permite
entender un poco mas que significan esos número, de donde vienen,
y que se puede extraer de ellos. Los datos son siempre generados en
base a la información, el EDA es una herramienta para entender esa
información.&lt;/p&gt;
&lt;h2 id=&#34;análisis-exploratorio-exploratory-data-analysis-eda&#34;&gt;Análisis exploratorio (Exploratory Data Analysis, EDA)&lt;/h2&gt;
&lt;p&gt;Vamos a comenzar llamando directamente las librerías o módulos
(en R &lt;code&gt;library&lt;/code&gt;) que necesitamos para hacer nuestro análisis, y
leyendo los archivos CSV en la memoria de R. Esto puede ser
realizado conforme se va utilizando, sin embargo es recomendable
importar todas las librerías y archivos al inicio de nuestro código
o script, para evitar errores o problemas de organización.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;  library(tidyverse)
  library(cowplot)

  path.to.files &amp;lt;- &amp;quot;https://raw.githubusercontent.com/teotenn/INEGI-export/master/&amp;quot;
  export.rows &amp;lt;- read_csv(paste0(path.to.files, &amp;quot;exportations_activity_rows.csv&amp;quot;))
  export.cols &amp;lt;- read_csv(paste0(path.to.files, &amp;quot;exportations_activity_cols.csv&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Las librerías son básicamente programas escritos en R que contienen
el código necesario para realizar, o más bien llamar ciertas funciones especificas
de cada librería. En español son popularmente conocidas como
paquetes o módulos. En este caso vamos a utilizar &lt;code&gt;tidyverse&lt;/code&gt; y
&lt;code&gt;cowplot&lt;/code&gt;. La librería &lt;code&gt;cowplot&lt;/code&gt; nos va a ayudar a colocar varias gráficas de forma
fácil y ordenada en un sólo espacio.&lt;/p&gt;
&lt;p&gt;En cuanto a la librería &lt;code&gt;tidyverse&lt;/code&gt; ofrece enormes ventajas (aunque también
pocas desventajas) para el análisis de datos. Al llamar esta
librería incluye una serie de librerías que contienen diferentes
tipos de herramientas para facilitar y organizar el análisis de
datos. En este post vamos a utilizar principalmente:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ggplot2&lt;/code&gt; Que facilita la creación de gráficas con el sistema de capas (The Language of Graphics escrito por Leland Wilkinson, 2000)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dplyr&lt;/code&gt; que nos ayuda a mandar resultados de un proceso al siguiente utilizando los famosos &lt;code&gt;%&amp;gt;%&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tibble&lt;/code&gt; que facilita la manipulación de tablas, transformando los tradicionales &lt;code&gt;data.frame&lt;/code&gt; de R a un formato mas amigable visualmente.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Si lo deseas, también podrías llamar estas tres librerías de una por una en
lugar de llamar todo el tidyverse de principio. El resultado será el mismo.&lt;/p&gt;
&lt;p&gt;Entre otras desventajas de estos paquetes es que no funcionan
muy bien cuando la cantidad de datos es muy grande (miles de
millones de filas), en cuyo caso se recomiendan otras herramientas
como &lt;a href=&#34;https://cran.r-project.org/web/packages/data.table/vignettes/datatable-intro.html&#34; target=&#34;_blank&#34;&gt;Data Table&lt;/a&gt; que funciona de forma un poco mas similar al tradicional
&lt;code&gt;data.frame&lt;/code&gt; de R. Más información sobre &lt;code&gt;tidyverse&lt;/code&gt; puede ser
encontrada en su página oficial,
(&lt;a href=&#34;https://www.tidyverse.org/&#34; target=&#34;_blank&#34;&gt;https://www.tidyverse.org/&lt;/a&gt;) o en el e-book &lt;a href=&#34;https://r4ds.had.co.nz/&#34; target=&#34;_blank&#34;&gt;R for data science&lt;/a&gt;
escrito por uno de los creadores de la librería. Un buen libro en
español es &lt;a href=&#34;https://www.datanalytics.com/libro_r/index.html&#34; target=&#34;_blank&#34;&gt;R para profesionales de los datos&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;organizando-los-datos&#34;&gt;Organizando los datos&lt;/h3&gt;
&lt;p&gt;Lo primero que debemos hacer es organizar los datos a un formato que sea mas amigable con R, y también con nuestras necesidades de análisis. Como ya he mencionado antes, yo manipulé los datos con anterioridad para tenerlos en un formato amigable con R. Por otro lado, algunas variables presentan nombres demasiado largos, por lo que he decididos reducirlos un poco para facilitar mi trabajo.&lt;/p&gt;
&lt;p&gt;Este análisis lo realicé primordialmente en inglés, por lo tanto
he decidido mantener
el código en inglés por facilidad para mi por un lado, pero también
por el beneficio de ser mas amigable con R en general, y de generar
nombres mas cortos. Así pues, algunos valores se mantendrán en español
y otros han sido traducidos para la manipulación de los datos.&lt;/p&gt;
&lt;p&gt;El siguiente bloque contiene la traducción de las actividades de exportación,
para generar nombres en inglés mas accesibles. Lo
primero fue guardar los nombres en español en un vector, para
utilizarlos más tarde en la traducción; también generamos un vector
del mismo tamaño, con su equivalente en Inglés (en exactamente el mismo orden).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;   ## Nombres en español en un vector
   colnames(export.cols)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;  [1] &amp;quot;state&amp;quot;                                                                                                                 
&amp;gt;  [2] &amp;quot;year&amp;quot;                                                                                                                  
&amp;gt;  [3] &amp;quot;Exportaciones totales&amp;quot;                                                                                                 
&amp;gt;  [4] &amp;quot;Industria alimentaria&amp;quot;                                                                                                 
&amp;gt;  [5] &amp;quot;Industria de las bebidas y el tabaco&amp;quot;                                                                                  
&amp;gt;  [6] &amp;quot;Fabricación de insumos textiles y acabado de textiles&amp;quot;                                                                 
&amp;gt;  [7] &amp;quot;Fabricación de productos textiles, excepto prendas de vestir&amp;quot;                                                          
&amp;gt;  [8] &amp;quot;Fabricación de prendas de vestir&amp;quot;                                                                                      
&amp;gt;  [9] &amp;quot;Industria del papel&amp;quot;                                                                                                   
&amp;gt; [10] &amp;quot;Industria química&amp;quot;                                                                                                     
&amp;gt; [11] &amp;quot;Industria del plástico y del hule&amp;quot;                                                                                     
&amp;gt; [12] &amp;quot;Fabricación de productos a base de minerales no metálicos&amp;quot;                                                             
&amp;gt; [13] &amp;quot;Industrias metálicas básicas&amp;quot;                                                                                          
&amp;gt; [14] &amp;quot;Fabricación de productos metálicos&amp;quot;                                                                                    
&amp;gt; [15] &amp;quot;Fabricación de maquinaria y equipo&amp;quot;                                                                                    
&amp;gt; [16] &amp;quot;Fabricación de equipo de computación, comunicación, medición y de otros equipos, componentes y accesorios electrónicos&amp;quot;
&amp;gt; [17] &amp;quot;Fabricación de equipo de transporte&amp;quot;                                                                                   
&amp;gt; [18] &amp;quot;Fabricación de muebles, colchones y persianas&amp;quot;                                                                         
&amp;gt; [19] &amp;quot;Otras industrias manufactureras&amp;quot;                                                                                       
&amp;gt; [20] &amp;quot;Subsectores no especificados&amp;quot;                                                                                          
&amp;gt; [21] &amp;quot;Minería de minerales metálicos y no metálicos, excepto petróleo y gas&amp;quot;                                                 
&amp;gt; [22] &amp;quot;Curtido y acabado de cuero y piel, y fabricación de productos de cuero, piel y materiales sucedáneos&amp;quot;                  
&amp;gt; [23] &amp;quot;Industria de la madera&amp;quot;                                                                                                
&amp;gt; [24] &amp;quot;Impresión e industrias conexas&amp;quot;                                                                                        
&amp;gt; [25] &amp;quot;Fabricación de accesorios, aparatos eléctricos y equipo de generación de energía eléctrica&amp;quot;                            
&amp;gt; [26] &amp;quot;Extracción de petróleo y gas&amp;quot;                                                                                          
&amp;gt; [27] &amp;quot;Fabricación de productos derivados del petróleo y del carbón&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;   categorias &amp;lt;- colnames(export.cols)[3:27]

   ## Equivalentes en inglés 
   activities.en &amp;lt;- c(&amp;quot;Total&amp;quot;, &amp;quot;Food&amp;quot;, &amp;quot;Drinks and tobacco&amp;quot;,
                   &amp;quot;Textiles&amp;quot;, &amp;quot;Textile products&amp;quot;, &amp;quot;Tailoring&amp;quot;,
                   &amp;quot;Paper&amp;quot;, &amp;quot;Chemistry&amp;quot;, &amp;quot;Plastic&amp;quot;,
                   &amp;quot;Minerals based&amp;quot;, &amp;quot;Metal industry&amp;quot;, &amp;quot;Metal products&amp;quot;,
                   &amp;quot;Machinery&amp;quot;, &amp;quot;Electronics&amp;quot;, &amp;quot;Transport equipment&amp;quot;,
                   &amp;quot;Furniture&amp;quot;, &amp;quot;Other manufactures&amp;quot;, &amp;quot;Not specified&amp;quot;,
                   &amp;quot;Mining&amp;quot;, &amp;quot;Leather&amp;quot;, &amp;quot;Wood&amp;quot;,
                   &amp;quot;Printing&amp;quot;, &amp;quot;Electricity&amp;quot;, &amp;quot;Petroleum&amp;quot;,
                   &amp;quot;Petroleum products&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Para cambiar los nombres de las columnas, podemos hacerlo
directamente con la función &lt;code&gt;colnames&lt;/code&gt;, seleccionando la posición
de los valores que queremos cambiar (en este caso, 3 al 27) y
colocando ahí los nuevos valores en inglés.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;   ## Cambio de nombres
   colnames(export.cols)[3:27] &amp;lt;- activities.en
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Para cambiar los valores en &lt;code&gt;export.rows&lt;/code&gt; vamos a necesitar la
conversión de las expresiones en español a las mismas en inglés.
Aquí he utilizado herramientas de programación basada en funciones
(Functional Programming) para generar primero la función
principal para traducir &lt;code&gt;translate&lt;/code&gt;. Aquí le estoy diciendo a
&lt;code&gt;translate&lt;/code&gt; exactamente lo que necesito hacer, sin preocuparme si
R puede hacerlo o no. Por ejemplo, utilizo la función &lt;code&gt;equivalent&lt;/code&gt;,
que no existe en R, pero que, basado en mis expectaciones, debe
buscar el equivalente en inglés de la frase en español. Así pues,
basado en &lt;code&gt;translatete&lt;/code&gt;, vamos llenando los huecos, creando la
función &lt;code&gt;equivalent&lt;/code&gt; que haga exactamente lo que necesito.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;   translate &amp;lt;- function(vector.es){
    vector.en &amp;lt;- c()
    for (i in 1:length(vector.es)){
        expression.es &amp;lt;- vector.es[i]
        expression.en &amp;lt;- equivalent(expression.es)
        ## &amp;quot;equivalent&amp;quot; toma expression.es y regresa el
        ## equivalente en ingles
        vector.en &amp;lt;- append(vector.en, expression.en)
    }
    vector.en
   }
   
  equivalent &amp;lt;- function(expression.es){
      position &amp;lt;- match(expression.es, categorias)
      expression.en &amp;lt;- activities.en[position]
      expression.en
  }

## Probando nuestra nueva función
   equivalent(&amp;quot;Impresión e industrias conexas&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; [1] &amp;quot;Printing&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Como podemos ver, &lt;code&gt;equivalent&lt;/code&gt; toma la expresión de nuestro vector
en español, y arroja el equivalente que le hemos elegido en inglés.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;   translate(categorias)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;  [1] &amp;quot;Total&amp;quot;               &amp;quot;Food&amp;quot;                &amp;quot;Drinks and tobacco&amp;quot; 
&amp;gt;  [4] &amp;quot;Textiles&amp;quot;            &amp;quot;Textile products&amp;quot;    &amp;quot;Tailoring&amp;quot;          
&amp;gt;  [7] &amp;quot;Paper&amp;quot;               &amp;quot;Chemistry&amp;quot;           &amp;quot;Plastic&amp;quot;            
&amp;gt; [10] &amp;quot;Minerals based&amp;quot;      &amp;quot;Metal industry&amp;quot;      &amp;quot;Metal products&amp;quot;     
&amp;gt; [13] &amp;quot;Machinery&amp;quot;           &amp;quot;Electronics&amp;quot;         &amp;quot;Transport equipment&amp;quot;
&amp;gt; [16] &amp;quot;Furniture&amp;quot;           &amp;quot;Other manufactures&amp;quot;  &amp;quot;Not specified&amp;quot;      
&amp;gt; [19] &amp;quot;Mining&amp;quot;              &amp;quot;Leather&amp;quot;             &amp;quot;Wood&amp;quot;               
&amp;gt; [22] &amp;quot;Printing&amp;quot;            &amp;quot;Electricity&amp;quot;         &amp;quot;Petroleum&amp;quot;          
&amp;gt; [25] &amp;quot;Petroleum products&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;translate&lt;/code&gt; toma todos los elementos en el vector, y nos arroja sus
equivalentes en inglés. Así pues, para transformar todos los
valores en la columna &lt;code&gt;Descripción&lt;/code&gt; a su equivalente en inglés he
decidido generar una nueva columna, utilizando mi función
&lt;code&gt;translate&lt;/code&gt;. Esto es muy fácil utilizando &lt;code&gt;mutate&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;  (export.rows &amp;lt;- mutate(export.rows,
                         Activity = translate(`Descripción`)))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; # A tibble: 5,255 × 6
&amp;gt;    Código Descripción           state           year     USD Activity
&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;                 &amp;lt;chr&amp;gt;          &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;   
&amp;gt;  1     NA Exportaciones totales Aguascalientes  2007 4389841 Total   
&amp;gt;  2     NA Exportaciones totales Aguascalientes  2008 4456893 Total   
&amp;gt;  3     NA Exportaciones totales Aguascalientes  2009 3951108 Total   
&amp;gt;  4     NA Exportaciones totales Aguascalientes  2010 5647929 Total   
&amp;gt;  5     NA Exportaciones totales Aguascalientes  2011 6051640 Total   
&amp;gt;  6     NA Exportaciones totales Aguascalientes  2012 6183782 Total   
&amp;gt;  7     NA Exportaciones totales Aguascalientes  2013 6726207 Total   
&amp;gt;  8     NA Exportaciones totales Aguascalientes  2014 8466007 Total   
&amp;gt;  9     NA Exportaciones totales Aguascalientes  2015 8495445 Total   
&amp;gt; 10     NA Exportaciones totales Aguascalientes  2016 7870962 Total   
&amp;gt; # … with 5,245 more rows
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;exploración-visual&#34;&gt;Exploración visual&lt;/h3&gt;
&lt;p&gt;Ahora para empezar formalmente nuestro EDA, vamos a darle un vistazo
a los totales por estado, utilizando nuestra tabla &lt;code&gt;export.cols&lt;/code&gt;.
Aquí utilizamos los famosos pipe &lt;code&gt;%&amp;gt;%&lt;/code&gt; que mandan los resultados
de un proceso, al siguiente proceso, por ejemplo, si queremos ver
los totales por estado, podemos pedirle a R que haga lo siguiente&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   toma la tabla export.cols %&amp;gt;%
      agrupa los datos por estado (state) %&amp;gt;%
      redúcelos a la sumatoria del total, nómbrala total export %&amp;gt;%
      organiza en forma descendente basado en total export %&amp;gt;%
      muestra en pantalla todo (n = Inf)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;La versión en R utilizando el paquete &lt;code&gt;dplyr&lt;/code&gt; es:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;export.cols %&amp;gt;%
    group_by(state) %&amp;gt;%
    summarise(`total export` = sum(Total)) %&amp;gt;%
    arrange(desc(`total export`)) %&amp;gt;%
    print(n = Inf)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; # A tibble: 32 × 2
&amp;gt;    state                           `total export`
&amp;gt;    &amp;lt;chr&amp;gt;                                    &amp;lt;dbl&amp;gt;
&amp;gt;  1 Chihuahua                            466861927
&amp;gt;  2 Baja California                      398935507
&amp;gt;  3 Coahuila de Zaragoza                 355638907
&amp;gt;  4 Nuevo León                           330267052
&amp;gt;  5 Tamaulipas                           284435973
&amp;gt;  6 Campeche                             264100465
&amp;gt;  7 Jalisco                              213931233
&amp;gt;  8 México                               188357470
&amp;gt;  9 Sonora                               179661021
&amp;gt; 10 Guanajuato                           167191962
&amp;gt; 11 Puebla                               127934390
&amp;gt; 12 Tabasco                              115797563
&amp;gt; 13 San Luis Potosí                       94812554
&amp;gt; 14 Querétaro                             88633615
&amp;gt; 15 Aguascalientes                        79688240
&amp;gt; 16 Veracruz de Ignacio de la Llave       68556313
&amp;gt; 17 Morelos                               37397175
&amp;gt; 18 Zacatecas                             34010223
&amp;gt; 19 Ciudad de México                      32037661
&amp;gt; 20 Hidalgo                               19504479
&amp;gt; 21 Durango                               17431796
&amp;gt; 22 Yucatán                               14496875
&amp;gt; 23 Michoacán de Ocampo                   13411397
&amp;gt; 24 Chiapas                               13291536
&amp;gt; 25 Tlaxcala                              12987607
&amp;gt; 26 Oaxaca                                11023551
&amp;gt; 27 Sinaloa                                7825439
&amp;gt; 28 Guerrero                               5918438
&amp;gt; 29 Colima                                 2518028
&amp;gt; 30 Baja California Sur                    2303491
&amp;gt; 31 Nayarit                                1146388
&amp;gt; 32 Quinta Roo                              517674
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Gracias a la agrupación de tidyverse, podemos utilizar estas
herramientas con muchas otras funciones, entre otras, podemos
mandar resultados a un gráfico &lt;code&gt;ggplot&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;   ## Visualización
  export.cols %&amp;gt;%
      group_by(state) %&amp;gt;%
      summarise(`total export` = sum(Total)) %&amp;gt;%
      ggplot() +
      geom_bar(aes(y = `total export`,
                   x = reorder(state, `total export`, FUN = abs),
                   fill = `total export`),
               stat = &#39;identity&#39;) +
      coord_flip()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://blog.rwhitedwarf.com/post/2022/EDA_INEGI_data/primer-ggplot-1.png&#34; alt=&#34;plot of chunk primer-ggplot&#34; /&gt;
&lt;/p&gt;
&lt;p&gt;En el bloque anterior comenzamos con algo similar, y mandamos los
resultados a &lt;code&gt;ggplot()&lt;/code&gt;, así que ya no es necesario especificar
dentro de la función &lt;code&gt;ggplot&lt;/code&gt; de donde tomar los datos, por lo
tanto esta función se queda vacía. &lt;code&gt;geom_bar&lt;/code&gt; genera un gráfico de barras,
que de forma típica toma los valores numéricos en el eje Y y los
valores categóricos en el eje X. Esto lo especificamos dentro de
la función &lt;code&gt;aes&lt;/code&gt; (por &amp;ldquo;aestetics&amp;rdquo;, o estética). Otra de las ventajas es que podemos llamar funciones dentro de funciones de gráficos
ggplot, por ejemplo, en &lt;code&gt;x&lt;/code&gt; utilizo la función &lt;code&gt;reorder&lt;/code&gt; para
ordenar los resultados por los valores de &lt;code&gt;total export&lt;/code&gt;, basado
en el valor absoluto (&lt;code&gt;FUN = abs&lt;/code&gt;). También, dentro de &lt;code&gt;aes&lt;/code&gt; he
declarado &lt;code&gt;fill = total export&lt;/code&gt; para que llene las barras en base
a los valores de &lt;code&gt;total export&lt;/code&gt;. Es importante no confundir &lt;code&gt;fill&lt;/code&gt;
con &lt;code&gt;color&lt;/code&gt;, el cual cambia simplemente los contornos de las
barras. También es importante especificar &lt;code&gt;fill&lt;/code&gt; dentro de &lt;code&gt;aes&lt;/code&gt;
cuando queremos darle un valor basado en nuestros datos categóricos; o bien,
se puede colocar fuera de &lt;code&gt;aes&lt;/code&gt; para darle un valor constante.
&lt;code&gt;stat = &#39;identity&#39;&lt;/code&gt; y &lt;code&gt;coord_flip()&lt;/code&gt; nos ayudan a ordenar las
barras, y cambiar el eje de las Y por X, respectivamente.&lt;/p&gt;
&lt;p&gt;Ahora podemos hacer lo mismo pero por categoría,
usando nuestra otra tabla &lt;code&gt;export.rows&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;export.rows %&amp;gt;%
    filter(Activity != &amp;quot;Total&amp;quot;) %&amp;gt;%
    group_by(Activity) %&amp;gt;%
    summarise(Total = sum(USD)) %&amp;gt;%
    arrange(desc(Total)) %&amp;gt;%
    print(n = Inf)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; # A tibble: 24 × 2
&amp;gt;    Activity                 Total
&amp;gt;    &amp;lt;chr&amp;gt;                    &amp;lt;dbl&amp;gt;
&amp;gt;  1 Transport equipment 1226859499
&amp;gt;  2 Electronics          747959073
&amp;gt;  3 Petroleum            397933968
&amp;gt;  4 Electricity          208582754
&amp;gt;  5 Other manufactures   147915402
&amp;gt;  6 Machinery            136957553
&amp;gt;  7 Chemistry            133570853
&amp;gt;  8 Metal industry       117915995
&amp;gt;  9 Metal products        82889135
&amp;gt; 10 Food                  81653585
&amp;gt; 11 Plastic               80126816
&amp;gt; 12 Mining                52953993
&amp;gt; 13 Not specified         51470567
&amp;gt; 14 Tailoring             43913959
&amp;gt; 15 Drinks and tobacco    31059501
&amp;gt; 16 Minerals based        30584505
&amp;gt; 17 Furniture             19883596
&amp;gt; 18 Petroleum products    14565067
&amp;gt; 19 Paper                 13876523
&amp;gt; 20 Leather                9863853
&amp;gt; 21 Printing               6915538
&amp;gt; 22 Textiles               6260722
&amp;gt; 23 Textile products       4954252
&amp;gt; 24 Wood                   1959275
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Para variar un poco y hacerlo mas didáctico, vamos a cambiar
algunos detalles, manteniéndolo simple:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Vamos a colocar &lt;code&gt;fill&lt;/code&gt; afuera de &lt;code&gt;aes&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Vamos a cambiar el valor de &lt;code&gt;color&lt;/code&gt; para observar la diferencia&lt;/li&gt;
&lt;li&gt;Vamos a renombrar el eje de las X&lt;/li&gt;
&lt;li&gt;Vamos a darle un título&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;export.rows %&amp;gt;%
    filter(Activity != &amp;quot;Total&amp;quot;) %&amp;gt;%
    group_by(Activity) %&amp;gt;%
    summarise(Total = sum(USD)) %&amp;gt;%
    ggplot() +
    geom_bar(aes(y = Total,
                 x = reorder(Activity, Total, FUN = abs)),
             fill = &amp;quot;darkblue&amp;quot;,
             color = &amp;quot;purple&amp;quot;,
             stat = &#39;identity&#39;) +
    labs(title = &amp;quot;Exportaciones totales por actividad&amp;quot;,
         x = &amp;quot;Activity&amp;quot;) +
    coord_flip()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://blog.rwhitedwarf.com/post/2022/EDA_INEGI_data/new-plot-1.png&#34; alt=&#34;plot of chunk new-plot&#34; /&gt;
&lt;/p&gt;
&lt;p&gt;Ahora de manera fácil e intuitiva podemos observar que cambios
en el código fueron responsables de que cambios en el gráfico.&lt;/p&gt;
&lt;p&gt;Por último, podemos hacer algo similar con las exportaciones
totales por año.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;export.cols %&amp;gt;%
    group_by(year) %&amp;gt;%
    summarise(`total export` = sum(Total)) %&amp;gt;%
    print(n = Inf)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; # A tibble: 12 × 2
&amp;gt;     year `total export`
&amp;gt;    &amp;lt;dbl&amp;gt;          &amp;lt;dbl&amp;gt;
&amp;gt;  1  2007      237809741
&amp;gt;  2  2008      257967777
&amp;gt;  3  2009      198234125
&amp;gt;  4  2010      258504747
&amp;gt;  5  2011      299732519
&amp;gt;  6  2012      320014188
&amp;gt;  7  2013      329562705
&amp;gt;  8  2014      347559680
&amp;gt;  9  2015      337170197
&amp;gt; 10  2016      324901419
&amp;gt; 11  2017      351726063
&amp;gt; 12  2018      387442789
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ahora en lugar de hacer un gráfico de barras, vamos a hacer líneas
y puntos. Vamos a cambiar otro detalle: en lugar de especificar
&lt;code&gt;aes&lt;/code&gt; dentro del geometric, que en este caso tendría que escribirse dos
veces exactamente lo mismo, uno dentro de &lt;code&gt;geom_line&lt;/code&gt; y otro en &lt;code&gt;geom_point&lt;/code&gt;,
podemos especificarlo dentro de la función principal del gráfico
&lt;code&gt;ggplot()&lt;/code&gt;, de esta forma los valores que especifiquemos ahí serán
tomados como los valores principales, y no necesitamos darle mas
detalles a &lt;code&gt;geom_line&lt;/code&gt; ni &lt;code&gt;geom_point&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;   ## Visualization
export.rows %&amp;gt;%
    filter(Activity == &amp;quot;Total&amp;quot;) %&amp;gt;%
    group_by(year) %&amp;gt;%
    summarise(Total = sum(USD)) %&amp;gt;%
    ggplot(aes(x = year, y = Total)) +
    geom_line() +
    geom_point() 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://blog.rwhitedwarf.com/post/2022/EDA_INEGI_data/ggplot-detailed-1.png&#34; alt=&#34;plot of chunk ggplot-detailed&#34; /&gt;
&lt;/p&gt;
&lt;p&gt;Podemos hacer lo mismo por estado. Aquí, debido a la complejidad de
los nombres de algunos estados, he decidido abreviar los nombres
de cada estado a sólo 6 letras, usando la función &lt;code&gt;abbreviate&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;   ## Por estado
export.rows %&amp;gt;%
    filter(Activity == &amp;quot;Total&amp;quot;) %&amp;gt;%
    group_by(year, state) %&amp;gt;%
    summarise(Total = sum(USD)) %&amp;gt;%
    ggplot(aes(x = year, y = Total)) +
    geom_line(aes(colour = abbreviate(state, 6)))+
    geom_point(aes(colour = abbreviate(state, 6)))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://blog.rwhitedwarf.com/post/2022/EDA_INEGI_data/abbreviate-1.png&#34; alt=&#34;plot of chunk abbreviate&#34; /&gt;
&lt;/p&gt;
&lt;p&gt;Gracias a &lt;code&gt;abbreviate&lt;/code&gt; los nombres de los estados se pueden
entender, sin embargo, a pesar de los colores y el texto, es
difícil apreciar propiamente 32 líneas (número total de estados en el país).&lt;/p&gt;
&lt;p&gt;Por otro lado nos gustaría ver si cada año fue el mismo estado o
la misma
actividad produciendo la mayor cantidad de dolares en exportaciones, o
si esto cambió con el tiempo. Debido a la complejidad de nuestro
gráfico anterior, necesitamos un acercamiento diferente:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;   ## Principal estado en cada año
export.cols %&amp;gt;%
    group_by(year) %&amp;gt;%
    filter(Total == max(Total)) %&amp;gt;%
    select(year, state, Total) %&amp;gt;%
    arrange(year)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; # A tibble: 12 × 3
&amp;gt; # Groups:   year [12]
&amp;gt;     year state              Total
&amp;gt;    &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;              &amp;lt;dbl&amp;gt;
&amp;gt;  1  2007 Baja California 31858677
&amp;gt;  2  2008 Baja California 32988913
&amp;gt;  3  2009 Baja California 26741828
&amp;gt;  4  2010 Chihuahua       34633881
&amp;gt;  5  2011 Chihuahua       38446014
&amp;gt;  6  2012 Chihuahua       41764861
&amp;gt;  7  2013 Chihuahua       43770979
&amp;gt;  8  2014 Chihuahua       45594451
&amp;gt;  9  2015 Chihuahua       40302945
&amp;gt; 10  2016 Chihuahua       43342067
&amp;gt; 11  2017 Chihuahua       46491551
&amp;gt; 12  2018 Chihuahua       51944047
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Los resultados son interesantes: el principal exportador hasta 2009
es Baja California, y después Chihuahua. Sin embargo, si observamos
las principales actividades exportadores, tenemos en primer lugar
a Campeche hasta 2013 y después  es Coahuila. Parece ser que
ciertas actividades no tienen mucha diferencia en la cantidad de
ingresos entre ellas, y por eso ciertas combinaciones resultan
en mayor nivel de exportación para ciertos estados. Por ejemplo,
Capeche es el principal exportador de Petroleo, y se mantiene en
primer lugar cuando ordenamos por actividad, sin embargo pasa al
sexto lugar cuando ordenamos por estado.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;## Activity
export.rows %&amp;gt;%
    filter(Activity != &amp;quot;Total&amp;quot;) %&amp;gt;%
    group_by(year) %&amp;gt;%
    filter(USD == max(USD)) %&amp;gt;%
    arrange(year) %&amp;gt;%
    select(Activity, state, year)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; # A tibble: 12 × 3
&amp;gt; # Groups:   year [12]
&amp;gt;    Activity            state                 year
&amp;gt;    &amp;lt;chr&amp;gt;               &amp;lt;chr&amp;gt;                &amp;lt;dbl&amp;gt;
&amp;gt;  1 Petroleum           Campeche              2007
&amp;gt;  2 Petroleum           Campeche              2008
&amp;gt;  3 Petroleum           Campeche              2009
&amp;gt;  4 Petroleum           Campeche              2010
&amp;gt;  5 Petroleum           Campeche              2011
&amp;gt;  6 Petroleum           Campeche              2012
&amp;gt;  7 Petroleum           Campeche              2013
&amp;gt;  8 Transport equipment Coahuila de Zaragoza  2014
&amp;gt;  9 Transport equipment Coahuila de Zaragoza  2015
&amp;gt; 10 Transport equipment Coahuila de Zaragoza  2016
&amp;gt; 11 Transport equipment Coahuila de Zaragoza  2017
&amp;gt; 12 Transport equipment Coahuila de Zaragoza  2018
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Sería interesante cambiar la manera de analizar los datos y
observar los principales exportadores junto con las principales
actividades.&lt;/p&gt;
&lt;h2 id=&#34;visualizaciones-interactivas-utilizando-funciones&#34;&gt;Visualizaciones interactivas utilizando funciones&lt;/h2&gt;
&lt;p&gt;En el área del análisis de datos, el uso de funciones resulta útil
en varios casos. Como vimos anteriormente, nuestra función
&lt;code&gt;translate&lt;/code&gt; nos ayudó a aplicarla en cada elemento de un vector
(en este caso, una columna). Este procesos de aplicar una función
en todos los elementos de una lista se conoce tradicionalmente en
el albur de programación como &amp;ldquo;map&amp;rdquo;. Otra uso importante de
funciones personalizadas es para hacer más eficiente el análisis,
por ejemplo cuando necesitamos repetir un proceso mas de una vez.&lt;/p&gt;
&lt;p&gt;En programación se tienen estándares al escribir código sobre no repetirte
a ti mismo, y se crean funciones o macros para básicamente cualquier
tarea que deba ser repetida al menos una vez. Como analista de datos
esto no es estrictamente necesario, sin embargo nos ahorra tiempo y
esfuerzo y al mismo tiempo nos ayuda a entender mejor el lenguaje
de programación que estamos utilizando para analizar nuestros datos.&lt;/p&gt;
&lt;p&gt;Como ejemplo, supongamos que queremos hacer visualizaciones de
las principales actividades por estado, por ejemplo, actividades
que generen mas de 5 millones de dolares. Podríamos escribir lo
siguiente&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;  export.rows %&amp;gt;%
      filter(Activity != &amp;quot;Total&amp;quot;) %&amp;gt;%
      group_by(state, Activity)  %&amp;gt;%
      summarise(Total = sum(USD)) %&amp;gt;%
      filter(state == &amp;quot;Chihuahua&amp;quot; &amp;amp;
             Total &amp;gt;= 5000000) %&amp;gt;%
      ggplot() +
      geom_bar(aes(y = Total,
                   x = reorder(Activity, Total, FUN = abs),
                   fill = Total),
               stat = &#39;identity&#39;) +
      coord_flip() +
      labs(title = &amp;quot;Chihuahua&amp;quot;,
           y = &amp;quot;Total USD&amp;quot;, x = NULL) +
      theme(legend.position=&amp;quot;none&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://blog.rwhitedwarf.com/post/2022/EDA_INEGI_data/five-mil-code-1.png&#34; alt=&#34;plot of chunk five-mil-code&#34; /&gt;
&lt;/p&gt;
&lt;p&gt;Sin embargo, tendríamos que repetir el mismo bloque de código por
cada estado que queremos visualizar, o si queremos cambiar el límite de 5 millones.
La mejor opción en este caso
es generar una función que nos permita hacer lo mismo cambiando
simplemente las variables que queremos. La manera mas fácil es repetir
el código anterior dentro de una función, cambiando el nombre
&amp;ldquo;Chihuahua&amp;rdquo; por una variable que podamos modificar cada vez que
llamemos la función, vamos a llamarla &lt;code&gt;estado&lt;/code&gt;. Por otro lado,
en lugar de filtrar sólo actividades
que producen mas de 5 millones de dolares, vamos a permitir que
este filtro también sea interactivo, sin embargo tomando el valor
de 5 millones por default.&lt;/p&gt;
&lt;p&gt;Veamos el siguiente bloque para entender mejor.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;  ## Funcion para ver principal actividad por estado
  plot_state &amp;lt;- function(estado, USD_min = 5000000){
      export.rows %&amp;gt;%
          filter(Activity != &amp;quot;Total&amp;quot;) %&amp;gt;%
          group_by(state, Activity)  %&amp;gt;%
          summarise(Total = sum(USD)) %&amp;gt;%
          filter(state == estado &amp;amp;
                 Total &amp;gt;= USD_min) %&amp;gt;%
          ggplot() +
          geom_bar(aes(y = Total,
                       x = reorder(Activity, Total, FUN = abs),
                       fill = Total),
                   stat = &#39;identity&#39;) +
          coord_flip() +
          labs(title = estado,
               y = &amp;quot;Total USD&amp;quot;, x = NULL) +
          theme(legend.position=&amp;quot;none&amp;quot;)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;El nombre de nuestra función es &lt;code&gt;plot_state&lt;/code&gt; y lo definimos como
cualquier otro objeto en R, utilizando &lt;code&gt;&amp;lt;-&lt;/code&gt; y la función
&lt;code&gt;function&lt;/code&gt;. Dentro de los paréntesis de &lt;code&gt;function&lt;/code&gt; debemos colocar
nuestras variables, aquellos valores que podrán ser modificados al
llamar la función. En este caso definimos &lt;code&gt;estado&lt;/code&gt; que nos ayudará
a seleccionar el estado a visualizar, y &lt;code&gt;USD_min&lt;/code&gt; para definir
la cantidad mínima de dolares a visualizar (por ejemplo, si hacemos
&lt;code&gt;USD_min = 0&lt;/code&gt; nuestra función graficaría todas las actividades,
siempre y cuando produzcan mas de cero). También podemos ver que
aquí he definido &lt;code&gt;USD_min = 5000000&lt;/code&gt;, esto genera un valor por
default, es decir, si llamamos nuestra función
&lt;code&gt;plot_state(&amp;quot;Chihuahua&amp;quot;)&lt;/code&gt; obtendremos las actividades que producen
mas de 5 millones en Chiuahua, sin embargo, si llamamos
&lt;code&gt;plot_state(&amp;quot;Chihuahua&amp;quot;, USD_min = 8000)&lt;/code&gt; obtendremos todas las
actividades que producen mas de 8 mil.&lt;/p&gt;
&lt;p&gt;Una vez definido el nombre y las variables de nuestra función,
podemos especificar el cuerpo dentro de corchetes &lt;code&gt;{}&lt;/code&gt;, es decir,
la función de nuestra función. En este caso podemos observar que
el código que forma el cuerpo de la función es exactamente el mismo
que utilizamos para visualizar Chihuahua, los únicos cambios son
que en el sitio donde habíamos escrito &amp;ldquo;Chihuahua&amp;rdquo; y &amp;ldquo;5000000&amp;rdquo;,
ahora están &lt;code&gt;estado&lt;/code&gt; y &lt;code&gt;USD_min&lt;/code&gt;. Hay dos consideraciones que deben
ser tomadas en cuenta al crear una función de este tipo en R:
primero que los valores definidos dentro del cuerpo de una función,
en este caso &lt;code&gt;estado&lt;/code&gt; y &lt;code&gt;USD_min&lt;/code&gt;, sólo existen dentro del cuerpo
de la función. Si vamos a la consola y tecleamos &lt;code&gt;ls()&lt;/code&gt; veremos que
estos objetos no existen en la memoria donde estamos trabajando.
Otro aspecto importante es que en R, a diferencia de otros
lenguajes de programación, una función puede tomar cualquier objeto
que exista en la memoria donde es ejecutado. Por ejemplo, en este
caso nuestra función utiliza la tabla &lt;code&gt;export.rows&lt;/code&gt;. Si esta tabla
no existiera (por ejemplo, si no la hemos creado vía &lt;code&gt;read_csv&lt;/code&gt;),
nuestra función generará un error.&lt;/p&gt;
&lt;p&gt;Es importante entender el proceso de como la ejecución de funciones
busca los valores, para no cometer errores. Al ser ejecutada, la
función buscará valores de los objetos PRIMERO dentro del cuerpo
de la función, y al no encontrarlos, irá a buscarlos a la memoria
general o global de R, que es donde estamos trabajando, si tampoco
existen aquí, generará un error. Esto significa que
si dentro de la función otorgamos un valor diferente a
&lt;code&gt;export.rows&lt;/code&gt;, la función utilizará su nuevo valor. Veamos un
ejemplo:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;  primeros &amp;lt;- function(){
      head(export.rows)
  }

  primeros()
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; # A tibble: 6 × 6
&amp;gt;   Código Descripción           state           year     USD Activity
&amp;gt;    &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;                 &amp;lt;chr&amp;gt;          &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;   
&amp;gt; 1     NA Exportaciones totales Aguascalientes  2007 4389841 Total   
&amp;gt; 2     NA Exportaciones totales Aguascalientes  2008 4456893 Total   
&amp;gt; 3     NA Exportaciones totales Aguascalientes  2009 3951108 Total   
&amp;gt; 4     NA Exportaciones totales Aguascalientes  2010 5647929 Total   
&amp;gt; 5     NA Exportaciones totales Aguascalientes  2011 6051640 Total   
&amp;gt; 6     NA Exportaciones totales Aguascalientes  2012 6183782 Total
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Generamos una función sin variables, que nos devuelve los primeros
valores en &lt;code&gt;export.rows&lt;/code&gt;. En este caso, &lt;code&gt;export.rows&lt;/code&gt; no existe
dentro del cuerpo de la función, por lo tanto R lo busca en la
memoria general, encuentra nuestra tabla, y la utiliza. Sin embargo
esto podría cambiar, veamos:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;  primeros &amp;lt;- function(){
      export.rows &amp;lt;- c(1:100)
      head(export.rows)
  }

  primeros()
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; [1] 1 2 3 4 5 6
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ahora que le hemos dado un valor a &lt;code&gt;export.rows&lt;/code&gt; dentro del
cuerpo de la función, el resultado es diferente. Sin embargo,
el objeto &lt;code&gt;export.rows&lt;/code&gt; en la memoria general no cambió&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;  head(export.rows)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; # A tibble: 6 × 6
&amp;gt;   Código Descripción           state           year     USD Activity
&amp;gt;    &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;                 &amp;lt;chr&amp;gt;          &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;   
&amp;gt; 1     NA Exportaciones totales Aguascalientes  2007 4389841 Total   
&amp;gt; 2     NA Exportaciones totales Aguascalientes  2008 4456893 Total   
&amp;gt; 3     NA Exportaciones totales Aguascalientes  2009 3951108 Total   
&amp;gt; 4     NA Exportaciones totales Aguascalientes  2010 5647929 Total   
&amp;gt; 5     NA Exportaciones totales Aguascalientes  2011 6051640 Total   
&amp;gt; 6     NA Exportaciones totales Aguascalientes  2012 6183782 Total
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;En este ejemplo perecería estúpido, sin embargo al generar
funciones muy largas, que utilizan objetos que tenemos creados en
la memoria, es fácil cometer errores y otorgarle un valor a un
objeto que ya existe y que necesitamos dentro de la función.
Diferentes lenguajes de programación protegen esto de diferentes
maneras, por ejemplo en python, para llamar un objeto de la memoria
general dentro de una función, es necesario utilizar el comando
&lt;code&gt;global&lt;/code&gt;, lo cual le indica que debe buscar este objeto en el ambiente
global, y resulta más fácil para nosotros el notar
que objetos estamos utilizando desde el ambiente global. En R
es importante ser conscientes de nuestros objetos globales y
locales.&lt;/p&gt;
&lt;p&gt;Continuando con nuestro EDA, podemos ver que ahora nuestra función
facilita la visualización por estado:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;   plot_state(&amp;quot;Chihuahua&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://blog.rwhitedwarf.com/post/2022/EDA_INEGI_data/plot-chihuahua-1.png&#34; alt=&#34;plot of chunk plot-chihuahua&#34; /&gt;
&lt;/p&gt;
&lt;p&gt;Podemos utilizar el paquete &lt;code&gt;cowplot&lt;/code&gt; para observar varios estados
juntos en un sólo gráfico.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;   plot_grid(
    plot_state(&amp;quot;Chihuahua&amp;quot;) ,
    plot_state(&amp;quot;Baja California&amp;quot;),
    plot_state(&amp;quot;Coahuila de Zaragoza&amp;quot;),
    plot_state(&amp;quot;Nuevo León&amp;quot;),
    plot_state(&amp;quot;Tamaulipas&amp;quot;),
    plot_state(&amp;quot;Campeche&amp;quot;, USD_min = 10000),
    ncol = 2)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://blog.rwhitedwarf.com/post/2022/EDA_INEGI_data/varios-estados-1.png&#34; alt=&#34;plot of chunk varios-estados&#34; /&gt;
&lt;/p&gt;
&lt;p&gt;La función &lt;code&gt;plot_grid&lt;/code&gt; resulta útil y conveniente, organiza varios
gráficos de forma simétrica, podemos especificar el número de
columnas &lt;code&gt;ncol&lt;/code&gt; o número de filas &lt;code&gt;nrow&lt;/code&gt; en las que nuestros
gráficos deben ser visualizados.&lt;/p&gt;
&lt;p&gt;A pesar de que cada estado obtiene sus principales ingresos en
exportaciones a partir de diferentes actividades, podemos observar
que en general, electrodomésticos (Electronics) y Equipo de
Transporte (Transport equipment) son las principales actividades.
Otras actividades como Maquinaria (Machinery) y metalúrgica
(Metal products) también tienen la tendencia de estar entre los
primeros lugares. Así pues, es claro que hay una tendencia entre
los 5 principales exportadores con el tipo de actividades
exportadoras. Solo para el caso de Campeche, en el sexto lugar es
diferente: su principal actividad de exportación es Petroleo, la
cual no aparece en las otras gráficas entre las principales
actividades de exportación. Sin embargo, si observamos las
principales actividades a lo largo del tiempo, exportación de
petroleo se encuentra en el tercer lugar:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;   export.rows %&amp;gt;%
    filter(Activity == &amp;quot;Electronics&amp;quot; |
           Activity == &amp;quot;Transport equipment&amp;quot; |
           Activity == &amp;quot;Petroleum&amp;quot;) %&amp;gt;%
    group_by(year, Activity) %&amp;gt;%
    summarise(`Total per activity` = sum(USD)) %&amp;gt;%
    ggplot(aes(x = year, y = `Total per activity`)) +
    geom_line(aes(colour = Activity)) +
    geom_point(aes(colour = Activity))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://blog.rwhitedwarf.com/post/2022/EDA_INEGI_data/3-activities-1.png&#34; alt=&#34;plot of chunk 3-activities&#34; /&gt;
&lt;/p&gt;
&lt;p&gt;Al menos desde 2007, exportación de petroleo genera menos ingresos
que exportación de electrodomésticos y equipo de transporte. Otro
detalle interesante que es claro en nuestra última gráfica es que
a partir de 2009, la exportación en equipo de transporte ha
incrementado año con año. Esto explica por que estados donde la
principal actividad de exportación es equipo de transporte están
en los primeros lugares como exportadores.&lt;/p&gt;
&lt;p&gt;Podemos generar otra función similar a &lt;code&gt;plot_state&lt;/code&gt; pero por
actividad, &lt;code&gt;plot_activity&lt;/code&gt; para observar los principales estados
exportadores de petroleo.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;  ## Funcion para ver principal estado por actividad
  plot_activity &amp;lt;- function(activity, USD_min = 5000000){
      export.cols %&amp;gt;%
          select(state, year, activity) %&amp;gt;%
          group_by(state)  %&amp;gt;%
          summarise(Total = sum(!!sym(activity))) %&amp;gt;%
          filter(Total &amp;gt;= USD_min) %&amp;gt;%
          ggplot() +
          geom_bar(aes(y = Total,
                       x = reorder(state,
                                   Total, FUN = abs),
                       fill = Total),
                   stat = &#39;identity&#39;) +
          coord_flip() +
          labs(title = activity,
               y = &amp;quot;Total USD&amp;quot;, x = NULL) +
          theme(legend.position=&amp;quot;none&amp;quot;)
  }

   plot_activity(&amp;quot;Petroleum&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://blog.rwhitedwarf.com/post/2022/EDA_INEGI_data/plot-activity-fun-1.png&#34; alt=&#34;plot of chunk plot-activity-fun&#34; /&gt;
&lt;/p&gt;
&lt;p&gt;Sólo 4 estados exportaron más de 5,000 millones de USD en petroleo.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;   plot_grid(
    plot_state(&amp;quot;Campeche&amp;quot;, USD_min = 1000000),
    plot_state(&amp;quot;Tabasco&amp;quot;, USD_min = 1000000),
    plot_state(&amp;quot;Veracruz de Ignacio de la Llave&amp;quot;),
    plot_state(&amp;quot;Chiapas&amp;quot;, USD_min = 1000000))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://blog.rwhitedwarf.com/post/2022/EDA_INEGI_data/activity-states-1.png&#34; alt=&#34;plot of chunk activity-states&#34; /&gt;
&lt;/p&gt;
&lt;p&gt;Parece ser que la economía de Tabasco, Campeche y Chiapas dependen
en alto grado de la extracción de petroleo, diferente a Veracruz,
que tiene otras actividades mas fuertes como productos químicos,
metalurgia y alimentación.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>R function to fill in merged cells</title>
      <link>https://blog.rwhitedwarf.com/post/fill_merged_cells/</link>
      <pubDate>Sun, 05 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://blog.rwhitedwarf.com/post/fill_merged_cells/</guid>
      <description>&lt;p&gt;This post is part of our series on &lt;a href=&#34;https://blog.rwhitedwarf.com/tags/r-functions&#34; target=&#34;_blank&#34;&gt;functions in R&lt;/a&gt;. You can see our &lt;a href=&#34;https://blog.rwhitedwarf.com/post/2021/functions/&#34; target=&#34;_blank&#34;&gt;previous post&lt;/a&gt; if you want to understand the basics but it is not strictly necessary. Here we will go into detail about for loops and if statements in R, two key elements of any function. We are going to define a process, map it in a step-by-step approach and wrape it in a function that can repeat it automatically. Even if you have a very basic understanding of R you should be able to follow this tutorial without problem.&lt;/p&gt;
&lt;p&gt;Our outcome will be an R function that by calling it, is able to fill in empty rows generated from imported sheets (like excel) when it contains merged cells. If you are only &lt;strong&gt;interested in the function itself&lt;/strong&gt; you can go to the end of the post and find it in the section &lt;a href=&#34;https://blog.rwhitedwarf.com/post/fill_merged_cells/#final&#34;&gt;Final remarks&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;description-of-the-problem&#34;&gt;Description of the problem&lt;/h3&gt;
&lt;p&gt;In our &lt;a href=&#34;https://blog.rwhitedwarf.com/post/2021/functions/&#34; target=&#34;_blank&#34;&gt;previous post&lt;/a&gt; we saw the basics for creating functions, yet using silly examples with not much of practical usage. Now we are ready to write a function that can have more practical use.&lt;/p&gt;
&lt;p&gt;There are different ways how to import data sheets (i.e. from excel) to R. Regardless of its limitations, these sheets are widely used in data analysis today. If you are used to do data analysis with a different software you should be familiar with the complications of sorting your data imported from sheets when there are merged cells in the rows. Usually, a file like below&lt;/p&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://blog.rwhitedwarf.com/post/2021/fill_merged_cells/Screenshot_excel_merged_cells.png&#34; alt=&#34;Excel with merged cells&#34; /&gt;
&lt;/p&gt;
&lt;p&gt;results in a table like this&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;Specie&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;Dup&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;Treat&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;Rep&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;Value&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;A. cap&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;A&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;34&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;AA&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;NA&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;NA&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;A&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;25&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;NA&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;18&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;AA&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;NA&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;NA&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;24&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;A&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;50&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;NA&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;AA&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;NA&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;NA&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;12&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;A&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;100&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;NA&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;15&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;AA&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;NA&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;NA&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;F. rub&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;F&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;NA&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;25&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;FF&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;NA&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;NA&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;F&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;25&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;NA&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;17&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;FF&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;NA&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;NA&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;F&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;50&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;NA&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;13&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;FF&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;NA&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;NA&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;F&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;100&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;NA&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;11&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;when the amount of rows to be filled in is small, there&amp;rsquo;s no big problem in copying and pasting the values. But as the DRY principle says, if we know how to create functions there is no need to do that, we can make a function that will do it automatically. This will specially pay off when you will have a table with hundreds or even thousands of cells merged. You might be thinking that nobody will merge cells for thousands of rows every 3 or 4 lines, but believe me, I have seen such things.&lt;/p&gt;
&lt;p&gt;Keep in mind that this is mainly a tutorial for writting functions in R. It does not intend to deal with all the issues that migh appear with the importing of data such as merged columns or a mixture of both, among others. But if you have problems with that or are interested in the topic, leave us a comment and we can cover some points in a future post.&lt;/p&gt;
&lt;h2 id=&#34;r-function-to-fill-in-merged-cells-from-excel&#34;&gt;R function to fill in merged cells from excel&lt;/h2&gt;
&lt;p&gt;With today&amp;rsquo;s technology there are many ways to solve this problem. However sometimes the easiest way to import data to R as data analyst or statistician is by simply taking the working sheet containing the data and exporting it in csv format.&lt;/p&gt;
&lt;p&gt;Regardless of the source (excel, libre office, google sheets, etc.) this method produces empty rows by default. When some rows have been merged because they belong to the same group or factor, the csv file will capture the value only on the first row and leave the rest empty until the next factor appear, where it again, will capture the value on the first row and leave the rest empty until the next factor appears. The process continues like this, iteratively until the end of the table. We basically need to copy the value stored on that first row and paste it to the empty rows, until a new factor appears.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s map the process in terms of R steps to complete our task.&lt;/p&gt;
&lt;h3 id=&#34;maping-the-process&#34;&gt;Maping the process&lt;/h3&gt;
&lt;p&gt;We will start by calling the table. If you have an excel, libre office calc or google sheet file with merged rows as our example above feel free to use it. Otherwise you can quickly simulate one similar to the image above. Start by exporting the sheet of interest to csv, then we call it using &lt;code&gt;read.csv&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;my.table &amp;lt;- read.csv(&#39;../../../static/post/2021/fill_merged_cells/Hydroponic_results.csv&#39;)
head(my.table, n = 10)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;    Specie Dup Treat Rep Value
&amp;gt; 1  A. cap   A     0   1    34
&amp;gt; 2          AA    NA  NA    26
&amp;gt; 3           A    25  NA    18
&amp;gt; 4          AA    NA  NA    24
&amp;gt; 5           A    50  NA    11
&amp;gt; 6          AA    NA  NA    12
&amp;gt; 7           A   100  NA    15
&amp;gt; 8          AA    NA  NA    11
&amp;gt; 9  F. rub   F     0  NA    25
&amp;gt; 10         FF    NA  NA    26
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here we can see the first 10 rows containing &lt;code&gt;NA&lt;/code&gt; for numeric columns and empty string for character columns. Now let&amp;rsquo;s go step by step to fill empty values.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. Identify and capture the factor
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let&amp;rsquo;s start with the first column &lt;code&gt;Specie&lt;/code&gt; (an experiment was run for 3 different species of plants). We want to check if the first row contains a categorical value&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;no.row &amp;lt;- 1
my.table[[&#39;Specie&#39;]][no.row]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; [1] &amp;quot;A. cap&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;2. Copy it into the empty rows
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we want to paste the value stored in &lt;code&gt;category&lt;/code&gt; to all empty rows. So we first need to check if the next row is empty&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;no.row &amp;lt;- 2
my.table[[&#39;Specie&#39;]][no.row]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; [1] &amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And when it is, we place the value contained in the previous row to our current row 2&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;my.table[[&#39;Specie&#39;]][no.row] &amp;lt;- my.table[[&#39;Specie&#39;]][no.row-1]
head(my.table)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;   Specie Dup Treat Rep Value
&amp;gt; 1 A. cap   A     0   1    34
&amp;gt; 2 A. cap  AA    NA  NA    26
&amp;gt; 3          A    25  NA    18
&amp;gt; 4         AA    NA  NA    24
&amp;gt; 5          A    50  NA    11
&amp;gt; 6         AA    NA  NA    12
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now row 2 contains it&amp;rsquo;s categorical value, and when we move to row 3 (which is also empty), it can be copied from the previous row 2&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;no.row &amp;lt;- 3
my.table[[&#39;Specie&#39;]][no.row]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; [1] &amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;my.table[[&#39;Specie&#39;]][no.row] &amp;lt;- my.table[[&#39;Specie&#39;]][no.row-1]
head(my.table)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;   Specie Dup Treat Rep Value
&amp;gt; 1 A. cap   A     0   1    34
&amp;gt; 2 A. cap  AA    NA  NA    26
&amp;gt; 3 A. cap   A    25  NA    18
&amp;gt; 4         AA    NA  NA    24
&amp;gt; 5          A    50  NA    11
&amp;gt; 6         AA    NA  NA    12
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;3. When a new factor appears, repeat the process
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can repeat this process until a new factor appears, as it is the case of row 9. Therefore we should not paste anything in row 9, and continue the process on row 10 which is also empty&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;no.row &amp;lt;- 10
my.table[[&#39;Specie&#39;]][no.row]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; [1] &amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;my.table[[&#39;Specie&#39;]][no.row] &amp;lt;- my.table[[&#39;Specie&#39;]][no.row-1]
head(my.table, n = 10)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;    Specie Dup Treat Rep Value
&amp;gt; 1  A. cap   A     0   1    34
&amp;gt; 2  A. cap  AA    NA  NA    26
&amp;gt; 3  A. cap   A    25  NA    18
&amp;gt; 4          AA    NA  NA    24
&amp;gt; 5           A    50  NA    11
&amp;gt; 6          AA    NA  NA    12
&amp;gt; 7           A   100  NA    15
&amp;gt; 8          AA    NA  NA    11
&amp;gt; 9  F. rub   F     0  NA    25
&amp;gt; 10 F. rub  FF    NA  NA    26
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;4. Repeat steps 1-3 for each column that needs it
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The process moves forward in this way until the whole column &lt;code&gt;Specie&lt;/code&gt; is filled in. Then we can move to the next column with empty values, in my case this is &lt;code&gt;Treat&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;If you look at the process, we basically need to write an R command for step 2. The rest is just a process of verification and repetition. We are going to automate verification using the function &lt;code&gt;if()&lt;/code&gt; and the repetition using &lt;code&gt;for()&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;writing-my-first-for-loop&#34;&gt;Writing my first for loop&lt;/h3&gt;
&lt;p&gt;Since the present post is directed to R beginners with not much experience with programming or coding I will avoid all the technicalities of for loops and if statements and instead dive deeply into them by applying our logic above. Then we are going to use them and explain carefully to obtain a pragmatic understanding of the process.&lt;/p&gt;
&lt;p&gt;We will start with a for loop to go row by row in one column and check what is inside, as described in the step &lt;em&gt;1&lt;/em&gt; of our process. Let&amp;rsquo;s start with only 20 rows as an example&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;for(no.row in 1:20){
    print(my.table[[&amp;quot;Specie&amp;quot;]][no.row])
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; [1] &amp;quot;A. cap&amp;quot;
&amp;gt; [1] &amp;quot;A. cap&amp;quot;
&amp;gt; [1] &amp;quot;A. cap&amp;quot;
&amp;gt; [1] &amp;quot;&amp;quot;
&amp;gt; [1] &amp;quot;&amp;quot;
&amp;gt; [1] &amp;quot;&amp;quot;
&amp;gt; [1] &amp;quot;&amp;quot;
&amp;gt; [1] &amp;quot;&amp;quot;
&amp;gt; [1] &amp;quot;F. rub&amp;quot;
&amp;gt; [1] &amp;quot;F. rub&amp;quot;
&amp;gt; [1] &amp;quot;&amp;quot;
&amp;gt; [1] &amp;quot;&amp;quot;
&amp;gt; [1] &amp;quot;&amp;quot;
&amp;gt; [1] &amp;quot;&amp;quot;
&amp;gt; [1] &amp;quot;&amp;quot;
&amp;gt; [1] &amp;quot;&amp;quot;
&amp;gt; [1] &amp;quot;A. ela&amp;quot;
&amp;gt; [1] &amp;quot;&amp;quot;
&amp;gt; [1] &amp;quot;&amp;quot;
&amp;gt; [1] &amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The function &lt;code&gt;for()&lt;/code&gt;uses the first argument that you define (here &lt;code&gt;no.row&lt;/code&gt;) and goes one by one &lt;code&gt;in&lt;/code&gt; the series specified as the second argument, in this case a series of numbers from 1 to 20 (&lt;code&gt;1:20&lt;/code&gt;). It means that in the first iteration &lt;code&gt;no.row&lt;/code&gt; will take the value &lt;code&gt;1&lt;/code&gt;, in the second iteration the value &lt;code&gt;2&lt;/code&gt;, and so on, until the last iteration where it will have the value &lt;code&gt;20&lt;/code&gt;. Each iteration will execute the code inside the curly braces &lt;code&gt;{}&lt;/code&gt; which, in this case, is simply to print the value of each row.&lt;/p&gt;
&lt;p&gt;Because the first argument in &lt;code&gt;for()&lt;/code&gt; is defined by us, we could as well use any arbitrary argument we want, for example&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;for(n in 1:20){
    print(my.table[[&amp;quot;Specie&amp;quot;]][n])
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;would do exactly the same but now &lt;code&gt;n&lt;/code&gt; is taking the values from 1 to 20.&lt;/p&gt;
&lt;p&gt;We can then initialize a function that takes the name of our data frame, the name of the column, and do exactly the same as our code above, but for all the rows contained in the table, no matter how many they are&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;fill_merged &amp;lt;- function(dat, column){
    ## Get value of each row
    for(n in 1:nrow(dat)){
        print(my.table[[column]][n])
        }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here our for loop will create a local variable &lt;code&gt;n&lt;/code&gt; that will take values from 1 until &lt;code&gt;nrow(dat)&lt;/code&gt; which means number of rows in the table &lt;code&gt;dat&lt;/code&gt;, and then print each row value contained in the column stated in the argument &lt;code&gt;column&lt;/code&gt;. If we apply it to our data frame&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;fill_merged(my.table, &amp;quot;Specie&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The R console will print, one by one, each of the values contained in the column &lt;code&gt;Specie&lt;/code&gt; (I have 120 rows, it makes no sense to take space to show it in the post, but you can go ahead and try it yourself).&lt;/p&gt;
&lt;p&gt;If the last two pieces of code are not clear for you, I recommend you to read our previous post about &lt;a href=&#34;https://blog.rwhitedwarf.com/post/2021/functions/&#34; target=&#34;_blank&#34;&gt;functions in R&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;how-to-use-if-statement-in-r&#34;&gt;How to use If statement in R&lt;/h3&gt;
&lt;p&gt;Printing the values is far from what we want to achieve. As we defined in the first step of the process, we need to check the value inside, if it has a value we leave it alone, but if it is empty, we fill it in with the previous value. To check if the value is empty or not we use the &lt;code&gt;if()&lt;/code&gt; function&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;fill_merged &amp;lt;- function(dat, column){
    ## Get value of each row
    for(n in 1:nrow(dat)){
        ## Check if it is empty
        if(dat[[column]][n] == &#39;&#39;){
            dat[[column]][n] &amp;lt;- dat[[column]][n - 1]
        }
    }
    return(dat)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The function &lt;code&gt;if()&lt;/code&gt; checks the expression inside parentheses and if it returns &lt;code&gt;TRUE&lt;/code&gt; it executes the code inside curly braces &lt;code&gt;{}&lt;/code&gt;, otherwise it will skip it. Therefore it is crucial that the expression inside &lt;code&gt;if()&lt;/code&gt; returns either &lt;code&gt;TRUE&lt;/code&gt; or &lt;code&gt;FALSE&lt;/code&gt;. You can always test it by sending the exact expression directly to the console&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;my.table[[&#39;Specie&#39;]][1] == &#39;&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; [1] FALSE
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;my.table[[&#39;Specie&#39;]][5] == &#39;&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; [1] TRUE
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Once we confirm that the value is empty, we enter the if statement and execute the code from step &lt;em&gt;2&lt;/em&gt;, which inside the function takes the form of &lt;code&gt;dat[[column]][n] &amp;lt;- dat[[column]][n - 1]&lt;/code&gt;.If the value is not empty, we simply do nothing.&lt;/p&gt;
&lt;p&gt;Now we can actually try the function in one of our columns&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;my.filled.table &amp;lt;- fill_merged(my.table, &#39;Specie&#39;)
head(my.filled.table, n = 15)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;    Specie Dup Treat Rep Value
&amp;gt; 1  A. cap   A     0   1    34
&amp;gt; 2  A. cap  AA    NA  NA    26
&amp;gt; 3  A. cap   A    25  NA    18
&amp;gt; 4  A. cap  AA    NA  NA    24
&amp;gt; 5  A. cap   A    50  NA    11
&amp;gt; 6  A. cap  AA    NA  NA    12
&amp;gt; 7  A. cap   A   100  NA    15
&amp;gt; 8  A. cap  AA    NA  NA    11
&amp;gt; 9  F. rub   F     0  NA    25
&amp;gt; 10 F. rub  FF    NA  NA    26
&amp;gt; 11 F. rub   F    25  NA    17
&amp;gt; 12 F. rub  FF    NA  NA    11
&amp;gt; 13 F. rub   F    50  NA    13
&amp;gt; 14 F. rub  FF    NA  NA    11
&amp;gt; 15 F. rub   F   100  NA    11
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt; that so far it works only for columns with character values, not numeric&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;fill_merged(my.table, &#39;Treat&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; Error in if (dat[[column]][n] == &amp;quot;&amp;quot;) {: missing value where TRUE/FALSE needed
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The reason is that only character columns produce empty strings. Numeric columns will produce &lt;code&gt;NA&lt;/code&gt; values. Therefore, we need to add a condition to our if expression to test also if the value is &lt;code&gt;NA&lt;/code&gt;. To do that we use double &lt;code&gt;|&lt;/code&gt; which in R means &lt;strong&gt;OR&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;fill_merged &amp;lt;- function(dat, column){
    ## Get value of each row
    for(n in 1:nrow(dat)){
        ## Check if it is empty
        if(dat[[column]][n] == &#39;&#39; || is.na(dat[[column]][n])){
            dat[[column]][n] &amp;lt;- dat[[column]][n - 1]
        }
    }
    return(dat)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now our if statement is telling to R &amp;ldquo;&lt;strong&gt;IF&lt;/strong&gt; the value is empty (&lt;code&gt;&#39;&#39;&lt;/code&gt;) &lt;strong&gt;OR&lt;/strong&gt; is NA (&lt;code&gt;is.na()&lt;/code&gt;) then, execute this code&amp;rdquo;, and so we enter to the code inside the if-curly-braces.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;NA&lt;/code&gt; are not exactly values and therefore we cannot test them by using the expression&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;my.table[[&#39;Treat&#39;]][2] == NA
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; [1] NA
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Instead of returning &lt;code&gt;TRUE&lt;/code&gt; or &lt;code&gt;FALSE&lt;/code&gt; returns &lt;code&gt;NA&lt;/code&gt; which means &lt;strong&gt;Not Available&lt;/strong&gt;. To check if the value is &lt;code&gt;NA&lt;/code&gt; or really a value we use the function &lt;code&gt;is.na()&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;is.na(my.table[[&#39;Treat&#39;]][2])
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; [1] TRUE
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we can use our function for columns with numeric values also&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;my.filled.table &amp;lt;- fill_merged(my.table, &#39;Treat&#39;)
head(my.filled.table, n = 10)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;    Specie Dup Treat Rep Value
&amp;gt; 1  A. cap   A     0   1    34
&amp;gt; 2  A. cap  AA     0  NA    26
&amp;gt; 3  A. cap   A    25  NA    18
&amp;gt; 4          AA    25  NA    24
&amp;gt; 5           A    50  NA    11
&amp;gt; 6          AA    50  NA    12
&amp;gt; 7           A   100  NA    15
&amp;gt; 8          AA   100  NA    11
&amp;gt; 9  F. rub   F     0  NA    25
&amp;gt; 10 F. rub  FF     0  NA    26
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;check-confirm-and-repeat-for-and-if-together&#34;&gt;Check, confirm and repeat (for and if together)&lt;/h3&gt;
&lt;p&gt;Now we could use our function for each column that presents this issue, but we are actually trying to apply the DRY principle. Instead we could use &lt;code&gt;for()&lt;/code&gt; to go through all the columns where we want to apply it. There are other functions that can help with this as well such as &lt;code&gt;map()&lt;/code&gt; and its derived functions from the package &lt;a href=&#34;https://purrr.tidyverse.org/&#34; target=&#34;_blank&#34;&gt;purrr&lt;/a&gt;.We could also write a new function that calls our first function to repeat it into each column. Feel free to experiment, for this tutorial we are going to take a different approach.&lt;/p&gt;
&lt;p&gt;We are going to improve the same old function and add yet one more for loop that iterates from each column of interest and repeats the same process. This will cover the step 4 of our mapped process.&lt;/p&gt;
&lt;p&gt;The implementation is actually easy, we just need to wrap the whole previous process of if&amp;rsquo;s and for&amp;rsquo;s inside a for loop that goes column by column&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;fill_merged &amp;lt;- function(dat, columns.as.vector){
    ## Go through the columns
    for(column in columns.as.vector){
        ## Get value of each row
        for(n in 1:nrow(dat)){
            ## Check if it is empty
            if(dat[[column]][n] == &#39;&#39; || is.na(dat[[column]][n])){
                dat[[column]][n] &amp;lt;- dat[[column]][n - 1]
            }
        }
    }
    return(dat)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I have changed the argument for initiating the function from &lt;code&gt;column&lt;/code&gt; to &lt;code&gt;columns.as.vector&lt;/code&gt;. Now this will take a vector containing all the names of the columns that should be treated. Notice that in our new for loop I am declaring &lt;code&gt;column&lt;/code&gt; to iterate over each value of &lt;code&gt;column.as.vector&lt;/code&gt; therefore, the variable &lt;code&gt;column&lt;/code&gt; will contain each string in the vector for each iteration. In this way we don&amp;rsquo;t need to change the rest of the code.&lt;/p&gt;
&lt;p&gt;Now you can call exactly the same function for each column that needs it&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;target_cols &amp;lt;- names(my.table)[c(1,3,4)]
my.filled.table &amp;lt;- fill_merged(my.table, target_cols)
head(my.filled.table, n = 15)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;    Specie Dup Treat Rep Value
&amp;gt; 1  A. cap   A     0   1    34
&amp;gt; 2  A. cap  AA     0   1    26
&amp;gt; 3  A. cap   A    25   1    18
&amp;gt; 4  A. cap  AA    25   1    24
&amp;gt; 5  A. cap   A    50   1    11
&amp;gt; 6  A. cap  AA    50   1    12
&amp;gt; 7  A. cap   A   100   1    15
&amp;gt; 8  A. cap  AA   100   1    11
&amp;gt; 9  F. rub   F     0   1    25
&amp;gt; 10 F. rub  FF     0   1    26
&amp;gt; 11 F. rub   F    25   1    17
&amp;gt; 12 F. rub  FF    25   1    11
&amp;gt; 13 F. rub   F    50   1    13
&amp;gt; 14 F. rub  FF    50   1    11
&amp;gt; 15 F. rub   F   100   1    11
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Also notice the trick in the first line: &lt;code&gt;names(my.table)&lt;/code&gt; returns a vector containing all the column names of the data frame and &lt;code&gt;names(my.table)[c(1,3,4)]&lt;/code&gt; is taking only the columns 1, 3 and 4, which are the ones that need to be fixed. This is extremely useful when you have many columns that need to be fixed&lt;/p&gt;
&lt;h3 id=&#34;marking-the-errors&#34;&gt;Marking the errors&lt;/h3&gt;
&lt;p&gt;You might have noticed that I&amp;rsquo;m adding text preceded by &lt;code&gt;##&lt;/code&gt; within the function. If you are not familiar with it, this are comments, it means that anything that is written in the same line after one &lt;code&gt;#&lt;/code&gt; will not be evaluated by R (I use double for technical reasons of my text editor). Although this function is quite small and simple, and we know what exactly we are doing on each line thanks to the explanations, it is a good practice to add comments to your code because after a while, when you will look back at the code you might had forgotten the logic and structure. Adding comments help us to know what each piece is about, making it easier to apply changes in the future.&lt;/p&gt;
&lt;p&gt;In the same way, it is a good practice to add errors when the function is expecting something in particular and we can foresee potential problems. Often we don&amp;rsquo;t foresee all the mistakes and problems that the user or we ourselves can have when using our own functions and thus, errors are usually added along the way based on the experience gathered by using the function.&lt;/p&gt;
&lt;p&gt;For example, our function is expecting that at least the first row will not have empty values, otherwise it cannot go one row before to find the value to paste on it. Although it is not expected, our table can still present this situation due to human errors, for example, somebody by accident pressed &lt;em&gt;Delete&lt;/em&gt; button somewhere on the first row in the source file. In such case R will mark some error that will be difficult to understand and track back. We might wonder for hours what we did wrong in our function only to find out that the problem comes from the data table itself. Instead we can mark our own error in advance by sending a message when the value on the first row is missing.&lt;/p&gt;
&lt;p&gt;An easy way of implementing this is using the function &lt;code&gt;stop()&lt;/code&gt;. Let&amp;rsquo;s implement our error into our function right before it copies the value from the row &lt;code&gt;n - 1&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;fill_merged &amp;lt;- function(dat, columns.as.vector){
    ## Go through the columns
    for(column in columns.as.vector){
        ## Get value of each row
        for(n in 1:nrow(dat)){
            ## Check if it is empty
            if(dat[[column]][n] == &#39;&#39; || is.na(dat[[column]][n])){
                ## If it is the row 1, stop with Error
                if(n == 1){
                    stop(paste0(&amp;quot;Row 1 of column &amp;quot;, column,
                                    &amp;quot; has empty values. Check your data.&amp;quot;))
                }
                else{
                    dat[[column]][n] &amp;lt;- dat[[column]][n - 1]
                }
            }
        }
    }
    return(dat)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If the value of the first row is empty, the function will stop, printing a message that says in which column the row no. 1 is empty. When the row is not the first, R will evaluate the code next, contained inside &lt;code&gt;else{}&lt;/code&gt;. &lt;code&gt;else&lt;/code&gt; is a complement for if that tell R what to do when the &lt;code&gt;if()&lt;/code&gt; part is not fulfilled. Sometimes we can omit it, when the &lt;code&gt;if()&lt;/code&gt; part is not fulfilled R will simply go to the next part of the code. But when we want to make sure that nothing will happen outside these options, we include &lt;code&gt;else&lt;/code&gt;. Here we are giving only two options, either &lt;code&gt;n&lt;/code&gt; equals 1 and the function stops with an error, or else &lt;code&gt;n&lt;/code&gt; is not one and the function continues.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s try the error by making a copy of our data frame with the first row empty&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;test.error &amp;lt;- my.table[2:10,]
fill_merged(test.error, &#39;Rep&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; Error in fill_merged(test.error, &amp;quot;Rep&amp;quot;): Row 1 of column Rep has empty values. Check your data.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Another misunderstanding that the user can encounter is with the argument &lt;code&gt;columns.as.vector&lt;/code&gt;. We are expecting that the user will provide a string, or vector of strings with the names of the columns, but the user as well might think that the function is expecting the whole data as vector. We can prevent the user for doing this by adding an error at the beginning of the function.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;fill_merged &amp;lt;- function(dat, columns.as.vector){
    ## Check if column names are provided as strings
    if(!is.character(columns.as.vector)){
        stop(&amp;quot;Column names must be provided as string or vector of strings of class character&amp;quot;)
    }
    ## Go through the columns
    for(column in columns.as.vector){
        ## Get value of each row
        for(n in 1:nrow(dat)){
            ## Check if it is empty
            if(dat[[column]][n] == &#39;&#39; || is.na(dat[[column]][n])){
                ## If it is the row 1, stop with Error
                if(n == 1){
                    stop(paste0(&amp;quot;Row 1 of column &amp;quot;, column,
                                    &amp;quot; has empty values. Check your data.&amp;quot;))
                }
                else{
                    dat[[column]][n] &amp;lt;- dat[[column]][n - 1]
                }
            }
        }
    }
    return(dat)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We want to make sure that &lt;code&gt;columns.as.vector&lt;/code&gt; is character. To test this, we use the function &lt;code&gt;is.character()&lt;/code&gt;, which will return &lt;code&gt;TRUE&lt;/code&gt; when the values inside are character, and &lt;code&gt;FALSE&lt;/code&gt; otherwise.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;a &amp;lt;- &#39;foo&#39;
is.character(a)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; [1] TRUE
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However we want to send the error only when the value is NOT character. To tell R to test the opposite, we start the argument with the symbol &lt;code&gt;!&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;!is.character(a)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; [1] FALSE
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now with our new version, when the user might provide any value that is not string, the error will be triggered&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;fill_merged(my.table, 1)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; Error in fill_merged(my.table, 1): Column names must be provided as string or vector of strings of class character
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Still if the user provides a vector of strings, or a misspelled name of the column, our function is not aware of it. We can add one more error when &lt;code&gt;column.as.vector&lt;/code&gt; is string but not a string that we are expecting&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;fill_merged &amp;lt;- function(dat, columns.as.vector){
    ## Check if column names are provided as strings
    if(!is.character(columns.as.vector)){
        stop(&amp;quot;Column names must be provided as string or vector of strings of class character&amp;quot;)
    }
    ## Go through the columns
    for(column in columns.as.vector){
        ## Check if the column name matches with dat column names
        if (!column %in% names(dat)){
            stop(paste0(&#39;Column &amp;lt;&#39;, column, &#39;&amp;gt; cannot be found in the data frame&#39;))
        }
        ## Get value of each row
        for(n in 1:nrow(dat)){
            ## Check if it is empty
            if(dat[[column]][n] == &#39;&#39; || is.na(dat[[column]][n])){
                ## If it is the row 1, stop with Error
                if(n == 1){
                    stop(paste0(&amp;quot;Row 1 of column &amp;lt;&amp;quot;, column,
                                    &amp;quot;&amp;gt; has empty values. Check your data.&amp;quot;))
                }
                else{
                    dat[[column]][n] &amp;lt;- dat[[column]][n - 1]
                }
            }
        }
    }
    return(dat)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here we are implementing &lt;code&gt;if (!column %in% names(dat))&lt;/code&gt;. Again we are using &lt;code&gt;!&lt;/code&gt; to tell R to test the opposite. &lt;code&gt;column %in% names(dat)&lt;/code&gt; will take the value of &lt;code&gt;column&lt;/code&gt; and check if it is present in the vector &lt;code&gt;names(dat)&lt;/code&gt; (which has the names of the columns).&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s test the last error by misspelling the name of one column&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;fill_merged(my.table, c(&#39;Specie&#39;, &#39;Treatment&#39;))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; Error in fill_merged(my.table, c(&amp;quot;Specie&amp;quot;, &amp;quot;Treatment&amp;quot;)): Column &amp;lt;Treatment&amp;gt; cannot be found in the data frame
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you can think of more errors feel free to add them, it will be good for you  as a practice. However you should also try and see what happens with other potential scenarios before adding the errors yourself. Sometimes the default errors from other functions are enough to solve problems. For example, try providing to our function a data frame that does not exist, R will immediately tell you &lt;code&gt;object &#39;x&#39; not found&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&#34;final&#34;&gt;Final remarks&lt;/h2&gt;
&lt;p&gt;I hope that the post has helped you to have a better understanding of &lt;code&gt;for()&lt;/code&gt; and &lt;code&gt;if()&lt;/code&gt;, and provided you with a good guidance on how you can plan and structure functions. If something was not clear or you still have questions, or something in your code did not work as expected, feel welcome to leave us a comment below (you will need a github account for that).&lt;/p&gt;
&lt;p&gt;There are many ways how you can call your function now to your future projects. One of the easiest for now would be to save it in an R script, for example &lt;code&gt;fill_merged_cells.R&lt;/code&gt; and then you can call it from any script or R code by providing the path to your script to the function &lt;code&gt;source()&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;source(&#39;~/Rscripts/fill_merged_cells.R&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;changing the path to the exact location of your file. Source will run all the code contained inside the &lt;code&gt;.R&lt;/code&gt; file in the R session where you call it, making your function available for the current session.&lt;/p&gt;
&lt;p&gt;Here is the final form of the &lt;strong&gt;function for filling in empty rows produced by merged cells&lt;/strong&gt;. I hope it will help with your work. Enjoy it!&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;fill_merged &amp;lt;- function(dat, columns.as.vector){
    ## Check if column names are provided as strings
    if(!is.character(columns.as.vector)){
        stop(&amp;quot;Column names must be provided as string or vector of strings of class character&amp;quot;)
    }
    ## Go through the columns
    for(column in columns.as.vector){
        ## Check if the column name matches with dat column names
        if (!column %in% names(dat)){
            stop(paste0(&#39;Column &amp;lt;&#39;, column, &#39;&amp;gt; cannot be found in the data frame&#39;))
        }
        ## Get value of each row
        for(n in 1:nrow(dat)){
            ## Check if it is empty
            if(dat[[column]][n] == &#39;&#39; || is.na(dat[[column]][n])){
                ## If it is the row 1, stop with Error
                if(n == 1){
                    stop(paste0(&amp;quot;Row 1 of column &amp;lt;&amp;quot;, column,
                                    &amp;quot;&amp;gt; has empty values. Check your data.&amp;quot;))
                }
                else{
                    dat[[column]][n] &amp;lt;- dat[[column]][n - 1]
                }
            }
        }
    }
    return(dat)
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Functions in R</title>
      <link>https://blog.rwhitedwarf.com/post/functions/</link>
      <pubDate>Tue, 30 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://blog.rwhitedwarf.com/post/functions/</guid>
      <description>&lt;h2 id=&#34;background&#34;&gt;Background&lt;/h2&gt;
&lt;p&gt;This is the first post of R with White Dwarf and I decided to start this blog with a basic tutorial. There is already a lot of information in the web about getting started with R. With a simple google search you can easily find info on how to install it, how to use R studio or other text editor, learn about the basic functions and concepts, what is a vector, a data frame, how to use them, etc. Therefore, I decided to start with a topic that is also basic and fundamental but slightly less common: Functions.&lt;/p&gt;
&lt;p&gt;How to create a function is not an easy topic for non-programmers and non-mathematicians, Myself I have a background in Ecology and when I started using R for my statistical analysis I was avoiding using functions at all cost, while most of my colleagues where avoiding R fully. Many people has the idea that, as a programming language, R is really difficult to use and it should be left for the initiated ones. They end up using user interface based-software which assumes not only that the user doesn&amp;rsquo;t know about programming, but also about statistics. It makes things easy for the user but also limits the possibilities of what you can do with your data and as a result, it also what you can learn.&lt;/p&gt;
&lt;p&gt;In today&amp;rsquo;s world, it is important to to have at least a basic understanding of programming. Learning how to write simple functions in R will widen your perception about R and programming by showing you that it is actually easy. I am writing this post especially for all the people who are not programmers, not statisticians and are thinking to learn R. By the end of the post I hope that you can agree with me that writing functions in R is not difficult.&lt;/p&gt;
&lt;h2 id=&#34;how-to-write-functions-in-r&#34;&gt;How to write functions in R&lt;/h2&gt;
&lt;p&gt;Basically, when we use R we are using functions all the time. When you want to obtain the summation of values, or the mean or standard deviation, you can simply call a function to do that&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;values &amp;lt;- c(2, 3, 4, 5)
sum(values)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; [1] 14
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you should already know from any R tutorial, the example above is storing the values in the vector &lt;code&gt;value&lt;/code&gt; and then calling the function &lt;code&gt;sum&lt;/code&gt; to obtain the summation of the values. One way to create our own version of sum would be:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;my_sum &amp;lt;- function(user.values){
    cumulative.sum &amp;lt;- user.values[1]
    for(i in 2:length(user.values)){
        cumulative.sum &amp;lt;- cumulative.sum + user.values[i]
    }
    return(cumulative.sum)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we can call our brand new function and obtain the same results&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;my_sum(values)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; [1] 14
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let&amp;rsquo;s go piece by piece. Line no. &lt;em&gt;1&lt;/em&gt; is simply placing the function that we are creating into the object &lt;code&gt;my_sum&lt;/code&gt; which means that later, we can call our function using that same argument: &lt;code&gt;my_func(some values)&lt;/code&gt;. This is similar to creating a vector or data frame or variables, as you know, if you enter &lt;code&gt;x &amp;lt;- 12&lt;/code&gt; then each time you type &lt;code&gt;x&lt;/code&gt; in the console it will return the value &lt;code&gt;12&lt;/code&gt;, and so it explains line &lt;em&gt;2&lt;/em&gt;, when we define &lt;code&gt;cumulative.sum &amp;lt;- user.values[1]&lt;/code&gt; this places the first value of the vector &lt;code&gt;user.values&lt;/code&gt; into the variable &lt;code&gt;cumulative.sum&lt;/code&gt;. It means that now we can start by adding the second value to the &lt;code&gt;cumulative.sum&lt;/code&gt;, then we move forward to the third value, and so on until the last element in the vector. This process is defined in the for loop: we move value by value from the second element to the last one: &lt;code&gt;for(i in 2:length(user.values))&lt;/code&gt;, each time we stored the cumulative value in our variable &lt;code&gt;cumulative.sum&lt;/code&gt; until we reach the last value. I will not go deep into the for loop, but I understand that it can also be somehow complicated for a beginner, if it is your case I invite you to leave us a comment (you will need a github account for that) and I might cover it in a future issue.&lt;/p&gt;
&lt;p&gt;Once we are outside the for loop we have collected the final value in &lt;code&gt;cumulative.sum&lt;/code&gt; so, we make sure that our function is returning exactly that by using &lt;code&gt;return(cumulative.sum)&lt;/code&gt;. If you have seen some other tutorials you might have noticed that the &lt;code&gt;return()&lt;/code&gt; is not always added at the end of the function. And indeed, it is not strictly necessary (more on that later), but as a beginner it is good to start with good habits and defining what exactly you want your function to return is a good habit for your future functions.&lt;/p&gt;
&lt;h3 id=&#34;simple-error-handling&#34;&gt;Simple error handling&lt;/h3&gt;
&lt;p&gt;When you work with functions you need to tell the user what exactly went wrong in order to help him fix it. Even if you are writing functions only for yourself, after a while has passed you might forget all the logic behind your function and thus, obtaining errors that you don&amp;rsquo;t understand where they come from. A basic knowledge of error handling can help us prevent that.&lt;/p&gt;
&lt;p&gt;What I&amp;rsquo;m explaining here is a very basic and simple management of errors but yet, practical and useful, it can save us wasted time and headaches. It is something I wish I had learned when I started writing my first functions. Due to my ignorance it used to take me a lot of time just to figure out what was wrong with my own code.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s go back to our function. As you probably already noticed, it starts summing up from the second value in the vector, therefore if we provide only one value instead of a vector of values the result will be &lt;code&gt;NA&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;my_sum(12)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; [1] NA
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;quite silly compared to the professional function from base-R which returns the value itself&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;sum(12)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; [1] 12
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We could try to imitate the base-R &lt;code&gt;sum()&lt;/code&gt; and continue in that direction, but instead we are going to have a little fun with simple examples of errors. Let&amp;rsquo;s say that instead of returning the value itself, we want our new function to send an error when a single value is entered. For that, we simply need to check if the value size is bigger than 1, and if not, send the error. We can achieve that with an if statement:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;my_sum &amp;lt;- function(user.values){
    if(length(user.values) == 1){
        stop(&#39;We cannot sum individual values here!&#39;)
    }
    cumulative.sum &amp;lt;- user.values[1]
    for(i in 2:length(user.values)){
        cumulative.sum &amp;lt;- cumulative.sum + user.values[i]
    }
    return(cumulative.sum)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see in line &lt;em&gt;2&lt;/em&gt;, we will enter inside the if-part-of-code if the length of the values is one (we cannot have length smaller than 1, if we run the function without a value, R will say that the argument is missing), calling &lt;code&gt;stop()&lt;/code&gt; which basically stops the function at that point, and exits printing whatever message you define inside it. Go ahead and try it.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;my_sum(12)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; Error in my_sum(12): We cannot sum individual values here!
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I am sure that with this basic info you can already move forward and improve it even more to send an error message when an object other than a vector is entered. Try to do it yourself and feel free to leave me a comment below if you get any trouble. Some hints: You can use the function &lt;code&gt;is.vector()&lt;/code&gt; to test if the value entered by the user is a vector or not; and you can place one if statement inside the other, first to check if it is a vector, and secondly to check its size.&lt;/p&gt;
&lt;h3 id=&#34;function-arguments&#34;&gt;Function arguments&lt;/h3&gt;
&lt;p&gt;You might be wondering what about the argument used as variable &lt;code&gt;user.values&lt;/code&gt;, where does it come from? how is it defined? how does R knows how to use it? Keeping it simple, all the arguments that you define inside the parenthesis of a function will be searched by R when you execute the function and will be used accordingly. You can easily see how we were using the variable &lt;code&gt;user.values&lt;/code&gt; to tell the rest of the program what to do with it. The function has no idea if the user will enter a single value, a vector or a data frame, this is the reason why we created the errors with &lt;code&gt;stop()&lt;/code&gt;. As the creator of the function, it is your role to decide what kind of object you need, how to use it and how to ensure that the user knows what is wrong if an unexpected object is entered.&lt;/p&gt;
&lt;p&gt;You can define as many arguments as you wish for your function, for example&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;sum_four_nums &amp;lt;- function(num1, num2, num3, num4){
    return(sum(num1, num2, num3, num4))
}

sum_four_nums(2, 4, 6, 8)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; [1] 20
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here we are telling R to take the four values entered by the user and sum them up. R will check the values in the order they are entered, so in our example it will associate the value 2 with our first variable &lt;code&gt;num1&lt;/code&gt;, then the value 4 with the second variable &lt;code&gt;num2&lt;/code&gt; and so on. If we miss one of the values, R will tell us that one of the variables is missing&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;sum_four_nums(2, 4, 6)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; Error in sum_four_nums(2, 4, 6): argument &amp;quot;num4&amp;quot; is missing, with no default
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we want to allow the user to provide only 3 values, we can initialize one of them as null&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;sum_four_nums &amp;lt;- function(num1, num2, num3, num4 = NULL){
    return(sum(num1, num2, num3, num4))
}

sum_four_nums(2, 4, 6)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; [1] 12
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This means that we can actually initialize our variables with whatever we want to put on it, for example we can tell our function to always add 10 if only 3 values are entered by the user&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;sum_four_nums &amp;lt;- function(num1, num2, num3, num4 = 10){
    return(sum(num1, num2, num3, num4))
}

sum_four_nums(2, 4, 6)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; [1] 22
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Also notice that we are telling R to take strictly four values, and not a vector of size 4. If we do this, R will associate the vector to the variable &lt;code&gt;num1&lt;/code&gt; as one object and will complain that the other arguments are missing&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;sum_four_nums(c(2, 4, 6, 8))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; Error in sum_four_nums(c(2, 4, 6, 8)): argument &amp;quot;num2&amp;quot; is missing, with no default
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As I mentioned already, R is not aware of what type of object the user should enter, therefore we could as well enter only a vector, or vector and numbers, and R will simply apply the &lt;code&gt;sum()&lt;/code&gt; function to whatever is inside it, because this is how we defined our function&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;sum_four_nums(c(2, 4, 6, 8), 20, 50)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; [1] 100
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here R is summing first all values contained in the vector, then 20 and 50, and finally the predefined 10. As you can see, the proper handling of errors is important when you want to ensure that you function does what is intended to do, or to help you or the user identify what exactly when wrong.&lt;/p&gt;
&lt;h3 id=&#34;functions-without-arguments&#34;&gt;Functions without arguments&lt;/h3&gt;
&lt;p&gt;You can also define functions without arguments, meaning without direct input from the user. For example, let&amp;rsquo;s write the classical Hello World!, a function that, when called, prints the sentence itself&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;hello_world_function &amp;lt;- function(){
    print(&#39;Hello World!&#39;)
}

hello_world_function()
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; [1] &amp;quot;Hello World!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see, in line &lt;em&gt;1&lt;/em&gt; when we define the function there is nothing inside the parenthesis and thus, when we call the function we don&amp;rsquo;t need to include anything inside it. This example might look silly, but sometimes we want the functions for their side effects, rather than for the values they return.&lt;/p&gt;
&lt;p&gt;When we write a function, R will search for the variable inside the function&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;sum_my_vector &amp;lt;- function(){
    my.vector &amp;lt;- c(10, 20, 30)
    return(sum(my.vector))
}

sum_my_vector()
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; [1] 60
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ls()
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;  [1] &amp;quot;base.dir&amp;quot;             &amp;quot;base.url&amp;quot;             &amp;quot;changing.wd&amp;quot;         
&amp;gt;  [4] &amp;quot;dirs&amp;quot;                 &amp;quot;fig.path&amp;quot;             &amp;quot;func.params&amp;quot;         
&amp;gt;  [7] &amp;quot;hello_world_function&amp;quot; &amp;quot;my_sum&amp;quot;               &amp;quot;rmd.file&amp;quot;            
&amp;gt; [10] &amp;quot;rmd.path&amp;quot;             &amp;quot;sum_four_nums&amp;quot;        &amp;quot;sum_my_vector&amp;quot;       
&amp;gt; [13] &amp;quot;values&amp;quot;               &amp;quot;work.in&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see, the vector called &lt;code&gt;my.vector&lt;/code&gt; is created inside the function and thus, when we call it, the function returns the sum of the vector. However, when we list all the objects in memory using &lt;code&gt;ls()&lt;/code&gt;, the object &lt;code&gt;my.vector&lt;/code&gt; doesn&amp;rsquo;t exists. All the objects that we define inside the function live only there. If we now create an object called &lt;code&gt;my.vector&lt;/code&gt; and call again the function, the result will not change&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;my.vector &amp;lt;- c(1, 2, 3)
sum_my_vector()
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; [1] 60
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ls()
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;  [1] &amp;quot;base.dir&amp;quot;             &amp;quot;base.url&amp;quot;             &amp;quot;changing.wd&amp;quot;         
&amp;gt;  [4] &amp;quot;dirs&amp;quot;                 &amp;quot;fig.path&amp;quot;             &amp;quot;func.params&amp;quot;         
&amp;gt;  [7] &amp;quot;hello_world_function&amp;quot; &amp;quot;my_sum&amp;quot;               &amp;quot;my.vector&amp;quot;           
&amp;gt; [10] &amp;quot;rmd.file&amp;quot;             &amp;quot;rmd.path&amp;quot;             &amp;quot;sum_four_nums&amp;quot;       
&amp;gt; [13] &amp;quot;sum_my_vector&amp;quot;        &amp;quot;values&amp;quot;               &amp;quot;work.in&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The reason is that R functions search for objects inside the function. Therefore, you could give the same names to objects inside and outside the functions without affecting the outcome, however this is not recommended because it might cause confusion in the future. Another reason why is not recommended is that R searches for the object inside the function first, but when it cannot find it, it searches for the object outside of the function, in your working environment (it means, what we can see listed by &lt;code&gt;ls()&lt;/code&gt;), for example&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;sum_other_vector &amp;lt;- function(){
    return(sum(my.vector))
}

sum_other_vector()
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; [1] 6
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;here I have created a similar function but this time I did not create the object &lt;code&gt;my.vector&lt;/code&gt; inside it, therefore R is using the one that I loaded into the working environment as &lt;code&gt;my.vector &amp;lt;- c(1, 2, 3)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We could consider the objects created inside the function as local variables because they have local effect only, and the ones defined outside of the function as global variables. Other programming languages make a clear difference of this two and handle each of them differently, often by initiating the global variables with special characters, or creating them using special functions, in order to avoid mistakes and confusion. In R you should be very careful on how you name your objects and where you use them when you are creating functions.&lt;/p&gt;
&lt;p&gt;On the other hand it has the advantage that it is very easy to create functions that use the same structure of data. For example, I could create a data frame called &lt;code&gt;elements&lt;/code&gt; that will always contain the columns called &lt;code&gt;Pb&lt;/code&gt;, &lt;code&gt;As&lt;/code&gt;, &lt;code&gt;Cd&lt;/code&gt; and &lt;code&gt;Zn&lt;/code&gt; and then just make functions that take no arguments to do all my statistics at once by calling the same table and the same columns inside them.&lt;/p&gt;
&lt;h2 id=&#34;why-to-write-functions&#34;&gt;Why to write functions&lt;/h2&gt;
&lt;p&gt;As mentioned above, I started writing functions when I did my Ph.D. I was working with contaminated soils and basically for all my projects I had to analyze data of concentration of elements. This means that for each project, I had to repeat the same process for each element and then, for the next project do the same for the new data and for different or more elements. Luckily my first project was only focused on 4 different elements. I did a script for the statistics and visualizations of the first element, organize the workflow, decided what would be variable and what constant, and created two functions, one for the statistics and one for the visualizations, based on the output of the first one, and then just applied the functions to the remaining 3 elements.&lt;/p&gt;
&lt;p&gt;When I got the first results of my second experiment it was related to more than 10 different elements, and that only for soils, I knew that later I&amp;rsquo;d have to do the same statistics for different parts of the plants. Therefore I decided to create a package. I simply googled how to put all my functions together in a package, installed it and then, for each of my next data results I could simply call my own functions directly in my R environment from any folder and do all the statistical analysis way faster than I can even measure.&lt;/p&gt;
&lt;p&gt;Learning how to write functions in R is not only intended for processes or calculations that don&amp;rsquo;t have a particular function yet (today basically everything is cover in one or another package). It can save a lot of time in any kind of work you are doing. It can reduce the time you need for your data analysis and the amount of code written in your scripts. As a result it also makes your code more organized and more understandable. It can also help you to understand better how R works, as you need to get more familiar with the type of objects used, the structures of the functions, the application of conditionals and iterative processes, etc.&lt;/p&gt;
&lt;p&gt;Functions are a key element of most (probably all) programming languages and thus, learning how to create your own will also develop your programming skills and teach you how to automatize tasks. There is a general informal rule for programming that is called the &lt;strong&gt;DRY&lt;/strong&gt; principle, which means &lt;strong&gt;D&lt;/strong&gt;on&amp;rsquo;t &lt;strong&gt;R&lt;/strong&gt;epeat &lt;strong&gt;Y&lt;/strong&gt;ourself. In other words, if there is a process in your code/program/script that has to be repeated at least once, it is worth it to write a function and then call it twice with the different arguments that will be variable rather than coping the whole code from the first case and pasting it where the second case needs it and only changing the arguments that are variable in the second case. The next post will be exactly about that.&lt;/p&gt;
&lt;h2 id=&#34;final-remarks&#34;&gt;Final remarks&lt;/h2&gt;
&lt;p&gt;I hope that this tutorial has reach its goal of showing how easy and useful is to write your own functions in R. I agree that all the functions created here had minimum practical application. It is usually the case when getting started. But right in our next post we are going to write our first complete function with practical application: A function that fills empty rows generated from merged cells imported from excel.&lt;/p&gt;
&lt;p&gt;Stay in touch!&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
