<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>R maps on R with White Dwarf</title>
    <link>https://blog.rwhitedwarf.com/tags/r-maps/</link>
    <description>Recent content in R maps on R with White Dwarf</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Wed, 13 Sep 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.rwhitedwarf.com/tags/r-maps/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Map any region in the world with R - Part IV: Object Oriented Programming in R with S3</title>
      <link>https://blog.rwhitedwarf.com/post/map_any_region_with_ggplot2_part_iv/</link>
      <pubDate>Wed, 13 Sep 2023 00:00:00 +0000</pubDate>
      
      <guid>https://blog.rwhitedwarf.com/post/map_any_region_with_ggplot2_part_iv/</guid>
      <description>&lt;p&gt;You can find all the posts on this series under the tag &lt;a href=&#34;https://blog.rwhitedwarf.com/tags/maps-app/&#34; title=&#34;#maps-app&#34; target=&#34;_blank&#34;&gt;maps-app&lt;/a&gt; (including the Spanish versions).&lt;/p&gt;
&lt;p&gt;You can also find the current state of the project under &lt;a href=&#34;https://github.com/teotenn&#34; target=&#34;_blank&#34;&gt;my GitHub&lt;/a&gt; repo &lt;a href=&#34;https://github.com/teotenn/mapic&#34; target=&#34;_blank&#34;&gt;mapic&lt;/a&gt;.&lt;/p&gt;
&lt;h1 id=&#34;scope-of-this-post&#34;&gt;Scope of this post&lt;/h1&gt;
&lt;p&gt;We are creating maps of data showing changes over a span of time for different countries and pointing at all kinds of cities. That basically means that we need to &lt;strong&gt;map any region of the world with R&lt;/strong&gt;. Today there are all kinds of packages and techniques to do that. I will share the strategy I used with &lt;a href=&#34;https://cran.r-project.org/web/packages/ggplot2/index.html&#34; target=&#34;_blank&#34;&gt;ggplot2&lt;/a&gt; and &lt;a href=&#34;https://cran.r-project.org/web/packages/maps/index.html&#34; target=&#34;_blank&#34;&gt;maps&lt;/a&gt; packages, using support of &lt;a href=&#34;https://www.openstreetmap.org/&#34; target=&#34;_blank&#34;&gt;Open Street Map&lt;/a&gt; to obtain the coordinates of cities and finally making it interactive with &lt;a href=&#34;https://shiny.rstudio.com/&#34; target=&#34;_blank&#34;&gt;shiny&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This series of posts share my path towards the creation of the Shiny app. It is a live project and I decided to share my path and experiences along the creation process. The posts are not only about the Shiny app, but the package I created behind it, including topics of functions crafting, creation of the maps, classes of objects, etc., as well as any interesting issue that appear on the way. It is my way to contribute to the R community and at the same time keeping the project documented for myself.&lt;/p&gt;
&lt;p&gt;This post is about &lt;strong&gt;Object Oriented Programming in R using S3 objects&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;I hope you all enjoy it. Feel free to leave any kind of comment and/or question at the end.&lt;/p&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://blog.rwhitedwarf.com/post/2022/map_any_region_with_ggplot2_part_I/maps_DrawingMap.png&#34; alt=&#34;R Maps&#34; /&gt;
&lt;/p&gt;
&lt;h1 id=&#34;object-oriented-programming-and-r&#34;&gt;Object oriented programming and R&lt;/h1&gt;
&lt;p&gt;R is a programming language that benefits greatly from the paradigm of functional programming. This is actually how most of R users utilize it and how it is recommended. However, it also offers the possibility of applying object oriented programming (OOP) paradigm which is the creation and use of objects with defined characteristics and methods. If you have never heard of this concept I recommend you to do a little research about it before getting deep into this post. I would recommend to start with the introduction to OOP of &lt;a href=&#34;https://adv-r.hadley.nz/oo.html&#34; target=&#34;_blank&#34;&gt;Advanced R&lt;/a&gt;. It is not my intention to explain OOP but rather to use it, in combination with functional programming, to support sharing information between functions.&lt;/p&gt;
&lt;p&gt;If you followed the &lt;a href=&#34;https://blog.rwhitedwarf.com/post/map_any_region_with_ggplot2_part_iii/&#34;&gt;previous post&lt;/a&gt; you might have noticed that at the &lt;a href=&#34;https://blog.rwhitedwarf.com/post/map_any_region_with_ggplot2_part_iii/#conclusions&#34;&gt;conclusions&lt;/a&gt; section I mentioned the use of OOP to extend our ggplot2 functions. The idea is to pass information between the functions to make the calculations more accurate rather than forcing the end user to repeat the information in each function. I mentioned the possibility of using environments, or the ggplot2 internal class &lt;code&gt;ggproto&lt;/code&gt;. The use of environments has a different function than what I am trying to achieve here, while the &lt;code&gt;ggproto&lt;/code&gt; objects are excellent to pass information between graphics created with &lt;code&gt;ggplot2&lt;/code&gt; but they become complicated if we want to include any more information like data frames or lists of values. Therefore I decided to keep it simple with the use of S3 objects.&lt;/p&gt;
&lt;p&gt;S3 objects are the most commonly used in R packages, the recommended ones and apparently, the only ones used in base-r and stats packages. As &lt;a href=&#34;https://adv-r.hadley.nz/s3.html&#34; target=&#34;_blank&#34;&gt;Hadley Wickham&lt;/a&gt; says it:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;S3 is R’s first and simplest OO system. S3 is informal and ad hoc, but there is a certain elegance in its minimalism: you can’t take away any part of it and still have a useful OO system. For these reasons, you should use it, unless you have a compelling reason to do otherwise. S3 is the only OO system used in the base and stats packages, and it’s the most commonly used system in CRAN packages.&lt;/p&gt;
&lt;p&gt;S3 is very flexible, which means it allows you to do things that are quite ill-advised. If you’re coming from a strict environment like Java this will seem pretty frightening, but it gives R programmers a tremendous amount of freedom. It may be very difficult to prevent people from doing something you don’t want them to do, but your users will never be held back because there is something you haven’t implemented yet. Since S3 has few built-in constraints, the key to its successful use is applying the constraints yourself.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;implementation-of-s3-class-objects-for-the-creation-of-the-maps&#34;&gt;Implementation of S3 class objects for the creation of the maps&lt;/h1&gt;
&lt;p&gt;An S3 object in R is basically a structured list with a class name. It can be easily created by placing the list within the function &lt;code&gt;structure&lt;/code&gt; and defining the &lt;code&gt;class&lt;/code&gt;, &lt;code&gt;structure(list(...), class = c(&amp;quot;class_name&amp;quot;))&lt;/code&gt;, or by creating the list first and then setting the class of that list. Then we create generics using the function &lt;code&gt;UseMethod()&lt;/code&gt; and add methods for each class by appending the class name to the generic, followed by a dot (i.e., &lt;code&gt;my_generic.MyClass&lt;/code&gt;, &lt;code&gt;my_generic.vector&lt;/code&gt;, &lt;code&gt;my_generic.matrix&lt;/code&gt;, etc.).&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s start with a simple example.&lt;/p&gt;
&lt;h2 id=&#34;a-simple-s3-object-for-the-colors&#34;&gt;A simple S3 object for the colors&lt;/h2&gt;
&lt;p&gt;We start by defining a function that initializes the object, our &lt;strong&gt;constructor&lt;/strong&gt;. We should use this function to also check that our object contains the values that we need and throw some errors when there are mistakes.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;define_map_colors &amp;lt;- function(dots_orgs,
                              target_country,
                              empty_countries,
                              border_countries,
                              oceans,
                              text_cities,
                              text_legend,
                              background_legend,
                              text_copyright) {
  require(stringr)

  ## Error handling
  all_arguments &amp;lt;- c(as.list(environment()))
  for (arggs in all_arguments) {
    stopifnot(&amp;quot;All arguments must be character&amp;quot; = is.character(arggs))
    if (nchar(arggs) != 7) {
      stop(&amp;quot;Colors should be in hex notation&amp;quot;)
    }
    if (!str_detect(arggs, &amp;quot;^#&amp;quot;)) {
      stop(&amp;quot;Colors should be in hex notation&amp;quot;)
    }
  }

  ## S3 object definition
  structure(
    list(
      dots_orgs = dots_orgs,
      target_country = target_country,
      empty_countries = empty_countries,
      border_countries = border_countries,
      oceans = oceans,
      text_cities = text_cities,
      text_legend = text_legend,
      background_legend = background_legend,
      text_copyright = text_copyright),
    class = c(&amp;quot;map_colors&amp;quot;))
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The function takes 9 arguments, each of them should be a color in hex notation, meaning that it must start with &lt;code&gt;#&lt;/code&gt; and it must contain 6 alphanumeric characters (i.e., &lt;code&gt;#f0f0f0&lt;/code&gt;). Thus, our error handling basically verifies that the parameters passed are of class &lt;code&gt;character&lt;/code&gt; starting with &lt;code&gt;#&lt;/code&gt; and containing exactly 7 symbols. Then, each of the 9 arguments is passed to a list within &lt;code&gt;structure&lt;/code&gt; and set them to the class &lt;code&gt;map_colors&lt;/code&gt;. And our object is created.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;default_map_colors &amp;lt;- define_map_colors(dots_orgs = &amp;quot;#493252&amp;quot;,
                               target_country = &amp;quot;#8caeb4&amp;quot;,
                               empty_countries = &amp;quot;#f3f3f3&amp;quot;,
                               border_countries = &amp;quot;#9c9c9c&amp;quot;,
                               oceans = &amp;quot;#4e91d2&amp;quot;,
                               text_cities = &amp;quot;#a0a0a0&amp;quot;,
                               text_legend = &amp;quot;#493252&amp;quot;,
                               background_legend = &amp;quot;#ffffff&amp;quot;,
                               text_copyright = &amp;quot;#f3f3f3&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is the same list of colors used in our &lt;a href=&#34;https://blog.rwhitedwarf.com/post/map_any_region_with_ggplot2_part_iii/&#34;&gt;previous post&lt;/a&gt; by the &lt;a href=&#34;https://blog.rwhitedwarf.com/post/map_any_region_with_ggplot2_part_iii/#background-and-preliminaries&#34;&gt;function that creates the maps&lt;/a&gt;. If you check the class of our new list of colors, &lt;code&gt;class(default_map_colors)&lt;/code&gt; it should be &lt;code&gt;map_colors&lt;/code&gt;. Since our new object is also a list, we could use it indistinctly to create the maps. Thus, we need a method that verifies that our object is actually of the class &lt;code&gt;map_colors&lt;/code&gt;. This is the &lt;strong&gt;validator&lt;/strong&gt;. The method &lt;code&gt;is&lt;/code&gt; already does that for other classes (i.e., &lt;code&gt;is.character()&lt;/code&gt;) therefore, we can add our object to tell it how to handle it.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;is.map_colors &amp;lt;- function(x) inherits(x, &amp;quot;map_colors&amp;quot;)

is.map_colors(default_map_colors)
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;[1] TRUE&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The function is very simple, we just need to check if the object passed inherits the class. Now we can use &lt;code&gt;is.map_colors()&lt;/code&gt; in all the functions that create maps in order to ensure that our new class is used rather than a simple list.&lt;/p&gt;
&lt;h2 id=&#34;creating-a-new-object-within-a-function&#34;&gt;Creating a new object within a function&lt;/h2&gt;
&lt;p&gt;Once again, I have made improvements to the function presented before, &lt;a href=&#34;https://blog.rwhitedwarf.com/post/map_any_region_with_ggplot2_part_iii/#background-and-preliminaries&#34;&gt;my_country_prev&lt;/a&gt;. This time the change is only one, almost by the end of the body: the addition of an S3 object that holds information which is used later by other functions that add layers to the map. It is not only about the colors, but we are also adding the values of the limits, so that other functions, such as labels creation, know about it. Since this version is more stable, I have also renamed it to a more formal name.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;base_map &amp;lt;- function(country,
                     x_limits = NULL,
                     y_limits = NULL,
                     show_coords = FALSE,
                     return_mapic_obj = TRUE,
                     map_colors = default_map_colors) {
  require(maps)
  require(ggplot2)

  ## Verifying the arguments passed to the function
  if (length(country) != 1) stop(&amp;quot;Function supports only one country per map&amp;quot;)
  stopifnot(is.logical(show_coords))
  stopifnot(&amp;quot;Name of the country should be character&amp;quot; = is.character(country))

  if (!country %in% map_data(&amp;quot;world&amp;quot;)$region) {
    stop(paste(&amp;quot;Country name not recognized&amp;quot;,
               &amp;quot;To see a list of recognized countries run&amp;quot;,
               &amp;quot;&amp;lt;unique(maps::map_data(&#39;world&#39;)$region)&amp;gt;&amp;quot;, sep = &amp;quot;\n&amp;quot;))
  }

  ## If coords limits missing, print worldwide map with coordinates system to allow
  ## User observe coords for reference
  if (missing(x_limits) || missing(y_limits)) {
    warning(&amp;quot;X and/or Y limits not provided.\nPrinting worldwide map.&amp;quot;)
    map_country_theme &amp;lt;- theme(panel.background = element_rect(fill = map_colors$oceans))
  } else if (show_coords) {
    map_country_theme &amp;lt;- theme(panel.background = element_rect(fill = map_colors$oceans))
  } else {
    if (length(x_limits) != 2 || length(y_limits) != 2 ||
         !all(grepl(&amp;quot;^-?[0-9.]+$&amp;quot;, c(x_limits, y_limits)))) {
      stop(&amp;quot;Limits for X and Y coords should be provided as vectors with two numeric values&amp;quot;)
    } else {

      ## Custom theme for the final map
      map_country_theme &amp;lt;- theme_bw() +
        theme(panel.background = element_rect(fill = map_colors$oceans),
              legend.position = &amp;quot;none&amp;quot;,
              panel.grid.major = element_blank(),
              panel.grid.minor = element_blank(),
              axis.line = element_line(colour = &amp;quot;black&amp;quot;),
              axis.title.x = element_blank(),
              axis.text.x = element_blank(),
              axis.ticks.x = element_blank(),
              axis.title.y = element_blank(),
              axis.text.y = element_blank(),
              axis.ticks.y = element_blank())
    }
  }

  ## Get the target cpuntry data
  map_data_country &amp;lt;- map_data(&amp;quot;world&amp;quot;)[map_data(&amp;quot;world&amp;quot;)$region == country, ]

  ## The map
  mapic &amp;lt;- ggplot() +
    ## First layer: worldwide map
    geom_polygon(data = map_data(&amp;quot;world&amp;quot;),
                 aes(x = long, y = lat, group = group),
                 color = map_colors$border_countries,
                 fill = map_colors$empty_countries) +
    ## Second layer: Country map
    geom_polygon(data = map_data_country,
                 aes(x = long, y = lat, group = group),
                 color = map_colors$border_countries,
                 fill = map_colors$target_country) +
    coord_map() +
    coord_fixed(1.3,
                xlim = x_limits,
                ylim = y_limits) +
    map_country_theme

  if (return_mapic_obj) {
    map_pointer &amp;lt;- structure(
      list(
        mapic = mapic,
        base_map = mapic,
        x_limits = x_limits,
        y_limits = y_limits,
        colors = map_colors
      ),
      class = &amp;quot;mapicHolder&amp;quot;)
    return(map_pointer)
  } else {
    return(mapic)
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The new &lt;code&gt;base_map&lt;/code&gt; does the same as the previous &lt;code&gt;my_country_prev&lt;/code&gt;: it creates the base map of a country. However, we have added the option to return a mapic object or not. When the option, &lt;code&gt;return_mapic_obj&lt;/code&gt; is set to &lt;code&gt;FALSE&lt;/code&gt;, the function behaves as before and it returns the map only. But when it is set as &lt;code&gt;TRUE&lt;/code&gt;, it generates a new object of class &lt;code&gt;mapicHolder&lt;/code&gt; that holds the information that will be piped to other functions as we mentioned above. Other changes are  minimal regarding style, the function still does the same.&lt;/p&gt;
&lt;p&gt;As you can see, the object does not necessarily has to be available to the end user for manipulation or modification. Here we can create 2 different objects to move forward with the creation of the maps and the end user does not need to know the structure or even the existence of the object. Thus, &lt;code&gt;spain &amp;lt;- base_map(&amp;quot;Spain&amp;quot;)&lt;/code&gt; will create an object with the base map for Spain, and &lt;code&gt;france &amp;lt;- base_map(&amp;quot;France&amp;quot;)&lt;/code&gt; creates a similar object for the base map of France. Each of them in an object of class &lt;code&gt;mapicHolder&lt;/code&gt; that can be called later. The idea is to be able to use the information of each of them easily by the rest of the functions that add layers to our maps.&lt;/p&gt;
&lt;h2 id=&#34;defining-our-own-methods&#34;&gt;Defining our own methods&lt;/h2&gt;
&lt;p&gt;Now that we have our S3 object and we know how to modify methods, let&amp;rsquo;s create a new method specially for it. We are going to replace our previous function &lt;a href=&#34;https://blog.rwhitedwarf.com/post/map_any_region_with_ggplot2_part_iii/#a-map-with-growing-dots-per-city&#34;&gt;make_dots&lt;/a&gt; for a method that works differently depending on the class of object that is passed. The initialization is pretty simple, it can be accomplished in one line:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;make_dots &amp;lt;- function(x, ...) UseMethod(&amp;quot;make_dots&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After this &lt;code&gt;make_dots&lt;/code&gt; exists as a method which behavior we can modified based on the class of the object passed. Notice the ellipsis (the three dots &lt;code&gt;...&lt;/code&gt;) in the function definition, they are necessary to ensure that all the arguments defined after our object (&lt;code&gt;x&lt;/code&gt;) are taken into account as well.&lt;/p&gt;
&lt;p&gt;With this we can re-write the definition of our function &lt;a href=&#34;https://blog.rwhitedwarf.com/post/map_any_region_with_ggplot2_part_iii/#a-map-with-growing-dots-per-city&#34;&gt;make_dots&lt;/a&gt;, or in other words, its name, to have it as the default behavior. The body of the function remains the same.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;make_dots.default &amp;lt;- function(.df,
                      year,
                      map_colors,
                      column_names = list(
                        lat = &amp;quot;lat&amp;quot;,
                        lon = &amp;quot;lon&amp;quot;,
                        cities = &amp;quot;city&amp;quot;,
                        start_year = &amp;quot;year&amp;quot;,
                        end_year = NULL),
                      dot_size = 1) {
  ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The function should be working as if no changes were done. The advantage is that now, we can create a second one, with the same name, which will behave differently when our object &lt;code&gt;mapicHolder&lt;/code&gt; is used.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;make_dots.mapicHolder &amp;lt;- function(.mapic_holder,
                                        .df,
                                        year,
                                        column_names = list(
                                          lat = &amp;quot;lat&amp;quot;,
                                          lon = &amp;quot;lon&amp;quot;,
                                          cities = &amp;quot;city&amp;quot;,
                                          start_year = &amp;quot;year&amp;quot;,
                                          end_year = NULL),
                                        dot_size = 1) {
  require(dplyr)
  require(tidyr)
  require(stringr)

  column_names &amp;lt;- column_names[lengths(column_names) != 0]
  year__ &amp;lt;- year

  ## Check required fields
  mandatory_cols &amp;lt;- c(&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;cities&amp;quot;, &amp;quot;start_year&amp;quot;)
  if (!all(mandatory_cols %in% names(column_names))) {
    stop(&amp;quot;Column names missing!&amp;quot;)
  } else {
    if (!&amp;quot;end_year&amp;quot; %in% names(column_names)) {
      .df$final_year &amp;lt;- NA_real_
      column_names[[&amp;quot;end_year&amp;quot;]] &amp;lt;- &amp;quot;final_year&amp;quot;
    }
  }

  ## Make map using default method
  mapic_dots &amp;lt;- make_dots(.df = .df,
                          year = year__,
                          map_colors = .mapic_holder$colors,
                          column_names = column_names,
                          dot_size = dot_size)

  ## Papere the data
  data_for_map &amp;lt;- .df  %&amp;gt;%
    mutate_at(vars(column_names$end_year), ~replace_na(., year__ + 1)) %&amp;gt;%
    mutate(year_final = !!sym(column_names$end_year),
           city_name = str_to_sentence(!!sym(column_names$cities))) %&amp;gt;%
    filter(year_final &amp;gt; year__ &amp;amp; !!sym(column_names$start_year) &amp;lt;= year__) %&amp;gt;%
    group_by(city_name) %&amp;gt;%
    summarise(x = median(!!sym(column_names$lon), na.rm = TRUE),
              y = median(!!sym(column_names$lat), na.rm = TRUE),
              n = n())

  ## Empty theme for labels
  empty_theme &amp;lt;- theme_bw() +
    theme(legend.position = &amp;quot;none&amp;quot;,
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          axis.line = element_line(colour = &amp;quot;white&amp;quot;),
          axis.title.x = element_blank(),
          axis.text.x = element_blank(),
          axis.ticks.x = element_blank(),
          axis.title.y = element_blank(),
          axis.text.y = element_blank(),
          axis.ticks.y = element_blank(),
          plot.margin = unit(c(-0, -0, -0, -0), &amp;quot;cm&amp;quot;))

  .mapic_holder[[&amp;quot;theme_labels&amp;quot;]] &amp;lt;- empty_theme
  .mapic_holder[[&amp;quot;mapic_dots&amp;quot;]] &amp;lt;- mapic_dots
  .mapic_holder[[&amp;quot;year&amp;quot;]] &amp;lt;- year__
  .mapic_holder[[&amp;quot;data&amp;quot;]] &amp;lt;- list(base = .df, map = data_for_map)
  .mapic_holder[[&amp;quot;mapic&amp;quot;]] &amp;lt;- .mapic_holder[[&amp;quot;mapic&amp;quot;]] + mapic_dots
  return(.mapic_holder)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The new function is basically applying the default function to the data, but the parameters required are different: we now request the object of class &lt;code&gt;mapicHolder&lt;/code&gt; but we don&amp;rsquo;t need to request the &lt;code&gt;map_colors&lt;/code&gt; because they come within the mentioned object. Additionally, we are adding additional data to our &lt;code&gt;mapicHolder&lt;/code&gt; to be passed and used for more functions.&lt;/p&gt;
&lt;p&gt;Now we have two options to create the maps. One specifying every parameter like in the &lt;a href=&#34;https://blog.rwhitedwarf.com/posts/2023/programming_with_ggplot2&#34;&gt;previous post&lt;/a&gt; using the &lt;code&gt;.default&lt;/code&gt; method:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;base_map(&amp;quot;Mexico&amp;quot;,
                map_colors,
                 x_limits = c(-118, -86),
                 y_limits = c(14, 34),
                 show_coords = T) +
  make_dots(datmx,
            year = 2022,
            map_colors, column_names = col_names)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Or the new version where the &lt;code&gt;mapicHolder&lt;/code&gt; can be piped from function to function:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;base_map(&amp;quot;Mexico&amp;quot;,
         map_colors,
         x_limits = c(-118, -86),
         y_limits = c(14, 34),
         show_coords = T) |&amp;gt;
  make_dots(datmx,
            year = 2022,
            column_names = col_names)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It has been a good exercise to learn the basis of S3 object but so far the differences between one and the other are minimal. Other than avoid repeating the list of colors, there is not much gain. However, all the information that we have gathered in our &lt;code&gt;mapicHolder&lt;/code&gt; object has high value to create the labels accurately and to place them in a proper position.&lt;/p&gt;
&lt;h2 id=&#34;passing-information-to-the-labels&#34;&gt;Passing information to the labels&lt;/h2&gt;
&lt;p&gt;To have our map complete, we are going to pass our &lt;code&gt;mapicHolder&lt;/code&gt; to the functions that print the years and the totals. As we did above, we first create our method and define its default behaviour.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;my_print_totals &amp;lt;- function(x, ...) UseMethod(&amp;quot;my_print_totals&amp;quot;)

my_print_totals.default &amp;lt;- function(totals, map_colors, x_limits, y_limits, totals_label = &amp;quot;Totals&amp;quot;) {
  ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can find the &lt;a href=&#34;https://blog.rwhitedwarf.com/post/map_any_region_with_ggplot2_part_iii/#adding-labels-for-the-map&#34;&gt;code of the original functions&lt;/a&gt; in my previous post. Now for our new function we can basically remove all the parameters and add only a &lt;code&gt;mapicHolder&lt;/code&gt; object, which already contains the rest of the information.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;my_print_totals.mapicHolder &amp;lt;- function(.mapic_holder,
                                        totals_label = &amp;quot;Totals&amp;quot;) {
  data_totals &amp;lt;- sum(.mapic_holder$data$map$n)
  mapic_totals &amp;lt;- my_print_totals(totals = data_totals,
                                  x_limits = .mapic_holder$x_limits,
                                  y_limits = .mapic_holder$y_limits,
                                  totals_label = totals_label,
                                  map_colors = .mapic_holder$colors)

  .mapic_holder[[&amp;quot;mapic_totals&amp;quot;]] &amp;lt;- mapic_totals
  .mapic_holder[[&amp;quot;totals&amp;quot;]] &amp;lt;- data_totals
  .mapic_holder[[&amp;quot;mapic&amp;quot;]] &amp;lt;- .mapic_holder[[&amp;quot;mapic&amp;quot;]] + mapic_totals
  return(.mapic_holder)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Basically the body of &lt;code&gt;my_print_totals.mapicHolder&lt;/code&gt; consists of passing the right parameters to &lt;code&gt;my_print_totals.default&lt;/code&gt;, and adding the new layer to the &lt;code&gt;mapicHolder&lt;/code&gt;. We can do exactly the same for the years and we will have the complete map ready to be shown.&lt;/p&gt;
&lt;h1 id=&#34;creating-the-map&#34;&gt;Creating the map&lt;/h1&gt;
&lt;p&gt;Before we are able to pipe and show the map, we need a couple preparations more. In order to show the map when we call our object, rather than a bunch of information, we need to add our object class to &lt;code&gt;print&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;print.mapicHolder &amp;lt;- function(p) plot(p$mapic)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It will be useful to do the same for &lt;code&gt;plot&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;plot.mapicHolder &amp;lt;- function(p) plot(p$mapic)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we can simply pipe one function after the other and reduce the amount of arguments passed to each function.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;my_country_prev(&amp;quot;Mexico&amp;quot;,
                map_colors,
                x_coords,
                y_coords,
                show_coords = T) |&amp;gt;
  make_dots(rbind(datmx, datmx),
            year = 2020,
            col_names) |&amp;gt;
  my_print_years(year_label = &amp;quot;Año&amp;quot;) |&amp;gt;
  my_print_totals(totals_label = &amp;quot;Totales&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://blog.rwhitedwarf.com/post/2023/map_any_region_with_ggplot2_part_III/unnamed-chunk-8-1.png&#34; alt=&#34;plot of chunk unnamed-chunk-8&#34; /&gt;
&lt;/p&gt;
&lt;h1 id=&#34;final-remarks&#34;&gt;Final Remarks&lt;/h1&gt;
&lt;p&gt;Now we have not only a functional workflow for the creation of the maps, but also a more user friendly one. If it is true that it does not follow the standards of &lt;code&gt;ggplot2&lt;/code&gt; of adding layers using &lt;code&gt;+&lt;/code&gt;, it uses the R pipe introduced in version 4.0 (we can also use dplyr&amp;rsquo;s pipe &lt;code&gt;%&amp;gt;%&lt;/code&gt;) which makes more sense, since it is the direction that R as a whole is taking.&lt;/p&gt;
&lt;p&gt;In the next post we will step back to the coordinates manipulation to implement a new system of objects to be able to use different types of databases. For now, our functions are able to use only &lt;code&gt;SQLite&lt;/code&gt; and &lt;code&gt;data.frame&lt;/code&gt; to store the information, which is fine for prototyping or for small projects, but very limited for production usage.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Map any region in the world with R - Part III: Programming with ggplot2</title>
      <link>https://blog.rwhitedwarf.com/post/map_any_region_with_ggplot2_part_iii/</link>
      <pubDate>Wed, 19 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>https://blog.rwhitedwarf.com/post/map_any_region_with_ggplot2_part_iii/</guid>
      <description>&lt;p&gt;You can find all the posts on this series under the tag &lt;a href=&#34;https://blog.rwhitedwarf.com/tags/maps-app/&#34; title=&#34;#maps-app&#34; target=&#34;_blank&#34;&gt;maps-app&lt;/a&gt; (including the Spanish versions).&lt;/p&gt;
&lt;p&gt;You can also find the current state of the project under &lt;a href=&#34;https://github.com/teotenn&#34; target=&#34;_blank&#34;&gt;my GitHub&lt;/a&gt; repo &lt;a href=&#34;https://github.com/teotenn/mapic&#34; target=&#34;_blank&#34;&gt;mapic&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;scope-of-this-post&#34;&gt;Scope of this post&lt;/h2&gt;
&lt;p&gt;We are creating maps of data showing changes over a span of time for different countries and pointing at all kinds of cities. That basically means that we need to &lt;strong&gt;map any region of the world with R&lt;/strong&gt;. Today there are all kinds of packages and techniques to do that. I will share the strategy I used with &lt;a href=&#34;https://cran.r-project.org/web/packages/ggplot2/index.html&#34; target=&#34;_blank&#34;&gt;ggplot2&lt;/a&gt; and &lt;a href=&#34;https://cran.r-project.org/web/packages/maps/index.html&#34; target=&#34;_blank&#34;&gt;maps&lt;/a&gt; packages, using support of &lt;a href=&#34;https://www.openstreetmap.org/&#34; target=&#34;_blank&#34;&gt;Open Street Map&lt;/a&gt; to obtain the coordinates of cities and finally making it interactive with &lt;a href=&#34;https://shiny.rstudio.com/&#34; target=&#34;_blank&#34;&gt;shiny&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This series of posts share my path towards the creation of the Shiny app. It is a live project and I decided to share my path and experiences along the creation process. The posts are not only about the Shiny app, but the package I created behind it, including topics of functions crafting, creation of the maps, classes of objects, etc., as well as any interesting issue that appear on the way. It is my way to contribute to the R community and at the same time keeping the project documented for myself.&lt;/p&gt;
&lt;p&gt;This post is about &lt;strong&gt;Creating functions for ggplot&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;I hope you all enjoy it. Feel free to leave any kind of comment and/or question at the end.&lt;/p&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://blog.rwhitedwarf.com/post/2022/map_any_region_with_ggplot2_part_I/maps_DrawingMap.png&#34; alt=&#34;R Maps&#34; /&gt;
&lt;/p&gt;
&lt;h2 id=&#34;background-and-preliminaries&#34;&gt;Background and preliminaries&lt;/h2&gt;
&lt;p&gt;In the &lt;a href=&#34;https://blog.rwhitedwarf.com/post/map_any_region_with_ggplot2_part_i/&#34; target=&#34;_blank&#34;&gt;first post&lt;/a&gt; we created a function to create the basic map. Since then I have modified the function slightly, but the concept is the same. You can see below the most up to date version and compare it with the &lt;a href=&#34;https://blog.rwhitedwarf.com/post/map_any_region_with_ggplot2_part_i/#function-to-create-the-basic-map-in-r&#34; target=&#34;_blank&#34;&gt;previous version&lt;/a&gt; if you wish.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;my_country_prev &amp;lt;- function(country,
                            map_colors,
                            x_limits = NULL,
                            y_limits = NULL,
                            show_coords = FALSE) {
  require(maps)
  require(ggplot2)

  ## Verifying the arguments passed to the function
  if (length(country) != 1) stop(&amp;quot;Function supports only one country per map&amp;quot;)
  stopifnot(is.logical(show_coords))
  stopifnot(&amp;quot;Name of the country should be character&amp;quot; = is.character(country))

  if (!country %in% map_data(&#39;world&#39;)$region) {
    stop(paste(&amp;quot;Country name not recognized&amp;quot;,
               &amp;quot;To see a list of recognized countries run&amp;quot;,
               &amp;quot;&amp;lt;unique(maps::map_data(&#39;world&#39;)$region)&amp;gt;&amp;quot;, sep = &amp;quot;\n&amp;quot;))
  }

  ## If coords limits missing, print worldwide map with coordinates system to allow
  ## User observe coords for reference
  if (missing(x_limits) || missing(y_limits)) {
    warning(&amp;quot;X and/or Y limits not provided.\nPrinting worldwide map.&amp;quot;)
    map_country_theme &amp;lt;- theme(panel.background = element_rect(fill = map_colors$oceans))
  } else if (show_coords) {
    map_country_theme &amp;lt;- theme(panel.background = element_rect(fill = map_colors$oceans))
  } else {
    if (length(x_limits) != 2 || length(y_limits) != 2 ||
         !all(grepl(&amp;quot;^-?[0-9.]+$&amp;quot;, c(x_limits, y_limits)))) {
      stop(&amp;quot;Limits for X and Y coords should be provided as vectors with two numeric values&amp;quot;)
    } else {

      ## All the received inputs are correct.
      ## Let&#39;s define our custom theme for the final map
      map_country_theme &amp;lt;- theme_bw() +
        theme(panel.background = element_rect(fill = map_colors$oceans),
              legend.position = &amp;quot;none&amp;quot;,
              panel.grid.major = element_blank(),
              panel.grid.minor = element_blank(),
              axis.line = element_line(colour = &amp;quot;black&amp;quot;),
              axis.title.x = element_blank(),
              axis.text.x = element_blank(),
              axis.ticks.x = element_blank(),
              axis.title.y = element_blank(),
              axis.text.y = element_blank(),
              axis.ticks.y = element_blank())
    }
  }

  ## make a df with only the country to overlap
  map_data_country &amp;lt;- map_data(&#39;world&#39;)[map_data(&#39;world&#39;)$region == country, ]
  ## The map (maps + ggplot2 )
  mapic &amp;lt;- ggplot() +
    ## First layer: worldwide map
    geom_polygon(data = map_data(&amp;quot;world&amp;quot;),
                 aes(x = long, y = lat, group = group),
                 color = map_colors$border_countries, # border countries
                 fill = map_colors$empty_countries) + # empty countries
    ## Second layer: Country map
    geom_polygon(data = map_data_country,
                 aes(x = long, y = lat, group = group),
                 color = map_colors$border_countries, # border target country
                 fill = map_colors$target_country) + # target country
    coord_map() +
    coord_fixed(1.3,
                xlim = x_limits,
                ylim = y_limits) +
    map_country_theme

  return(mapic)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;One critical difference is the argument &lt;code&gt;map_colors&lt;/code&gt; that is nor explained or well defined. This is a list object containing the values for the colors to be used for all the elements of the maps. There are different ways to define and use this. The idea is to make it an S3 object and explain it on its own, but it is a topic that I am still exploring and I haven&amp;rsquo;t decided yet the details of it. For now, let&amp;rsquo;s use it simply as a list containing our chosen colors for the map.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;map_colors &amp;lt;- list(dots_orgs = &amp;quot;#493252&amp;quot;,
                   target_country = &amp;quot;#8caeb4&amp;quot;,
                   empty_countries = &amp;quot;#f3f3f3&amp;quot;,
                   border_countries = &amp;quot;#9c9c9c&amp;quot;,
                   oceans = &amp;quot;#4e91d2&amp;quot;,
                   text_cities = &amp;quot;#a0a0a0&amp;quot;,
                   text_legend = &amp;quot;#493252&amp;quot;,
                   background_legend = &amp;quot;#ffffff&amp;quot;,
                   text_copyright = &amp;quot;#f3f3f3&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The function easily prints the map of any country, using the naming from the package &lt;code&gt;maps&lt;/code&gt;. Now we want to add the data to it.&lt;/p&gt;
&lt;p&gt;Now we need to define some simple data frame simulating a collection of organizations in Mexico.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;mx_data &amp;lt;- data.frame(
  ID = c(1:10),
  Name = sprintf(&amp;quot;org%d&amp;quot;, seq(1:10)),
  Registration_year = c(2001:2010),
  Country = &amp;quot;MX&amp;quot;,
  Region = c(&amp;quot;Mexico&amp;quot;,
             &amp;quot;Baja California Norte&amp;quot;,
             &amp;quot;Mexico&amp;quot;,
             &amp;quot;Jalisco&amp;quot;,
             &amp;quot;Queretaro&amp;quot;,
             &amp;quot;Baja California Norte&amp;quot;,
             &amp;quot;Mexico&amp;quot;,
             &amp;quot;Morelos&amp;quot;,
             &amp;quot;Mexico&amp;quot;,
             &amp;quot;Estado de Mexico&amp;quot;),
  City = c(&amp;quot;Ciudad de Mexico&amp;quot;,
           &amp;quot;Tijuana&amp;quot;,
           &amp;quot;Ciudad de Mexico&amp;quot;,
           &amp;quot;Guadalajara&amp;quot;,
           &amp;quot;Queretaro&amp;quot;,
           &amp;quot;Tijuana&amp;quot;,
           &amp;quot;Ciudad de Mexico&amp;quot;,
           &amp;quot;Cuernavaca&amp;quot;,
           &amp;quot;Ciudad de Mexico&amp;quot;,
           &amp;quot;Texcoco&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can see it as a company that along 10 years managed to open one new franchise per year, and we want to map where each is located and where it has grown the most. For that, we need the coordinates of the cities where each franchise is located. We can easily obtain that using code from the previous posts: either directly from &lt;a href=&#34;https://blog.rwhitedwarf.com/post/map_any_region_with_ggplot2_part_ii/&#34; target=&#34;_blank&#34;&gt;part II&lt;/a&gt; or the &lt;a href=&#34;https://blog.rwhitedwarf.com/post/webscrap_and_iteration_in_r/&#34; target=&#34;_blank&#34;&gt;improved version of the function&lt;/a&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;webscrap_to_db(db_name = &amp;quot;test-mex.sqlite&amp;quot;,
               dat = mx_data,
               city = &amp;quot;City&amp;quot;,
               country = &amp;quot;Country&amp;quot;,
               db_backup_after = 5)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And also using previously defined functions, we can combine the data with the just obtained coordinates system.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;(datmx &amp;lt;- combine_csv_sql(db_file = &amp;quot;test-mex.sqlite&amp;quot;,
                         csv_file = mx_data))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;    ID  Name Registration_year             City Country Region State County
&amp;gt; 1   1  org1              2001 Ciudad de Mexico      MX                    
&amp;gt; 2   2  org2              2002          Tijuana      MX                    
&amp;gt; 3   3  org3              2003 Ciudad de Mexico      MX                    
&amp;gt; 4   4  org4              2004      Guadalajara      MX                    
&amp;gt; 5   5  org5              2005        Queretaro      MX                    
&amp;gt; 6   6  org6              2006          Tijuana      MX                    
&amp;gt; 7   7  org7              2007 Ciudad de Mexico      MX                    
&amp;gt; 8   8  org8              2008       Cuernavaca      MX                    
&amp;gt; 9   9  org9              2009 Ciudad de Mexico      MX                    
&amp;gt; 10 10 org10              2010          Texcoco      MX                    
&amp;gt;                                                            osm_name        lon
&amp;gt; 1                                          Ciudad de México, México  -99.13318
&amp;gt; 2     Tijuana, Municipio de Tijuana, Baja California, 22320, México -117.01953
&amp;gt; 3                                          Ciudad de México, México  -99.13318
&amp;gt; 4                                      Guadalajara, Jalisco, México -103.33840
&amp;gt; 5  Santiago de Querétaro, Municipio de Querétaro, Querétaro, México -100.39706
&amp;gt; 6     Tijuana, Municipio de Tijuana, Baja California, 22320, México -117.01953
&amp;gt; 7                                          Ciudad de México, México  -99.13318
&amp;gt; 8                                Cuernavaca, Morelos, 62000, México  -99.23423
&amp;gt; 9                                          Ciudad de México, México  -99.13318
&amp;gt; 10                                   Texcoco, Carbó, Sonora, México -111.05867
&amp;gt;         lat
&amp;gt; 1  19.43263
&amp;gt; 2  32.53174
&amp;gt; 3  19.43263
&amp;gt; 4  20.67204
&amp;gt; 5  20.59547
&amp;gt; 6  32.53174
&amp;gt; 7  19.43263
&amp;gt; 8  18.92183
&amp;gt; 9  19.43263
&amp;gt; 10 29.63900
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now &lt;code&gt;datmx&lt;/code&gt; should have the coordinates, together with the rest of the data about our franchises. We should also have our SQLite file and, of course, our source data. It means that we are ready to add the data to the map.&lt;/p&gt;
&lt;h2 id=&#34;programming-with-ggplot2&#34;&gt;Programming with ggplot2&lt;/h2&gt;
&lt;p&gt;If you ever wondered how to create functions with ggplot2, there are a few ways, but here is the basic point that we need to understand, if we want to have them working in the same style as ggplot works:&lt;/p&gt;
&lt;p&gt;Once you have the base plot with the function &lt;code&gt;ggplot()&lt;/code&gt; you can add geoms and stats to it by simply using &lt;code&gt;+&lt;/code&gt;, or you can create new functions by returning a &lt;code&gt;list&lt;/code&gt; of geoms and stats.&lt;/p&gt;
&lt;p&gt;The first point is as simple as the following lines:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;my_country_prev(&amp;quot;Mexico&amp;quot;, map_colors, x_limits = c(-118, -86), y_limits = c(14, 34)) +
  ggtitle(&amp;quot;A map of Mexico&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://blog.rwhitedwarf.com/post/2023/map_any_region_with_ggplot2_part_III/map1-1.png&#34; alt=&#34;plot of chunk map1&#34; /&gt;
&lt;/p&gt;
&lt;p&gt;Or we could do the same by creating a function and returning the title inside a list.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;my_title &amp;lt;- function(text) {
  return(list(ggtitle(text)))
}

my_country_prev(&amp;quot;Mexico&amp;quot;, map_colors, x_limits = c(-118, -86), y_limits = c(14, 34)) +
  my_title(&amp;quot;The same map of Mexico&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://blog.rwhitedwarf.com/post/2023/map_any_region_with_ggplot2_part_III/map2-1.png&#34; alt=&#34;plot of chunk map2&#34; /&gt;
&lt;/p&gt;
&lt;p&gt;With that in mind, we can do all the calculations we want and start adding the data in form of geoms and stats to the base map.&lt;/p&gt;
&lt;h3 id=&#34;a-map-with-growing-dots-per-city&#34;&gt;A map with growing dots per city&lt;/h3&gt;
&lt;p&gt;We started with something simple, adding the amount of organizations per city, as growing dots.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;make_dots &amp;lt;- function(.df,
                      year,
                      map_colors,
                      column_names = list(
                        lat = &amp;quot;lat&amp;quot;,
                        lon = &amp;quot;lon&amp;quot;,
                        cities = &amp;quot;city&amp;quot;,
                        start_year = &amp;quot;year&amp;quot;,
                        end_year = NULL),
                      dot_size = 1) {
  require(dplyr)
  require(tidyr)
  require(stringr)

  ## Some error handling
  mandatory_cols &amp;lt;- c(&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;cities&amp;quot;, &amp;quot;start_year&amp;quot;)
  if(!all(mandatory_cols %in% names(column_names))) {
    stop(&amp;quot;Column names missing!&amp;quot;)
  } else {
    if (!&amp;quot;end_year&amp;quot; %in% names(column_names)) {
      .df$final_year &amp;lt;- NA_real_
      column_names[[&amp;quot;end_year&amp;quot;]] &amp;lt;- &amp;quot;final_year&amp;quot;
    }
  }

  ## Dots base size
  base_size &amp;lt;- 5
  dot_sizes &amp;lt;- c(0.5 * (base_size * dot_size),
                 1 * (base_size * dot_size),
                 2 * (base_size * dot_size),
                 3 * (base_size * dot_size),
                 4 * (base_size * dot_size),
                 5 * (base_size * dot_size),
                 7 * (base_size * dot_size),
                 8 * (base_size * dot_size),
                 9 * (base_size * dot_size))

  ## Data manipulation to be used in the map
  filt &amp;lt;- .df  %&amp;gt;%
    mutate(year_final = replace_na(!!sym(column_names$end_year), year + 1),
           city_name = str_to_sentence(!!sym(column_names$cities))) %&amp;gt;%
    filter(year_final &amp;gt; year &amp;amp; !!sym(column_names$start_year) &amp;lt;= year) %&amp;gt;%
    group_by(city_name) %&amp;gt;%
    summarise(x = median(!!sym(column_names$lon), na.rm = T),
              y = median(!!sym(column_names$lat), na.rm = T),
              n = n()) %&amp;gt;%
    mutate(dot_size = case_when(n == 1 ~ dot_sizes[1], 
                                n &amp;gt;= 2 &amp;amp; n &amp;lt;= 5 ~ dot_sizes[2], 
                                n &amp;gt;= 6 &amp;amp; n &amp;lt;= 10 ~ dot_sizes[3], 
                                n &amp;gt;= 11 &amp;amp; n &amp;lt;= 30 ~ dot_sizes[4], 
                                n &amp;gt;= 31 &amp;amp; n &amp;lt;= 50 ~ dot_sizes[5], 
                                n &amp;gt;= 51 &amp;amp; n &amp;lt;= 100 ~ dot_sizes[6], 
                                n &amp;gt;= 101 &amp;amp; n &amp;lt;= 200 ~ dot_sizes[7], 
                                n &amp;gt;= 201 &amp;amp; n &amp;lt;= 300 ~ dot_sizes[8], 
                                n &amp;gt;= 301 ~ dot_sizes[9],
                                TRUE ~ NA))

  ## -------------------------- MAIN MAP ----------------------------------
  map_points &amp;lt;- list(
    geom_point(data = filt,
               aes(x, y, size = dot_size),
               color = map_colors$dots_orgs,
               alpha = 7/10,
               shape = 19) ,
    scale_size_identity(&#39;&#39;,
                        breaks = dot_sizes, 
                        labels = c(&#39;1&#39;, &#39;2-5&#39;, &#39;6-10&#39;, &#39;11-30&#39;, &#39;31-50&#39;,
                                   &#39;51-100&#39;, &#39;101-200&#39;, &#39;201-300&#39;, &#39;&amp;gt;300&#39;),
                        guide = guide_legend(label.position = &#39;bottom&#39;,
                                             label.vjust = 0,
                                             nrow = 1)),
    geom_point(data = filter(filt, n == 1),
               aes(x, y),
               color = map_colors$dots_orgs,
               shape = 19,
               size = 2.5) ,
    theme(legend.position = &#39;bottom&#39;)
  )

  return(map_points)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see, the function also requires our object &lt;code&gt;map_colors&lt;/code&gt;, which we created before. Another way of passing values from a list is by defining these values directly within the function arguments, as we did here for &lt;code&gt;column_names&lt;/code&gt;. We could pass the arguments directly when calling the function, or define them earlier to be used. Let&amp;rsquo;s use the second approach.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;col_names = list(lat = &amp;quot;lat&amp;quot;,
                 lon = &amp;quot;lon&amp;quot;,
                 cities = &amp;quot;City&amp;quot;,
                 start_year = &amp;quot;Registration_year&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you look at the data frame that we created containing the data, this are simply the names of the columns as we specified them.&lt;/p&gt;
&lt;p&gt;Now, about the function itself, it starts, as expected, by calling the libraries and then doing a bit of error handling to ensure that the fields that are strictly required are actually present in the data frame. There I am also adding the options for the &lt;code&gt;end_year&lt;/code&gt; which is used in case some franchise closed and we want to map it only for the period of time it was present.&lt;/p&gt;
&lt;p&gt;Then we define the &lt;strong&gt;&amp;ldquo;Dots base size&amp;rdquo;&lt;/strong&gt;. Here we experimented with so many sizes, both for the dots and for the final map, and this are the ones that look the best. Still, I&amp;rsquo;m allowing this value to be changed as the parameter &lt;code&gt;dot_size&lt;/code&gt; in the function definition, however I wouldn&amp;rsquo;t recommend changing it. You can also play with the internal values and see it for yourself. Since the idea here is to create functions for the &amp;ldquo;standards&amp;rdquo; of the maps, allowing minimal changes, we are not so strict as per how big the dots should be, yet we have certain degree of control.&lt;/p&gt;
&lt;p&gt;Then we do a little bit of data manipulation before being able to use the data. This includes the standardization of the names of Cities (up to some degree), filtering the data that does not match with the selected year, using only the median value of the latitude and longitude data, and defining the sizes of the dots according to the amount of franchises. The last one is a tricky one that I haven&amp;rsquo;t decided yet what amount of freedom should still be out there. Maybe there should be a separated function to define all that. Our maps were created to handle data containing from few hundreds of rows, to a couple of thousands, thus, the values presented here. But if you want to show just a few organizations (as is the case of this example), the map looks quite deserted; on the other hand, if you need to map values of thousands per city, the maps look overloaded. For the present post I&amp;rsquo;m keeping it as is, with a note for consideration. We also added one extra &lt;code&gt;geom_point&lt;/code&gt; to overwrite the alpha value for the case of only 1, and make it solid. This also works well on the visuals.&lt;/p&gt;
&lt;p&gt;In any case, the function above shows how we can manipulate the data inside a function, and return only what we need to add it to an existent ggplot. We can now add the dots as we would normally do in ggplot style.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;my_country_prev(&amp;quot;Mexico&amp;quot;,
                map_colors,
                 x_limits = c(-118, -86),
                 y_limits = c(14, 34),
                 show_coords = T) +
  make_dots(datmx,
            year = 2022,
            map_colors, column_names = col_names) +
  scale_x_continuous(n.breaks = 20) +
  ggtitle(&amp;quot;A map of Mexico&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://blog.rwhitedwarf.com/post/2023/map_any_region_with_ggplot2_part_III/unnamed-chunk-5-1.png&#34; alt=&#34;plot of chunk unnamed-chunk-5&#34; /&gt;
&lt;/p&gt;
&lt;h3 id=&#34;adding-labels-for-the-map&#34;&gt;Adding labels for the map&lt;/h3&gt;
&lt;p&gt;Moving forward, we want to add some labels to the maps to know what we are seeing. Here I created one function to show which year is being mapped, and a second one to show the totals. Although we can achieve that easily in different ways, I managed to make it complicated, keeping in mind that we want to map any region in the world.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;my_print_years &amp;lt;- function(year, map_colors, x_limits, y_limits, year_label = &amp;quot;Year&amp;quot;) {

  ## POSITION FOR THE LABELS
  ## Starting points
  x_units &amp;lt;- abs(x_limits[1] - x_limits[2])/10
  y_units &amp;lt;- abs(y_limits[1] - y_limits[2])/10
  start_x &amp;lt;- min(x_limits)
  start_y &amp;lt;- min(y_limits)
  ## Frame
  rectangle.start.x &amp;lt;- start_x
  rectangle.wide &amp;lt;- rectangle.start.x + x_units
  rectangle.start.y &amp;lt;- start_y
  rectangle.high &amp;lt;- rectangle.start.y + y_units
  ## Text
  num.size &amp;lt;- 4
  text.size &amp;lt;- 3  
  num.position.x &amp;lt;- start_x + (x_units * 0.5)
  text.position.x &amp;lt;- start_x + (x_units * 0.5)
  num.position.y &amp;lt;- start_y + (y_units * 0.25)
  text.position.y &amp;lt;- start_y + (y_units * 0.65)

  ## Adding the ggplot geoms
  pyears &amp;lt;- list(
    geom_rect(
      aes(xmin = rectangle.start.x, xmax = rectangle.wide,
          ymin = rectangle.start.y, ymax = rectangle.high),
      color = map_colors$text_legend,
      fill = map_colors$text_legend,
      alpha = 9/10),
    geom_text(
      aes(x = num.position.x,
          y = num.position.y,
          label = year),
      size = num.size,
      fontface = &#39;bold&#39;,
      color = map_colors$background_legend),
    geom_text(
      aes(x = text.position.x,
          y = text.position.y,
          label = year_label),
      size = text.size,
      fontface = &#39;bold&#39;,
      alpha = 9/10,
      color = map_colors$background_legend)
  )
  return(pyears)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Consider this some kind of snippet to add the labels wherever you want, and in any size you want. Our function is basically doing some basic simple calculations to place the labelling inside the map area, on the bottom-left corner. The first part with the comment &lt;code&gt;## POSITION FOR THE LABELS&lt;/code&gt; shows the basic calculations to do that, based on the coords, which should be the same as the coords specified in the map function. The calculations and the position are very stiff in size and location, but they will work the same regardless of the region mapped. On the other hand, it provides the basis for the function. Feel free to play with them to add custom options such as selecting the sizes or the corner where we want to display them.&lt;/p&gt;
&lt;p&gt;The rest of the code is intuitive, &lt;code&gt;geom_text&lt;/code&gt; to add the info we want to show, one for the word &amp;ldquo;Year&amp;rdquo; and another one for the numeric value. We add the corresponding values to the &lt;code&gt;aes&lt;/code&gt;, the sizes, some alpha for transparency and our colors defined in &lt;code&gt;map_colors&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;my_print_totals &amp;lt;- function(totals, map_colors, x_limits, y_limits, totals_label = &amp;quot;Totals&amp;quot;) {
  ## POSITION FOR THE LABELS
  ## Starting points
  x_units &amp;lt;- abs(x_limits[1] - x_limits[2])/10
  y_units &amp;lt;- abs(y_limits[1] - y_limits[2])/10
  start_x &amp;lt;- min(x_limits) + x_units
  start_y &amp;lt;- min(y_limits)
  ## Frame
  rectangle.start.x &amp;lt;- start_x
  rectangle.wide &amp;lt;- rectangle.start.x + x_units
  rectangle.start.y &amp;lt;- start_y
  rectangle.high &amp;lt;- rectangle.start.y + y_units
  ## Text
  num.size &amp;lt;- 4
  text.size &amp;lt;- 3  
  num.position.x &amp;lt;- start_x + (x_units*0.5)
  text.position.x &amp;lt;- start_x + (x_units*0.5)
  num.position.y &amp;lt;- start_y + (y_units*0.25)
  text.position.y &amp;lt;- start_y + (y_units*0.65)
  
    ptotals &amp;lt;- list(
        geom_rect(aes(xmin = rectangle.start.x, xmax = rectangle.wide,
                      ymin = rectangle.start.y, ymax = rectangle.high),
                  color = &#39;#283151&#39;,
                  fill = map_colors$background_legend,
                  alpha = 9/10),
        geom_text(
            aes(x = num.position.x, y = num.position.y,
                label = totals),
            size = num.size,
            fontface = &#39;bold&#39;,
            alpha = 9/10,
            color = map_colors$text_legend),
        geom_text(
            aes(x = text.position.x, y = text.position.y,
                label = totals_label),
            size = text.size,
            fontface = &#39;bold&#39;,
            alpha = 9/10,
            color = map_colors$text_legend)
    )
    return(ptotals)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can follow exactly the same approach for the totals, to place them right next to the year. For now we have to specify the value of the total that we want to be shown, but this actually should be calculated by the function. Actually, if you think about it, we are passing a great deal of information that should be coming from the previous functions, and we should keep here arguments that control the visuals of the labels only. That is not an easy topic and I decided to cover it in a separated post. Another reason why I don&amp;rsquo;t want to show it yet is because I haven&amp;rsquo;t decided yet which approach I want to use.&lt;/p&gt;
&lt;p&gt;So, for now we have to pass each argument to each function and make sure that we are passing the same argument, but that is easy to achieve in R by directing the values to an object before passing it to the functions. Let&amp;rsquo;s see it in action.&lt;/p&gt;
&lt;p&gt;The dataset has already been stored in &lt;code&gt;datmx&lt;/code&gt; and the colors in &lt;code&gt;map_colors&lt;/code&gt;. Now we need to define a few more.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;x_coords &amp;lt;- c(-118, -86)
y_coords &amp;lt;- c(14, 34)
yr &amp;lt;- 2020
totals &amp;lt;- 10
my_country_prev(&amp;quot;Mexico&amp;quot;,
                map_colors,
                x_coords,
                y_coords,
                show_coords = T) +
  make_dots(rbind(datmx, datmx),
            map_colors,
            year = yr,
            col_names) +
  my_print_years(yr, map_colors, x_coords, y_coords, &amp;quot;Año&amp;quot;) +
  my_print_totals(totals, map_colors, x_coords, y_coords, &amp;quot;Totales&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://blog.rwhitedwarf.com/post/2023/map_any_region_with_ggplot2_part_III/unnamed-chunk-8-1.png&#34; alt=&#34;plot of chunk unnamed-chunk-8&#34; /&gt;
&lt;/p&gt;
&lt;p&gt;And there it is. Since my map is for Mexico, I am adding labels in Spanish. Feel free to test it in your own language and with more data. We can also have a look at how the labels fit to other countries, for example, smaller and bigger compared to Mexico.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;x_coords &amp;lt;- c(4, 18)
y_coords &amp;lt;- c(47, 56)
my_country_prev(&amp;quot;Germany&amp;quot;,
                map_colors,
                 x_coords, y_coords,
                 show_coords = T) + 
  my_print_years(yr, map_colors, x_coords, y_coords) +
  my_print_totals(totals, map_colors, x_coords, y_coords) +
  ggtitle(&amp;quot;A map of Germany&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://blog.rwhitedwarf.com/post/2023/map_any_region_with_ggplot2_part_III/unnamed-chunk-9-1.png&#34; alt=&#34;plot of chunk unnamed-chunk-9&#34; /&gt;
&lt;/p&gt;
&lt;p&gt;Germany is also looking good. And since we have the possibility of passing the values for year and totals, we don&amp;rsquo;t actually need to have any data to test it, although the info shown is incorrect.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;x_coords &amp;lt;- c(28, 185)
y_coords &amp;lt;- c(10, 100)
my_country_prev(&amp;quot;Russia&amp;quot;,
                map_colors,
                 x_coords, y_coords,
                 show_coords = T) +
  my_print_years(yr, map_colors, x_coords, y_coords) +
  my_print_totals(totals, map_colors, x_coords, y_coords)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://blog.rwhitedwarf.com/post/2023/map_any_region_with_ggplot2_part_III/unnamed-chunk-10-1.png&#34; alt=&#34;plot of chunk unnamed-chunk-10&#34; /&gt;
&lt;/p&gt;
&lt;p&gt;Russia is a very particular case because the country is quite long but not so wide. If we specify coordinates too narrow for latitude, the map does not look good and the labels start getting deformed. It would be the same case with Chile, if we make it narrow in longitude but it is naturally long in latitude. Since the main aim of the functions is to take care of the aesthetics and visualization, we have to ensure that this should not happen, somehow. Having certain degree of the labels is one way to do that. We will see a few more in the future.&lt;/p&gt;
&lt;h2 id=&#34;conclusions&#34;&gt;Conclusions&lt;/h2&gt;
&lt;p&gt;If your aim is only to make maps like the above for any given country, our first 3 posts should have you covered. We could also import our functions to a shiny app and work with that. However, there are many improvements that we can still do.&lt;/p&gt;
&lt;p&gt;Now that we know the basis for functional programming with ggplot2, we can extend the power of our functions in the way how they share arguments by exploring the OOP (Object Oriented Programming) in R, the &lt;code&gt;ggproto&lt;/code&gt; system to extend ggplot, and the use of environments.&lt;/p&gt;
&lt;p&gt;Since we want the maps to be dynamic in time, we could also work on a couple of functions to cover that. It could easily be achieved in a for loop, which is perfectly fine. We could also use the &lt;code&gt;apply&lt;/code&gt; family of functions or the &lt;code&gt;map&lt;/code&gt; family of functions from the &lt;code&gt;purrr&lt;/code&gt; package (not to be confused with geographic maps or the package maps). The last options could be a bit of complication because of the excess of arguments in our functions. That only shows that it is worth it to still improve them.&lt;/p&gt;
&lt;p&gt;The next posts will be focused on this topic, so stay connected if you are interested on how I tackle these challenges.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Webscrap and iteration in R</title>
      <link>https://blog.rwhitedwarf.com/post/webscrap_and_iteration_in_r/</link>
      <pubDate>Fri, 24 Mar 2023 00:00:00 +0000</pubDate>
      
      <guid>https://blog.rwhitedwarf.com/post/webscrap_and_iteration_in_r/</guid>
      <description>&lt;h2 id=&#34;about-this-post&#34;&gt;About this post&lt;/h2&gt;
&lt;p&gt;We are creating maps of data showing changes over a span of time for different countries and pointing at all kinds of cities. That basically means that we need to &lt;strong&gt;map any region of the world with R&lt;/strong&gt;. Today there are all kinds of packages and techniques to do that. I will share the strategy I used with &lt;a href=&#34;https://cran.r-project.org/web/packages/ggplot2/index.html&#34; target=&#34;_blank&#34;&gt;ggplot2&lt;/a&gt; and &lt;a href=&#34;https://cran.r-project.org/web/packages/maps/index.html&#34; target=&#34;_blank&#34;&gt;maps&lt;/a&gt; packages, using support of &lt;a href=&#34;https://www.openstreetmap.org/&#34; target=&#34;_blank&#34;&gt;Open Street Map&lt;/a&gt; to obtain the coordinates of cities and finally making it interactive with &lt;a href=&#34;https://shiny.rstudio.com/&#34; target=&#34;_blank&#34;&gt;shiny&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This series of posts share my path towards the creation of the Shiny app. It is a live project and I decided to share my path and experiences along the creation process. The posts are not only about the Shiny app, but the package I created behind it, including topics of functions crafting, creation of the maps, classes of objects, etc., as well as any interesting issue that appear on the way. It is my way to contribute to the R community and at the same time keeping the project documented for myself.&lt;/p&gt;
&lt;p&gt;You can find all the posts on this series under the tag &lt;a href=&#34;https://blog.rwhitedwarf.com/tags/maps-app/&#34; title=&#34;#maps-app&#34; target=&#34;_blank&#34;&gt;maps-app&lt;/a&gt; (including the Spanish versions).&lt;/p&gt;
&lt;p&gt;You can also find the current state of the project under &lt;a href=&#34;https://github.com/teotenn&#34; target=&#34;_blank&#34;&gt;my GitHub&lt;/a&gt; repo &lt;a href=&#34;https://github.com/teotenn/mapic&#34; target=&#34;_blank&#34;&gt;mapic&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This post is originally written in Spanish, from the Amsterdam airport, on the way to Mexico. I hope you enjoy. Feel free to leave any type of comment and/or question at the end.&lt;/p&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://blog.rwhitedwarf.com/post/2022/map_any_region_with_ggplot2_part_I/maps_DrawingMap.png&#34; alt=&#34;R Maps&#34; /&gt;
&lt;/p&gt;
&lt;h2 id=&#34;motivation&#34;&gt;Motivation&lt;/h2&gt;
&lt;p&gt;As I mentioned in the previous posts in the series, I&amp;rsquo;ve been working lately on the code for creating the maps and I&amp;rsquo;ve made changes that increase the efficiency of the functions, the readability of the code, and make it easier to use. At the same it allows me to extend the functions beyond their original design.&lt;/p&gt;
&lt;p&gt;I have mentioned on a few occasions that the code evolved slowly from scripts created to generate the specific map of some country. So, the first few functions are more of a collection of the steps used to generate the map, wrapped in the form of functions to automate the process.&lt;/p&gt;
&lt;p&gt;For this reason, I wanted to make changes to adapt the functions to paradigms more suitable for functional programming, which is R&amp;rsquo;s strong point. However, back then the priority was to generate the maps, and thus, most of my time was devoted to creating the maps and the debugging of the code when it was necessary. I need to add that this project is part of a voluntary work for an NGO, of which I became the director of the research division, which generated even more responsibilities and work for me. And all as a side job, separated from my main source of income (which is also based on R).&lt;/p&gt;
&lt;p&gt;However, for better or worse, 2022 was a year full of changes and challenges for me and my family, which forced me to put the project aside for a while, resign my position as responsible of the division, and focus solely on to my career, my health and my family. The result was that when I managed to regaining stability in my life, I found myself with more free time and fewer obligations to rethink the code and work on it. Additionally, my main job had a turn going from statistics to more programming oriented in R, which has given me more tools and experience to improve the code, and has motivated me to take up old lessons about functional programming and, above all, iteration.&lt;/p&gt;
&lt;p&gt;This allowed me to improve the two main functions: the one in charge of the webscrapping and the one that sends the data to SQLite. You can find the original functions in the previous post, &lt;a href=&#34;https://blog.rwhitedwarf.com/post/map_any_region_with_ggplot2_part_i/&#34; target=&#34;_blank&#34;&gt;Map any region in the world with R - Part I: The basic map&lt;/a&gt; and compare it with the new, improved functions in this.&lt;/p&gt;
&lt;h2 id=&#34;webscrapp-to-sqlite&#34;&gt;Webscrapp to SQLite&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;webscrap_to_sqlite&lt;/code&gt; function is responsible for sending the coordinates found by Open Street Map to our database. The original function is inefficient, as it does each operation line by line. It is also very rigid in the way it directs the values of the regions, both its request to the API and the placement of the values in the database, which makes any extension or modification very complicated.&lt;/p&gt;
&lt;p&gt;For these reasons, it is the function that received the most changes, it was practically rewritten from scratch, making the search more efficient, also allowing internal search of the data already stored; more flexible, dealing with region parameters more clearly; and more understandable, improving the style of the code.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;webscrap_to_sqlite &amp;lt;- function(db.name,
                               dat,
                               city = &amp;quot;City&amp;quot;,
                               country = &amp;quot;Country&amp;quot;,
                               region = NULL,
                               state = NULL,
                               county = NULL,
                               db_backup_after = 10) {
  ## Loading libraries
  require(RSQLite)
  require(dplyr)

  ## 1. DB connection
  con &amp;lt;- dbConnect(drv = SQLite(), dbname = db.name)
  dbExecute(conn = con,
            &amp;quot;CREATE TABLE IF NOT EXISTS orgs
                    (ID INTEGER UNIQUE,
                     City TEXT,
                     Country TEXT, 
                     Region TEXT,
                     State TEXT,
                     County TEXT,
                     osm_name TEXT,
                     lon REAL,
                     lat REAL)&amp;quot;)
  db &amp;lt;- as_tibble(dbReadTable(con, &amp;quot;orgs&amp;quot;))

  ## 2. Data filtering
  new_coords &amp;lt;- data.frame()
  dat_local &amp;lt;- compare_db_data(db.name, dat)
  df_len &amp;lt;- nrow(dat_local)

  ## 3. While there are rows in DF:
  if (df_len != 0) {
    ## 3.1 Define subsample size
    dat_local &amp;lt;- dat_local[c(1:db_backup_after), ]
    dat_local &amp;lt;- filter(dat_local, rowSums(is.na(dat_local)) != ncol(dat_local))

    ## 3.2 for loop for the webscrapping
    for (i in 1:nrow(dat_local)) {
      print(paste0(&amp;quot;Searching entry &amp;quot;, dat_local[[&amp;quot;ID&amp;quot;]][i]))
      
      ## 3.3 Info abstraction
      rg &amp;lt;- ifelse(is.null(region), &amp;quot;&amp;quot;, dat_local[[region]][i])
      st &amp;lt;- ifelse(is.null(state), &amp;quot;&amp;quot;, dat_local[[state]][i])
      ct &amp;lt;- ifelse(is.null(county), &amp;quot;&amp;quot;, dat_local[[county]][i])
      rcity &amp;lt;- dat_local[[city]][i]
      rcountry &amp;lt;- dat_local[[country]][i]

      ## 3.4 Getting the coords
      ## 3.4.1. First, check if they are already in the DB
      search_query &amp;lt;- filter(db, City == rcity, Country == rcountry,
                             Region == rg, State == st, County == ct)
      if (nrow(search_query != 0)) {
        coords &amp;lt;- search_query[1, ]
        coords$ID &amp;lt;- dat_local[[&amp;quot;ID&amp;quot;]][i]
        print(&amp;quot;Found from memory&amp;quot;)
        
        ## 3.4.2 If they are not, search with OSM API
      } else {
        coords &amp;lt;- coords_from_city(rcity, rcountry,
                                   Region = rg, State = st, County = ct)
        coords &amp;lt;- cbind(ID = dat_local[[&amp;quot;ID&amp;quot;]][i],
                        City = rcity,
                        Country = rcountry,
                        Region = rg,
                        State = st,
                        County = ct,
                        coords)
      }
      new_coords &amp;lt;- rbind(new_coords, coords)
    }

    ## Send only new results to DB
    dbWriteTable(con, &amp;quot;orgs&amp;quot;, new_coords, append = TRUE)
    dbDisconnect(con)

    ## 3.4.3 Repeat
    webscrap_to_sqlite(db.name = db.name,
                       dat = dat,
                       city = city,
                       country = country,
                       region = region,
                       state = state,
                       county = county,
                       db_backup_after = db_backup_after)

    ## 4. Exit iteration
  } else {
    db_final &amp;lt;- import_db_as_df(db.name)
    size &amp;lt;- nrow(db_final)
    not_found &amp;lt;- nrow(db_final[is.na(db_final$lat), ])
    message(paste(&amp;quot;Search finished.\n&amp;quot;,
                  size, &amp;quot;entries searched.\n&amp;quot;,
                  not_found, &amp;quot;ENTRIES NOT FOUND&amp;quot;))
  }
}        
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The function starts by calling the necessary libraries and (1) connecting to the database, creating it if necessary. (2) Then it generates two data frames, an empty one that will store new coordinates and a relative one that contains only the data that does not yet exist in the database. (3) So, as long as there is data in this last data frame, the function will continue to loop.&lt;/p&gt;
&lt;p&gt;(3.1) We then define the subsample, which is a subset of &lt;code&gt;dat_local&lt;/code&gt; the size of &lt;code&gt;db_backup_after&lt;/code&gt; and focus solely on this subsample. (3.2) On this subsample we make the iterations using &lt;code&gt;for&lt;/code&gt; to obtain the coordinates. First (3.3) we prepare the data as strings and then (3.4) we look up the coordinates. (3.4.1) If they already exist in the database we take it from there, and if not (3.4.2) they are searched using &lt;code&gt;coords_from_city&lt;/code&gt;. Finally, (3.4.3) we iterate all over again, allowing the function to call itself.&lt;/p&gt;
&lt;p&gt;Since step 2 filters the data that is not yet in the database and step 3 places the results of new searches in an empty data frame, the function calls itself and applies only for each subset of data. When &lt;code&gt;compare_db_data&lt;/code&gt; finally returns 0 values because all the data that was fed into the function is already contained in the database, we can exit the function. In this case I decided to import the data again from SQLite to get details of the search, and end the iteration by sending a message to the user about the total number of entries and the number of which were not found.&lt;/p&gt;
&lt;p&gt;If we compare this function with the one proposed in my previous post, the function is completely different but the end result is the same. The arguments used by the function are also the same and take the same values, which avoids conflicts for the user. The only new parameter is &lt;code&gt;db_backup_after&lt;/code&gt; which allows us to control how many rows the iteration is done. A smaller value means more iterations, which results in higher local memory usage, but also faster in finding data that already exists in the DB. On the other hand, a higher value reduces the number of iterations but increases the number of API connections. For this reason I have given it a default value of 10. This, in addition to being a balanced value, also reduces confusion for the user who might not be familiar with the changes.&lt;/p&gt;
&lt;h2 id=&#34;remove-missing-values-from-the-database&#34;&gt;Remove missing values from the database&lt;/h2&gt;
&lt;p&gt;In the previous proposal, only found coordinates were sent to the database, and those not found were ignored. In the present proposal, all entries are sent to the DB. Therefore, it is important to have some option to remove the missing entries.&lt;/p&gt;
&lt;p&gt;For this I generated the function &lt;code&gt;remove_na_from_db&lt;/code&gt;, a very simple function which gives the user the possibility of removing &lt;code&gt;NA&lt;/code&gt;s automatically.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;remove_na_from_db &amp;lt;- function(db.file) {
  require(RSQLite)
  con &amp;lt;- dbConnect(drv = RSQLite::SQLite(), dbname = db.file)
  dbExecute(conn = con,
            &amp;quot;DELETE FROM orgs WHERE lon IS NULL OR trim(lon) = &#39;&#39;;&amp;quot;)
  dbDisconnect(con)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The function is just a connection to the database that issues the command to remove rows where the &lt;code&gt;lon&lt;/code&gt; field is empty, in SQLite syntax. This is the safest, most direct and fastest way to do it. We could also import the data back into R, filter it, and send it back to SQLite, but this would require more local memory usage, more code, and more risk as it would require rewriting the database to SQLite entirely. . The power of the &lt;code&gt;RSQLite&lt;/code&gt; library (or any other library that connects R to SQL) lies precisely in the ability to pass commands written and executed directly in SQL.&lt;/p&gt;
&lt;h2 id=&#34;obtaining-the-coordinates&#34;&gt;Obtaining the coordinates&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;coords_from_city&lt;/code&gt; function also received significant changes in code readability and flexibility, and a bit less in functionality and efficiency.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;coords_from_city &amp;lt;- function(city = NULL,
                             country_code,
                             region = NULL,
                             state = NULL,
                             county = NULL) {
  require(&amp;quot;RJSONIO&amp;quot;)

  ## 1. Abstract regions for OSM
  CityCoded &amp;lt;- gsub(&amp;quot; &amp;quot;, &amp;quot;%20&amp;quot;, City) 
  CountryCoded &amp;lt;- paste(&amp;quot;&amp;amp;countrycodes=&amp;quot;, CountryTwoLetter, sep = &amp;quot;&amp;quot;)
  extras &amp;lt;- c(city = City, state = State, region = Region, county = County)
  extrasCoded &amp;lt;- &amp;quot;&amp;quot;
  if (!is.null(extras)) {
    for (i in 1:length(extras)) {
      if (extras[i] != &amp;quot;&amp;quot; &amp;amp;&amp;amp; !is.na(extras[i]) &amp;amp;&amp;amp; !grepl(&amp;quot;^\\s*$&amp;quot;, extras[i])) {
        valCoded &amp;lt;- gsub(&amp;quot; &amp;quot;, &amp;quot;%20&amp;quot;, extras[i])
        extrasCoded &amp;lt;- paste0(extrasCoded, &amp;quot;&amp;amp;&amp;quot;, names(extras)[i], &amp;quot;=&amp;quot;, valCoded)
      }
    }
  }

  ## 2. Response
  link &amp;lt;- paste(
    &amp;quot;http://nominatim.openstreetmap.org/search?city=&amp;quot;
  , extrasCoded
  , CountryCoded
  , &amp;quot;&amp;amp;format=json&amp;quot;
  , sep = &amp;quot;&amp;quot;
  )

  response &amp;lt;- try({fromJSON(link)},
                  silent = TRUE)

  if (class(response) == &amp;quot;try-error&amp;quot;) {
    stop(response[1])
  } else if (class(response) == &amp;quot;response&amp;quot;) {
    response_status &amp;lt;- http_status(response)
    if (response_status$category != &amp;quot;Success&amp;quot;) {
      stop(response_status$message)
    }
  } else if (is.list(response)) {

    ## 3. Organize results
    if (length(response) == 0) {
      message(paste(&amp;quot;No results found for&amp;quot;, extrasCoded))
      coords &amp;lt;- data.frame(&amp;quot;lon&amp;quot; = NA, &amp;quot;lat&amp;quot; = NA, &amp;quot;osm_name&amp;quot; = as.character(NA))
      
    } else if (length(response) == 1) {
      message(paste(&amp;quot;Found&amp;quot;, response[[1]]$display_name))
      coords &amp;lt;- data.frame(
        lon = response[[1]]$lon,
        lat = response[[1]]$lat,
        osm_name = response[[1]]$display_name
      )
      
    } else {
      message(paste(&amp;quot;Several entries found for&amp;quot;, city, country_code))
      coords &amp;lt;- data.frame(
        lon = response[[1]]$lon,
        lat = response[[1]]$lat,
        osm_name = response[[1]]$display_name
      )
    }
  }
    
  ## 4. Exit as data frame
  return(coords)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The main change is in section 1, instead of passing each of the regions as its own string and formatting them one by one, I have abstracted them all into a single vector. This reduces the amount of code, memory usage, and allows us to include the city in the list, making it an optional value as well. The reason I had prepared them separately in the previous post is simply because the feature grew slowly: at first we only needed city, but then we had to use some additional fields depending on the country we were working in. To make things easier for me, I simply added each region field as needed. Now that I have time to work on the code, this was the first function I modified.&lt;/p&gt;
&lt;p&gt;Step 2 now prints messages that help us identify the error when it comes to the connection, while also stopping the process. Whether it is a local connection error, or problems on the API side, we will get a message and the process will stop, which should avoid long waiting times when there is no connection and several locations are being searched.&lt;/p&gt;
&lt;p&gt;Step 3 changes the organization of the results a bit, always returning a data frame with the same columns when the results were not found, but now with empty fields in such case. This helps the functions presented above to populate the database. Additionally, when many results were found, this information is printed on the screen; for now this is for information purposes only. The idea is to keep this space to make changes in the future that allow us to select the option interactively. This is something I still need to think about and plan properly because on one hand I want to use it in a Shiny app, and on the other we want to keep the ability for web scrapping to happen automatically with as little intervention as possible.&lt;/p&gt;
&lt;p&gt;As I mentioned before, these new features also allow us to perform searches with the empty city value. This was a requested requirement in the last version, as some users started making maps by region, while others, not finding very small cities, decided to group the data by region. Thanks to the changes made to &lt;code&gt;coords_from_city&lt;/code&gt;, the &lt;code&gt;webscrap_to_sqlite&lt;/code&gt; function can now return results when the value for city is &lt;code&gt;NA&lt;/code&gt;, assuming that the coordinates for the region or state are found. Here it is important to mention that it is recommended to use the &lt;code&gt;state&lt;/code&gt; argument for region search, for some reason this works better in the OSM API. As an example, the search &lt;code&gt;coords_from_city(state = &amp;quot;Castilla La Mancha&amp;quot;, country_code = &amp;quot;ES&amp;quot;)&lt;/code&gt; returns the expected results, despite of the fact that Spain has no states; however if we do &lt;code&gt;coords_from_city(region = &amp;quot;Castilla La Mancha&amp;quot;, country_code = &amp;quot;ES&amp;quot;)&lt;/code&gt; nominatim does not find the results.&lt;/p&gt;
&lt;h2 id=&#34;conclusions&#34;&gt;Conclusions&lt;/h2&gt;
&lt;p&gt;These changes have been very important in speeding up the coordinate search process and automating map creation. On the other hand, it allowed me to style the code more and improve its efficiency. Since my main project for now is turning it into a Shiny app, it was important for me to improve the code and the efficiency before dealing with the details of the server. Since this is recent work that I have been doing in the last few months, I decided to share it right away now that I have fresh information on the changes. I hope it can help more than one to make more abstract code and practice recursion.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Map any region in the world with R - Part II: Obtaining the coordinates</title>
      <link>https://blog.rwhitedwarf.com/post/map_any_region_with_ggplot2_part_ii/</link>
      <pubDate>Fri, 04 Nov 2022 00:00:00 +0000</pubDate>
      
      <guid>https://blog.rwhitedwarf.com/post/map_any_region_with_ggplot2_part_ii/</guid>
      <description>&lt;p&gt;You can find all the posts on this series under the tag &lt;a href=&#34;https://blog.rwhitedwarf.com/tags/maps-app/&#34; title=&#34;#maps-app&#34; target=&#34;_blank&#34;&gt;maps-app&lt;/a&gt; (including the Spanish versions).&lt;/p&gt;
&lt;p&gt;You can also find the current state of the project under &lt;a href=&#34;https://github.com/teotenn&#34; target=&#34;_blank&#34;&gt;my GitHub&lt;/a&gt; repo &lt;a href=&#34;https://github.com/teotenn/mapic&#34; target=&#34;_blank&#34;&gt;mapic&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;scope-of-this-post&#34;&gt;Scope of this post&lt;/h2&gt;
&lt;p&gt;This is the second part of the series to create a map of any region of the world with R.&lt;/p&gt;
&lt;p&gt;We are creating maps of data showing changes over a span of time for different countries and pointing at all kinds of cities. That basically means that we need to &lt;strong&gt;map any region of the world with R&lt;/strong&gt;. Today there are all kinds of packages and techniques to do that. I will share the strategy I used with &lt;a href=&#34;https://cran.r-project.org/web/packages/ggplot2/index.html&#34; target=&#34;_blank&#34;&gt;ggplot2&lt;/a&gt; and &lt;a href=&#34;https://cran.r-project.org/web/packages/maps/index.html&#34; target=&#34;_blank&#34;&gt;maps&lt;/a&gt; packages, using support of &lt;a href=&#34;https://www.openstreetmap.org/&#34; target=&#34;_blank&#34;&gt;Open Street Map&lt;/a&gt; to obtain the coordinates of cities and finally making it interactive with &lt;a href=&#34;https://shiny.rstudio.com/&#34; target=&#34;_blank&#34;&gt;shiny&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This series of posts share my path towards the creation of the Shiny app. It is a live project and I decided to share my path and experiences along the creation process. The posts are not only about the Shiny app, but the package I created behind it, including topics of functions crafting, creation of the maps, classes of objects, etc., as well as any interesting issue that appear on the way. It is my way to contribute to the R community and at the same time keeping the project documented for myself.&lt;/p&gt;
&lt;p&gt;This post is about &lt;strong&gt;Web scrapping with nominatim open street maps&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;I hope you all enjoy it. Feel free to leave any kind of comment and/or question at the end.&lt;/p&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://blog.rwhitedwarf.com/post/2022/map_any_region_with_ggplot2_part_I/maps_DrawingMap.png&#34; alt=&#34;R Maps&#34; /&gt;
&lt;/p&gt;
&lt;h2 id=&#34;open-street-maps-and-nominatim&#34;&gt;Open Street Maps and Nominatim&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;A simple query&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(&#39;RJSONIO&#39;)

site &amp;lt;- (&amp;quot;http://nominatim.openstreetmap.org/search?city=Texcoco&amp;amp;limit=9&amp;amp;format=json&amp;quot;)
(result &amp;lt;- fromJSON(site))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; [[1]]
&amp;gt; [[1]]$place_id
&amp;gt; [1] 1177116
&amp;gt; 
&amp;gt; [[1]]$licence
&amp;gt; [1] &amp;quot;Data © OpenStreetMap contributors, ODbL 1.0. https://osm.org/copyright&amp;quot;
&amp;gt; 
&amp;gt; [[1]]$osm_type
&amp;gt; [1] &amp;quot;node&amp;quot;
&amp;gt; 
&amp;gt; [[1]]$osm_id
&amp;gt; [1] 336169214
&amp;gt; 
&amp;gt; [[1]]$boundingbox
&amp;gt; [1] &amp;quot;29.619&amp;quot;       &amp;quot;29.659&amp;quot;       &amp;quot;-111.0786667&amp;quot; &amp;quot;-111.0386667&amp;quot;
&amp;gt; 
&amp;gt; [[1]]$lat
&amp;gt; [1] &amp;quot;29.639&amp;quot;
&amp;gt; 
&amp;gt; [[1]]$lon
&amp;gt; [1] &amp;quot;-111.0586667&amp;quot;
&amp;gt; 
&amp;gt; [[1]]$display_name
&amp;gt; [1] &amp;quot;Texcoco, Carbó, Sonora, México&amp;quot;
&amp;gt; 
&amp;gt; [[1]]$class
&amp;gt; [1] &amp;quot;place&amp;quot;
&amp;gt; 
&amp;gt; [[1]]$type
&amp;gt; [1] &amp;quot;village&amp;quot;
&amp;gt; 
&amp;gt; [[1]]$importance
&amp;gt; [1] 0.385
&amp;gt; 
&amp;gt; [[1]]$icon
&amp;gt; [1] &amp;quot;https://nominatim.openstreetmap.org/ui/mapicons/poi_place_village.p.20.png&amp;quot;
&amp;gt; 
&amp;gt; 
&amp;gt; [[2]]
&amp;gt; [[2]]$place_id
&amp;gt; [1] 3448536
&amp;gt; 
&amp;gt; [[2]]$licence
&amp;gt; [1] &amp;quot;Data © OpenStreetMap contributors, ODbL 1.0. https://osm.org/copyright&amp;quot;
&amp;gt; 
&amp;gt; [[2]]$osm_type
&amp;gt; [1] &amp;quot;node&amp;quot;
&amp;gt; 
&amp;gt; [[2]]$osm_id
&amp;gt; [1] 458633446
&amp;gt; 
&amp;gt; [[2]]$boundingbox
&amp;gt; [1] &amp;quot;16.551667&amp;quot;  &amp;quot;16.591667&amp;quot;  &amp;quot;-97.053333&amp;quot; &amp;quot;-97.013333&amp;quot;
&amp;gt; 
&amp;gt; [[2]]$lat
&amp;gt; [1] &amp;quot;16.571667&amp;quot;
&amp;gt; 
&amp;gt; [[2]]$lon
&amp;gt; [1] &amp;quot;-97.033333&amp;quot;
&amp;gt; 
&amp;gt; [[2]]$display_name
&amp;gt; [1] &amp;quot;Texcoco, Santa María Sola, Oaxaca, México&amp;quot;
&amp;gt; 
&amp;gt; [[2]]$class
&amp;gt; [1] &amp;quot;place&amp;quot;
&amp;gt; 
&amp;gt; [[2]]$type
&amp;gt; [1] &amp;quot;hamlet&amp;quot;
&amp;gt; 
&amp;gt; [[2]]$importance
&amp;gt; [1] 0.36
&amp;gt; 
&amp;gt; [[2]]$icon
&amp;gt; [1] &amp;quot;https://nominatim.openstreetmap.org/ui/mapicons/poi_place_village.p.20.png&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;We start with &lt;a href=&#34;https://www.openstreetmap.org/&#34; target=&#34;_blank&#34;&gt;Open Street Map&lt;/a&gt; and its API &lt;a href=&#34;https://nominatim.openstreetmap.org/ui/about.html&#34; target=&#34;_blank&#34;&gt;nominatim&lt;/a&gt;. In the piece of code above we can see how to perform a simple query for one city. It is basically one long string containing first the url of nominatim and at the end the search details: here we start the search with city using &lt;code&gt;?city=Texcoco&lt;/code&gt;, in this case I aimed for a city with only a few results. Next we are limiting the amount of results to 9 with &lt;code&gt;&amp;amp;limit=9&lt;/code&gt; and finally requesting the results in format JSON.&lt;/p&gt;
&lt;p&gt;We could basically copy the string that we are passing to &lt;code&gt;site&lt;/code&gt; and paste it in the web browser to see the results directly there. Feel free to change the city &lt;code&gt;Texcoco&lt;/code&gt; to any other city, and play a bit more with the rest of the parameters. Particularly have a look at what happens when you remove the &lt;code&gt;&amp;amp;format=json&lt;/code&gt; part or when you exchange &lt;code&gt;json&lt;/code&gt; for any other abstract string like &lt;code&gt;csv&lt;/code&gt; or other non-recognized format.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A more specific query&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;city &amp;lt;- &#39;San%20Francisco&#39;
state &amp;lt;- &#39;&amp;amp;state=California&#39;
country &amp;lt;- &#39;&amp;amp;countrycodes=US&#39;
start.nominatim &amp;lt;- &amp;quot;http://nominatim.openstreetmap.org/search?city=&amp;quot;
end.nominatim &amp;lt;- &amp;quot;&amp;amp;format=json&amp;quot;

site &amp;lt;- paste0(start.nominatim, city, country, state, end.nominatim)
(result &amp;lt;- fromJSON(site))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; [[1]]
&amp;gt; [[1]]$place_id
&amp;gt; [1] 297054975
&amp;gt; 
&amp;gt; [[1]]$licence
&amp;gt; [1] &amp;quot;Data © OpenStreetMap contributors, ODbL 1.0. https://osm.org/copyright&amp;quot;
&amp;gt; 
&amp;gt; [[1]]$osm_type
&amp;gt; [1] &amp;quot;relation&amp;quot;
&amp;gt; 
&amp;gt; [[1]]$osm_id
&amp;gt; [1] 111968
&amp;gt; 
&amp;gt; [[1]]$boundingbox
&amp;gt; [1] &amp;quot;37.6403143&amp;quot;  &amp;quot;37.929811&amp;quot;   &amp;quot;-123.173825&amp;quot; &amp;quot;-122.281479&amp;quot;
&amp;gt; 
&amp;gt; [[1]]$lat
&amp;gt; [1] &amp;quot;37.7790262&amp;quot;
&amp;gt; 
&amp;gt; [[1]]$lon
&amp;gt; [1] &amp;quot;-122.419906&amp;quot;
&amp;gt; 
&amp;gt; [[1]]$display_name
&amp;gt; [1] &amp;quot;San Francisco, CAL Fire Northern Region, California, United States&amp;quot;
&amp;gt; 
&amp;gt; [[1]]$class
&amp;gt; [1] &amp;quot;boundary&amp;quot;
&amp;gt; 
&amp;gt; [[1]]$type
&amp;gt; [1] &amp;quot;administrative&amp;quot;
&amp;gt; 
&amp;gt; [[1]]$importance
&amp;gt; [1] 1.035131
&amp;gt; 
&amp;gt; [[1]]$icon
&amp;gt; [1] &amp;quot;https://nominatim.openstreetmap.org/ui/mapicons/poi_boundary_administrative.p.20.png&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;If you explore OSM and nominatim a bit you will see that we can add search arguments using &lt;code&gt;&amp;amp;&lt;/code&gt; followed by the argument we want (i.e., &lt;code&gt;state&lt;/code&gt;), the symbol equal &lt;code&gt;=&lt;/code&gt; and the argument. In my example above you can see how we are specifying the State and Country of our query. Additionally it is important to know how to pass spaces in a name, for example, San Francisco will be passed as &lt;code&gt;San%20Francisco&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;With this basic information in mind and knowing that the package &lt;code&gt;RJSONIO&lt;/code&gt; helps us to retrieve the data from the JSON api into an R-friendly format, we can easily prepare a function to search for any city quickly, provided a few extra details like a region, state or county, and especially important, the country (try searching for cities like London or Prague without providing a country, you might be surprised of how many cities exist in the world with such names).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;coords_from_city &amp;lt;- function(City,
                             CountryTwoLetter,
                             Region = NULL,
                             State = NULL,
                             County = NULL){
    require(&#39;RJSONIO&#39;)
    CityCoded &amp;lt;- gsub(&#39; &#39;,&#39;%20&#39;,City) #remove space for URLs
    CountryCoded &amp;lt;- paste(&amp;quot;&amp;amp;countrycodes=&amp;quot;, CountryTwoLetter, sep = &#39;&#39;)
    extras &amp;lt;- c(state = State, region = Region, county = County)
    extrasCoded &amp;lt;- &#39;&#39;
    if(!is.null(extras)) {
        for(i in 1:length(extras)){
            if(extras[i] != &#39;&#39; &amp;amp;&amp;amp; !is.na(extras[i]) &amp;amp;&amp;amp; !grepl(&amp;quot;^\\s*$&amp;quot;, extras[i])){
                valCoded &amp;lt;- gsub(&#39; &#39;, &#39;%20&#39;, extras[i])
                extrasCoded &amp;lt;- paste0(extrasCoded, &#39;&amp;amp;&#39;, names(extras)[i], &#39;=&#39;, valCoded)
            }
        }
    }
    ## get data
    url &amp;lt;- paste(
        &amp;quot;http://nominatim.openstreetmap.org/search?city=&amp;quot;
      , CityCoded
      , CountryCoded
      , extrasCoded
      , &amp;quot;&amp;amp;format=json&amp;quot;
      , sep=&amp;quot;&amp;quot;)
    x &amp;lt;- fromJSON(url)
    ## retrieve coords
    if(is.vector(x)){
            message(paste(&#39;Found&#39;, x[[1]]$display_name))
            lon &amp;lt;- x[[1]]$lon
            lat &amp;lt;- x[[1]]$lat
            osm_name &amp;lt;- x[[1]]$display_name
            coords &amp;lt;- data.frame(&#39;lon&#39; = lon, &#39;lat&#39; = lat, &#39;osm_name&#39; = osm_name)
    }
    ## When x is not a vector
    else{
        message(paste(&#39;No results found for&#39;, City, CountryTwoLetter))
        coords &amp;lt;- data.frame(&#39;lon&#39; = NA, &#39;lat&#39; = NA)
    }
    ## return a df
    coords
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;An important detail to know is that often, providing values to either &lt;code&gt;state&lt;/code&gt; or &lt;code&gt;region&lt;/code&gt; parameters returns similar results, this is particularly useful in countries where no states are used or other forms of organization are present. However, when the country has &amp;ldquo;States&amp;rdquo;, you cannot pass the name of a State to the parameter &lt;code&gt;Region&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The function returns a data frame that we will use later to create a table with all of our results. Since we are interested in creating maps, we only need the coordinates expressed in latitude and longitude parameters. In case the query is not found, it fills the values with &lt;code&gt;NA&lt;/code&gt;&amp;rsquo;s, which later we&amp;rsquo;ll use to keep track of what was found and what wasn&amp;rsquo;t. We are also keeping the values inside &lt;code&gt;osm_name&lt;/code&gt; which provides enough information to tell the user useful details regarding the search results, including the country of the city found, and other details like state or region.&lt;/p&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://blog.rwhitedwarf.com/post/2022/map_any_region_with_ggplot2_part_II/maps_coords_from_city.png&#34; alt=&#34;Function coords_from_city() in detail&#34; /&gt;
&lt;/p&gt;
&lt;p&gt;An important point to consider in &lt;code&gt;coords_from_city&lt;/code&gt; is that it will return only the top result from the query. It means that the more information you provide, the more accurate your result will be. For our project it worked well because for big countries we were always collecting enough info about regions and states, while for smaller countries often the options were too small. But if you use the function it is important to know that if you provide a city name like &lt;code&gt;Springfield&lt;/code&gt;, &lt;code&gt;Country = &#39;US&#39;&lt;/code&gt; and give no info about State and County, the function will retrieve only the top result from the search and discard the remaining options.&lt;/p&gt;
&lt;h2 id=&#34;keeping-the-info-in-a-database&#34;&gt;Keeping the info in a database&lt;/h2&gt;
&lt;p&gt;The function &lt;code&gt;coords_from_city&lt;/code&gt; could be enough if we need to retrieve info about a few cities; we could make a for loop, retrieve all the coords we need and sore them in a data frame to later save as csv, &lt;code&gt;Rdata&lt;/code&gt; or any format we choose. The same is true when we are searching for hundreds or thousands of cities but with data increasing the searching time also increases. If, for any reason, the R session breaks, the information would be lost and we will have to start all over again from row 1. Therefore, we are going to send every single result to a database. In that way, no matter when we stop the process or how this happens, the data is safely stored outside of R.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;webscrap_to_sqlite &amp;lt;- function(db.name,
                               dat,
                               col.city = &#39;City&#39;,
                               col.country = &#39;Country&#39;,
                               region = NULL,
                               state = NULL,
                               county = NULL)
{
    require(RSQLite)
    df_len &amp;lt;- nrow(dat)
    ## Connect to db and table
    con &amp;lt;- dbConnect(drv=SQLite(), dbname=db.name)
    dbExecute(conn = con,
                &amp;quot;CREATE TABLE IF NOT EXISTS orgs
                    (ID INTEGER UNIQUE,
                     City TEXT, osm_name TEXT,
                     lon REAL,lat REAL)&amp;quot;)
    ## -- Iteration to web-scrap data -- ##
    ccount &amp;lt;- 0
    ## For loop to webscrapping
    for(i in 1:df_len){
        rg &amp;lt;- ifelse(is.null(region), &#39;&#39;, dat[[region]][i])
        st &amp;lt;- ifelse(is.null(state), &#39;&#39;, dat[[state]][i])
        ct &amp;lt;- ifelse(is.null(county), &#39;&#39;, dat[[county]][i])
        print(paste(&#39;Entry&#39;, i))
        ## Do the webscrap
        coords &amp;lt;- coords_from_city(dat[[col.city]][i],
                                   dat[[col.country]][i],
                                   Region = rg, State = st, County = ct)
        ## DB send query ONLY if coords were found
        if(is.na(coords$lon[1])){
            ccount &amp;lt;- ccount + 1
        }
        else{
            sq &amp;lt;- dbExecute(con, &#39;INSERT OR IGNORE INTO orgs
                             (ID, City, osm_name, lon, lat)
                             VALUES (?, ?, ?, ?, ?);&#39;,
                        list(dat[[&#39;ID&#39;]][i], dat[[col.city]][i],
                             coords$osm_name, coords$lon[1], coords$lat[1]))
        }
        print(paste(&#39;Completed&#39;, (i/df_len)*100, &#39;%&#39;))
    }
    ## Close db
    dbDisconnect(con)
    message(paste(&amp;quot;WEB SCRAP FOR COORDINATES SEARCH FINISHED.&amp;quot;,
                ccount, &amp;quot;ENTRIES NOT FOUND&amp;quot;))
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For storing the data I have chosen to use &lt;a href=&#34;https://www.sqlite.org/index.html&#34; target=&#34;_blank&#34;&gt;SQLite&lt;/a&gt; through the R package &lt;a href=&#34;https://rsqlite.r-dbi.org/&#34; target=&#34;_blank&#34;&gt;RSQLite&lt;/a&gt;. If you are not familiar with SQL databases I recommend you to start with a general google search and then come back to the documentation of SQLite and the R package. I chose SQLite because we needed to have something light and portable that would allow us to move the information easily from country to country rather than a centralized database where we could store everything, but a very similar approach can be applied using other types of SQL databases.&lt;/p&gt;
&lt;p&gt;The function &lt;code&gt;dbConnect()&lt;/code&gt; generates the SQLite file if it does not exist yet. Then we give SQLite the order to create the table &lt;code&gt;orgs&lt;/code&gt; if doesn&amp;rsquo;t exist yet, and the structure for such table. Next we search for the coordinates of the entries one by one using &lt;code&gt;coords_from_city()&lt;/code&gt; and finally we send it to the database. In that way we could stop the process at any time and continue later by simply retrieving the table &lt;code&gt;orgs&lt;/code&gt; from the database, compare it with our original data and move forward from what is missing. For that, the column &lt;code&gt;ID&lt;/code&gt; is critical, it is the column that allows us to link an entry between the original data, the R data.frame and the SQL table.&lt;/p&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://blog.rwhitedwarf.com/post/2022/map_any_region_with_ggplot2_part_II/maps_webscrap_to_sqlite.png&#34; alt=&#34;Function webscrap_to_sqlite() in detail&#34; /&gt;
&lt;/p&gt;
&lt;p&gt;Our function also has a variable &lt;code&gt;ccount&lt;/code&gt; that counts each time an entry was not found. In that way, once the query is finished it will print the amount of entries that were not found. The reasons for not finding an entry can be many, among the most common ones that I encountered are the following:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Wrong spelling of the City name or excess of info (i.e., value &amp;ldquo;Prague, District 3&amp;rdquo; when the city name is simply &amp;ldquo;Prague&amp;rdquo;).&lt;/li&gt;
&lt;li&gt;Wrong spelling of the State, Region and/or County name.&lt;/li&gt;
&lt;li&gt;The given City is simply not in the database of Open Street Maps (it happened specially for very small villages).&lt;/li&gt;
&lt;li&gt;Breaks of the internet connection. This one is particularly important because sometimes running the query a second or third time would find cities that were not found the first time.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To read the data back to R from SQL we simply need to make a connection to the database, read the table, and close the connection. The function &lt;code&gt;combine_df_sql&lt;/code&gt; takes care of that and at the same time joins our original data to the data stored in the database by the ID and the city name. This was important for the project because we wanted to keep the coordinates of the cities separated from the rest of the information due to some internal practical reasons. But I think that keeping all the data in SQL at once can facilitate many things. Among others, you could identify when a particular city was already found in the past and retrieve the coordinates from the database directly rather than making a connection to nominatim. I did that for a few countries and it reduces the querying time considerably. For the present post I decided to show the separated version of data in order to provide more tools to the reader.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;combine_df_sql &amp;lt;- function(db.file, original.data){
    require(dplyr)
    require(RSQLite)
    if(is.character(original.data)){
        if(grepl(&#39;.csv&#39;, original.data, fixed = T)){
            df &amp;lt;- read.csv(original.data)
        }
        else{
            stop(&amp;quot;Incorrect file format for data&amp;quot;)
        }
    }
    else if(is.data.frame(original.data)){
        df &amp;lt;- original.data
    }
    else{
        stop(&amp;quot;Incorrect data format&amp;quot;)
    }
    con &amp;lt;- dbConnect(drv=RSQLite::SQLite(), dbname = db.file)
    db &amp;lt;- dbReadTable(con, &amp;quot;orgs&amp;quot;)
    dbDisconnect(con)
    result &amp;lt;- left_join(df, db, by = c(&#39;ID&#39;, &#39;City&#39;))
    return(result)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Another detail of our function is the ability to read either from the &lt;code&gt;csv&lt;/code&gt; file or from a &lt;code&gt;data.frame&lt;/code&gt;. Since we were working mainly with csv files and I used data frames for the unit tests, these 2 formats were enough. Feel free to modify or extend the function for the data formats that you might need.&lt;/p&gt;
&lt;h2 id=&#34;missing-data&#34;&gt;Missing data&lt;/h2&gt;
&lt;p&gt;As mentioned above, sometimes the results from the query would be incomplete and a second or third run were necessary but with a fewer rows. Some others I just needed to stop the query and continue later from where we left. And yet some other times the data was incomplete or wrong and this could be solved later with the data owner. The 3 scenarios required me to read the csv file to R, then the table from the database and compare them to filter the missing values. So I crafted the function &lt;code&gt;compare_db_data&lt;/code&gt; to compare the database (db) to the original data.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;compare_db_data &amp;lt;- function(db.file, dat){
    require(dplyr)
    require(RSQLite)
    if(is.character(dat)){
        if(grepl(&#39;.csv&#39;, dat, fixed = T)){
            df &amp;lt;- read.csv(dat)
        }
        else{
            stop(&amp;quot;Incorrect file format for data&amp;quot;)
        }
    }
    else if(is.data.frame(dat)){
        df &amp;lt;- dat
    }
    else{
        stop(&amp;quot;Incorrect data format&amp;quot;)
    }
    con &amp;lt;- dbConnect(drv=RSQLite::SQLite(), dbname = db.file)
    db &amp;lt;- dbReadTable(con, &amp;quot;orgs&amp;quot;)
    dbDisconnect(con)
    filtered &amp;lt;- filter(df, !(as.character(ID) %in%
                              as.character(db$ID)))
    filtered
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As mentioned earlier, sometimes Open Street Maps would simply not have registered certain &amp;ldquo;cities&amp;rdquo; (in fact it happened only with really small villages or populations). For that the function &lt;code&gt;add_coords_manually&lt;/code&gt; would take a csv file with a particular structure to add the missing data. The csv file must have the following columns:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ID&lt;/code&gt; column named exactly like that and containing the same ID as the original data.&lt;/li&gt;
&lt;li&gt;A column containing the name of the city&lt;/li&gt;
&lt;li&gt;Columns containing the Latitude and Longitude were we want to point at the city&lt;/li&gt;
&lt;li&gt;A value for &lt;code&gt;osm_name&lt;/code&gt;. This could be left empty or we can provide the value we want in this slot. What is important is to have the column present in the csv file.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Then, as in previous function, we pass to &lt;code&gt;add_coords_manually&lt;/code&gt; the name of the csv file with the complementary information, the name of the SQLite database and the names of the columns where we have the values for &lt;code&gt;city&lt;/code&gt; names, &lt;code&gt;osm_name&lt;/code&gt;, &lt;code&gt;lat&lt;/code&gt; and &lt;code&gt;long&lt;/code&gt;, all as strings. The rest of the function is self descriptive, provided basic knowledge of SQL syntax.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;add_coords_manually &amp;lt;- function(csv_file, db.name,
                                city, osm_name, lat, lon){
    require(tidyverse)
    require(RSQLite)
    csv_dat &amp;lt;- read_csv(csv_file)
    csv_len &amp;lt;- length(csv_dat$ID)
    con &amp;lt;- dbConnect(drv=RSQLite::SQLite(), dbname=db.name)
    for(i in 1:csv_len){
        dbSendQuery(con, &#39;INSERT OR IGNORE INTO orgs
                      (ID, City, osm_name, lon, lat)
                      VALUES (?, ?, ?, ?, ?);&#39;,
                    list(csv_dat[[&#39;ID&#39;]][i],
                         csv_dat[[city]][i],
                         csv_dat[[osm_name]][i],
                         csv_dat[[lat]][i],
                         csv_dat[[lon]][i]))
    }
    dbDisconnect(con)
    print(paste(csv_len, &#39;inserted&#39;))
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;next-steps&#34;&gt;Next steps&lt;/h2&gt;
&lt;p&gt;If you are new to R you could probably already had noticed that one of the strengths of R that I&amp;rsquo;m using a lot here is its use of functions. The first maps that we created were done writing scripts with a few hundreds of lines. Those gave us the basis to craft the necessary functions and so, the rest of the maps were possible using just a few lines. Some of the scripts for the web scrapping of the coordinates consist of less than 10 lines of code. That is possible using the functions above and a few others created for special or particular cases. I will not share absolutely everything but I want to give an idea of how to make the process more efficient. You can always create more functions for your particular cases or modify my proposed functions to adapt to your particular situation.&lt;/p&gt;
&lt;p&gt;And speaking of extensibility, just while writting this blog I found out about the package &lt;a href=&#34;https://github.com/r-tmap/tmaptools&#34; target=&#34;_blank&#34;&gt;tmaptools&lt;/a&gt; which contains the function &lt;a href=&#34;https://www.rdocumentation.org/packages/tmap/versions/1.6-1/topics/geocode_OSM&#34; target=&#34;_blank&#34;&gt;geocode_OSM&lt;/a&gt; which uses nominatim to retrieve the coordinates of the searched point. The function has a more user friendly searching format and more possibilities for the return value, while my &lt;code&gt;coords_from_city()&lt;/code&gt; option stays quite stiff and still with the original format that it was envisioned a few years ago when I created it. If you are truly interested in the topic I invite you to check the package. Myself I have been busy maintaining the code and creating maps that I found little time to do any improvements to the original project. But that&amp;rsquo;s exactly my main task right now so, if I do any changes to the functions presented here using the &lt;a href=&#34;https://github.com/r-tmap/tmaptools&#34; target=&#34;_blank&#34;&gt;tmaptools&lt;/a&gt; package you can be sure that I will create a short post to share it as well.&lt;/p&gt;
&lt;p&gt;Then, once we got the coordinates of our target cities and we know how to make the basic map, the next step is to add the cities to the base map. In the next post I will show you how I did that and a function to make the process faster and efficient.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Mapa de cualquier región del mundo con R - Parte II: obteniendo las coordenadas.</title>
      <link>https://blog.rwhitedwarf.com/es/post/2022/mapa_de_cualquier_region_con_ggplot2ii/</link>
      <pubDate>Fri, 04 Nov 2022 00:00:00 +0000</pubDate>
      
      <guid>https://blog.rwhitedwarf.com/es/post/2022/mapa_de_cualquier_region_con_ggplot2ii/</guid>
      <description>&lt;p&gt;Pueden encontrar todas las publicaciones en este tema bajo la etiqueta &lt;a href=&#34;https://blog.rwhitedwarf.com/tags/maps-app/&#34; target=&#34;_blank&#34;&gt;maps-app&lt;/a&gt; (incluyendo las versiones en inglés).&lt;/p&gt;
&lt;p&gt;También pueden encontrar el estado actual del proyecto en &lt;a href=&#34;https://github.com/teotenn&#34; target=&#34;_blank&#34;&gt;mi GitHub&lt;/a&gt; repo &lt;a href=&#34;https://github.com/teotenn/mapic&#34; target=&#34;_blank&#34;&gt;mapic&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;sobre-este-post&#34;&gt;Sobre este post&lt;/h2&gt;
&lt;p&gt;Esta es la segunda parte de las series de cómo crear mapas de cualquier región del mundo con R. De antemano me disculpo por detalles que puedan encontrar en la traducción, el post original lo creé en Inglés y el trabajo de traducción puede ser excesivo si voy a cada detalle. Por otro lado, recomiendo un conocimiento al menos básico del idioma Inglés si se quiere tener éxito en R o programación en general. Ayuda mucho a entender la sintaxis.&lt;/p&gt;
&lt;p&gt;Estamos creando mapas de datos que muestran los cambios durante un período de tiempo para diferentes países y orientado a todo tipo de ciudades. Esto básicamente significa que necesitamos &lt;strong&gt;mapear cualquier región del mundo con R&lt;/strong&gt;. Hoy en día existen todo tipo de paquetes y técnicas para hacerlo. Quiero compartir la estrategia que utilicé con &lt;a href=&#34;https://cran.r-project.org/web/packages/ggplot2/index.html&#34; target=&#34;_blank&#34;&gt;ggplot2&lt;/a&gt; y &lt;a href=&#34;https://cran.r-project.org/web/packages/maps/index.html&#34; target=&#34;_blank&#34;&gt;maps&lt;/a&gt;, utilizando el soporte de &lt;a href=&#34;https://www.openstreetmap.org/&#34; target=&#34;_blank&#34;&gt;Open Street Map&lt;/a&gt; para obtener las coordenadas de las ciudades y finalmente hacerlo interactivo con &lt;a href=&#34;https://shiny.rstudio.com/&#34; target=&#34;_blank&#34;&gt;shiny&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Estas publicaciones comparten mi camino en la creación de la aplicación Shiny. Es un proyecto vivo en el que estoy trabajando actualmente y decidí compartir mis experiencias durante el proceso de creación. Estas publicaciones no son sólo acerca de Shiny apps, si no más bien sobre la creación del paquete detrás, incluyendo temas sobre la generación de funciones, creación de los mapas, clases de objetos, entre otros, incluyendo cualquier tema interesante que aparezca en el camino. Es mi manera de contribuir a la comunidad de R y al mismo tiempo documentar el proyecto en si mismo.&lt;/p&gt;
&lt;p&gt;Espero que lo disfruten. Siéntanse libres de dejar cualquier tipo de comentario y/o pregunta al final.&lt;/p&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://blog.rwhitedwarf.com/post/2022/map_any_region_with_ggplot2_part_I/maps_DrawingMap.png&#34; alt=&#34;R Maps&#34; /&gt;
&lt;/p&gt;
&lt;h2 id=&#34;open-street-maps-y-nominatim&#34;&gt;Open Street Maps y Nominatim&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Una búsqueda sencilla&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(&#39;RJSONIO&#39;)

site &amp;lt;- (&amp;quot;http://nominatim.openstreetmap.org/search?city=Texcoco&amp;amp;limit=9&amp;amp;format=json&amp;quot;)
(result &amp;lt;- fromJSON(site))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; [[1]]
&amp;gt; [[1]]$place_id
&amp;gt; [1] 1177116
&amp;gt; 
&amp;gt; [[1]]$licence
&amp;gt; [1] &amp;quot;Data © OpenStreetMap contributors, ODbL 1.0. https://osm.org/copyright&amp;quot;
&amp;gt; 
&amp;gt; [[1]]$osm_type
&amp;gt; [1] &amp;quot;node&amp;quot;
&amp;gt; 
&amp;gt; [[1]]$osm_id
&amp;gt; [1] 336169214
&amp;gt; 
&amp;gt; [[1]]$boundingbox
&amp;gt; [1] &amp;quot;29.619&amp;quot;       &amp;quot;29.659&amp;quot;       &amp;quot;-111.0786667&amp;quot; &amp;quot;-111.0386667&amp;quot;
&amp;gt; 
&amp;gt; [[1]]$lat
&amp;gt; [1] &amp;quot;29.639&amp;quot;
&amp;gt; 
&amp;gt; [[1]]$lon
&amp;gt; [1] &amp;quot;-111.0586667&amp;quot;
&amp;gt; 
&amp;gt; [[1]]$display_name
&amp;gt; [1] &amp;quot;Texcoco, Carbó, Sonora, México&amp;quot;
&amp;gt; 
&amp;gt; [[1]]$class
&amp;gt; [1] &amp;quot;place&amp;quot;
&amp;gt; 
&amp;gt; [[1]]$type
&amp;gt; [1] &amp;quot;village&amp;quot;
&amp;gt; 
&amp;gt; [[1]]$importance
&amp;gt; [1] 0.385
&amp;gt; 
&amp;gt; [[1]]$icon
&amp;gt; [1] &amp;quot;https://nominatim.openstreetmap.org/ui/mapicons/poi_place_village.p.20.png&amp;quot;
&amp;gt; 
&amp;gt; 
&amp;gt; [[2]]
&amp;gt; [[2]]$place_id
&amp;gt; [1] 3448536
&amp;gt; 
&amp;gt; [[2]]$licence
&amp;gt; [1] &amp;quot;Data © OpenStreetMap contributors, ODbL 1.0. https://osm.org/copyright&amp;quot;
&amp;gt; 
&amp;gt; [[2]]$osm_type
&amp;gt; [1] &amp;quot;node&amp;quot;
&amp;gt; 
&amp;gt; [[2]]$osm_id
&amp;gt; [1] 458633446
&amp;gt; 
&amp;gt; [[2]]$boundingbox
&amp;gt; [1] &amp;quot;16.551667&amp;quot;  &amp;quot;16.591667&amp;quot;  &amp;quot;-97.053333&amp;quot; &amp;quot;-97.013333&amp;quot;
&amp;gt; 
&amp;gt; [[2]]$lat
&amp;gt; [1] &amp;quot;16.571667&amp;quot;
&amp;gt; 
&amp;gt; [[2]]$lon
&amp;gt; [1] &amp;quot;-97.033333&amp;quot;
&amp;gt; 
&amp;gt; [[2]]$display_name
&amp;gt; [1] &amp;quot;Texcoco, Santa María Sola, Oaxaca, México&amp;quot;
&amp;gt; 
&amp;gt; [[2]]$class
&amp;gt; [1] &amp;quot;place&amp;quot;
&amp;gt; 
&amp;gt; [[2]]$type
&amp;gt; [1] &amp;quot;hamlet&amp;quot;
&amp;gt; 
&amp;gt; [[2]]$importance
&amp;gt; [1] 0.36
&amp;gt; 
&amp;gt; [[2]]$icon
&amp;gt; [1] &amp;quot;https://nominatim.openstreetmap.org/ui/mapicons/poi_place_village.p.20.png&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;Comenzamos con &lt;a href=&#34;https://www.openstreetmap.org/&#34; target=&#34;_blank&#34;&gt;Open Street Map&lt;/a&gt; y su API &lt;a href=&#34;https://nominatim.openstreetmap.org/ui/about.html&#34; target=&#34;_blank&#34;&gt;nominatim&lt;/a&gt;. En el código anterior podemos ver cómo realizar una consulta simple para una ciudad. Es básicamente un string (en R, &amp;ldquo;string&amp;rdquo; se utiliza para referirse a texto) largo que contiene primero la url de nominatim y al final los detalles de la búsqueda: aquí comenzamos la búsqueda de la ciudad, usando &lt;code&gt;?city=Texcoco&lt;/code&gt; que en este caso apunta a una ciudad con solo unos pocos resultados. A continuación, limitamos la cantidad de resultados a 9 con &lt;code&gt;&amp;amp;limit=9&lt;/code&gt; y finalmente solicitamos los resultados en formato JSON.&lt;/p&gt;
&lt;p&gt;Básicamente, podríamos copiar el string que estamos pasando a la variable &lt;code&gt;site&lt;/code&gt; y pegarla en el navegador web para ver los resultados directamente ahí. Siéntete libre de cambiar la ciudad &lt;code&gt;Texcoco&lt;/code&gt; a cualquier otra ciudad, y juega un poco más con el resto de los parámetros. En particular, eche un vistazo a lo que sucede cuando elimina la parte &lt;code&gt;&amp;amp;format=json&lt;/code&gt; o cuando cambia &lt;code&gt;json&lt;/code&gt; por cualquier otra cadena abstracta como &lt;code&gt;csv&lt;/code&gt; u otro formato no reconocido.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Una búsqueda más sencilla&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;city &amp;lt;- &#39;San%20Francisco&#39;
state &amp;lt;- &#39;&amp;amp;state=California&#39;
country &amp;lt;- &#39;&amp;amp;countrycodes=US&#39;
start.nominatim &amp;lt;- &amp;quot;http://nominatim.openstreetmap.org/search?city=&amp;quot;
end.nominatim &amp;lt;- &amp;quot;&amp;amp;format=json&amp;quot;

site &amp;lt;- paste0(start.nominatim, city, country, state, end.nominatim)
(result &amp;lt;- fromJSON(site))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; [[1]]
&amp;gt; [[1]]$place_id
&amp;gt; [1] 297054975
&amp;gt; 
&amp;gt; [[1]]$licence
&amp;gt; [1] &amp;quot;Data © OpenStreetMap contributors, ODbL 1.0. https://osm.org/copyright&amp;quot;
&amp;gt; 
&amp;gt; [[1]]$osm_type
&amp;gt; [1] &amp;quot;relation&amp;quot;
&amp;gt; 
&amp;gt; [[1]]$osm_id
&amp;gt; [1] 111968
&amp;gt; 
&amp;gt; [[1]]$boundingbox
&amp;gt; [1] &amp;quot;37.6403143&amp;quot;  &amp;quot;37.929811&amp;quot;   &amp;quot;-123.173825&amp;quot; &amp;quot;-122.281479&amp;quot;
&amp;gt; 
&amp;gt; [[1]]$lat
&amp;gt; [1] &amp;quot;37.7790262&amp;quot;
&amp;gt; 
&amp;gt; [[1]]$lon
&amp;gt; [1] &amp;quot;-122.419906&amp;quot;
&amp;gt; 
&amp;gt; [[1]]$display_name
&amp;gt; [1] &amp;quot;San Francisco, CAL Fire Northern Region, California, United States&amp;quot;
&amp;gt; 
&amp;gt; [[1]]$class
&amp;gt; [1] &amp;quot;boundary&amp;quot;
&amp;gt; 
&amp;gt; [[1]]$type
&amp;gt; [1] &amp;quot;administrative&amp;quot;
&amp;gt; 
&amp;gt; [[1]]$importance
&amp;gt; [1] 1.035131
&amp;gt; 
&amp;gt; [[1]]$icon
&amp;gt; [1] &amp;quot;https://nominatim.openstreetmap.org/ui/mapicons/poi_boundary_administrative.p.20.png&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;Si exploramos OSM y nominatim un poco, veremos que podemos agregar argumentos de búsqueda usando &lt;code&gt;&amp;amp;&lt;/code&gt; seguido del argumento que queremos (es decir, &lt;code&gt;state&lt;/code&gt;), el símbolo igual (&lt;code&gt;=&lt;/code&gt;) y el argumento. En mi ejemplo anterior, puede verse cómo especificamos el estado y el país de nuestra consulta. Además, es importante saber cómo pasar espacios en un nombre, por ejemplo, San Francisco pasaría como &lt;code&gt;San%20Francisco&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Con esta información básica en mente y sabiendo que el paquete &lt;code&gt;RJSONIO&lt;/code&gt; nos ayuda a recuperar los datos de la API JSON en un formato tabular compatible con R, podemos preparar fácilmente una función para buscar cualquier ciudad rápidamente, siempre que se proporcionen algunos detalles adicionales como una región, estado o condado, y especialmente importante, el país (intenta buscar ciudades como Londres o Praga sin proporcionar un país, te sorprenderá la cantidad de ciudades que existen en el mundo con esos nombres).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;coords_from_city &amp;lt;- function(City,
                             CountryTwoLetter,
                             Region = NULL,
                             State = NULL,
                             County = NULL){
    require(&#39;RJSONIO&#39;)
    CityCoded &amp;lt;- gsub(&#39; &#39;,&#39;%20&#39;,City) #remover espacios de  URLs
    CountryCoded &amp;lt;- paste(&amp;quot;&amp;amp;countrycodes=&amp;quot;, CountryTwoLetter, sep = &#39;&#39;)
    extras &amp;lt;- c(state = State, region = Region, county = County)
    extrasCoded &amp;lt;- &#39;&#39;
    if(!is.null(extras)) {
        for(i in 1:length(extras)){
            if(extras[i] != &#39;&#39; &amp;amp;&amp;amp; !is.na(extras[i]) &amp;amp;&amp;amp; !grepl(&amp;quot;^\\s*$&amp;quot;, extras[i])){
                valCoded &amp;lt;- gsub(&#39; &#39;, &#39;%20&#39;, extras[i])
                extrasCoded &amp;lt;- paste0(extrasCoded, &#39;&amp;amp;&#39;, names(extras)[i], &#39;=&#39;, valCoded)
            }
        }
    }
    ## obtener los datos
    url &amp;lt;- paste(
        &amp;quot;http://nominatim.openstreetmap.org/search?city=&amp;quot;
      , CityCoded
      , CountryCoded
      , extrasCoded
      , &amp;quot;&amp;amp;format=json&amp;quot;
      , sep=&amp;quot;&amp;quot;)
    x &amp;lt;- fromJSON(url)
    ## obtener las coordenadas
    if(is.vector(x)){
            message(paste(&#39;Found&#39;, x[[1]]$display_name))
            lon &amp;lt;- x[[1]]$lon
            lat &amp;lt;- x[[1]]$lat
            osm_name &amp;lt;- x[[1]]$display_name
            coords &amp;lt;- data.frame(&#39;lon&#39; = lon, &#39;lat&#39; = lat, &#39;osm_name&#39; = osm_name)
    }
    ## Si x no es un vector
    else{
        message(paste(&#39;No results found for&#39;, City, CountryTwoLetter))
        coords &amp;lt;- data.frame(&#39;lon&#39; = NA, &#39;lat&#39; = NA)
    }
    ## regresa un df
    coords
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Un detalle importante que debe saber es que, a menudo, proporcionar valores a los parámetros &amp;ldquo;state&amp;rdquo; o &amp;ldquo;region&amp;rdquo; arroja resultados similares, esto es particularmente útil en países donde no se usan estados o hay otras formas de organización presentes. Sin embargo, cuando el país tiene estrictamente estados, no puedes pasar el nombre de un Estado al parámetro &lt;code&gt;Region&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;La función devuelve un data frame que usaremos más adelante para crear una tabla con todos nuestros resultados. Como estamos interesados en crear mapas, solo necesitamos las coordenadas expresadas en latitud y longitud. En caso de que no se encuentre la consulta, la función completa los valores con &lt;code&gt;NA&lt;/code&gt;, que luego usaremos para realizar un seguimiento de lo que se encontró y lo que no. También mantenemos los valores dentro de &lt;code&gt;osm_name&lt;/code&gt;, que brinda suficiente información para brindarle al usuario detalles útiles sobre los resultados de la búsqueda, incluido el país de la ciudad encontrada y otros detalles como el estado o la región.&lt;/p&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://blog.rwhitedwarf.com/post/2022/map_any_region_with_ggplot2_part_II/maps_coords_from_city.png&#34; alt=&#34;Funcion coords_from_city() en detalle&#34; /&gt;
&lt;/p&gt;
&lt;p&gt;Un punto importante a considerar en &lt;code&gt;coords_from_city&lt;/code&gt; es que devuelve solo el resultado superior de la consulta. Esto significa que cuanto más información se proporcione, más preciso será su resultado. Para nuestro proyecto funciona bien porque para los países grandes siempre recopilamos suficiente información sobre regiones y estados, mientras que para los países más pequeños, las opciones a menudo son demasiado pequeñas. Pero si usamos la función, es importante saber que si se proporciona un nombre de ciudad como &lt;code&gt;Springfield&lt;/code&gt;, &lt;code&gt;country = &#39;US&#39;&lt;/code&gt; y no proporciona información sobre el estado y el condado, la función recuperara solo el primer resultado de la búsqueda, y descarta las opciones restantes.&lt;/p&gt;
&lt;h2 id=&#34;mantener-la-información-en-una-base-de-datos&#34;&gt;Mantener la información en una base de datos&lt;/h2&gt;
&lt;p&gt;La función &lt;code&gt;coords_from_city&lt;/code&gt; podría ser suficiente si necesitamos obtener información unas pocas ciudades; Podríamos utilizar la iteración de &lt;code&gt;for&lt;/code&gt; para recuperar todas las coordenadas que necesitamos y almacenarlas en un data frame para luego guardarlas en formato csv, &lt;code&gt;Rdata&lt;/code&gt; o cualquier formato que elijamos. Lo mismo ocurre cuando buscamos cientos o miles de ciudades, pero con el aumento del tamaño, el tiempo de búsqueda también aumenta. Si, por alguna razón, la sesión de R se interrumpe, la información se perdería y tendremos que comenzar de nuevo desde la fila 1. Por lo tanto, enviaremos todos los resultados a una base de datos. De esa forma, no importa cuándo detengamos el proceso o cómo suceda, los datos se almacenan de forma segura fuera de R.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;webscrap_to_sqlite &amp;lt;- function(db.name,
                               dat,
                               col.city = &#39;City&#39;,
                               col.country = &#39;Country&#39;,
                               region = NULL,
                               state = NULL,
                               county = NULL)
{
    require(RSQLite)
    df_len &amp;lt;- nrow(dat)
    ## Conexion a la db y la tabla
    con &amp;lt;- dbConnect(drv=SQLite(), dbname=db.name)
    dbExecute(conn = con,
                &amp;quot;CREATE TABLE IF NOT EXISTS orgs
                    (ID INTEGER UNIQUE,
                     City TEXT, osm_name TEXT,
                     lon REAL,lat REAL)&amp;quot;)
    ## -- Iteraciones para el webscrap -- ##
    ccount &amp;lt;- 0
    ## For loop para el webscrapping
    for(i in 1:df_len){
        rg &amp;lt;- ifelse(is.null(region), &#39;&#39;, dat[[region]][i])
        st &amp;lt;- ifelse(is.null(state), &#39;&#39;, dat[[state]][i])
        ct &amp;lt;- ifelse(is.null(county), &#39;&#39;, dat[[county]][i])
        print(paste(&#39;Entry&#39;, i))
        ## Haz el webscrap
        coords &amp;lt;- coords_from_city(dat[[col.city]][i],
                                   dat[[col.country]][i],
                                   Region = rg, State = st, County = ct)
        ## Enviar resultados a DB sólo si se encontró algo
        if(is.na(coords$lon[1])){
            ccount &amp;lt;- ccount + 1
        }
        else{
            sq &amp;lt;- dbExecute(con, &#39;INSERT OR IGNORE INTO orgs
                             (ID, City, osm_name, lon, lat)
                             VALUES (?, ?, ?, ?, ?);&#39;,
                        list(dat[[&#39;ID&#39;]][i], dat[[col.city]][i],
                             coords$osm_name, coords$lon[1], coords$lat[1]))
        }
        print(paste(&#39;Completed&#39;, (i/df_len)*100, &#39;%&#39;))
    }
    ## Cerrar la conexión
    dbDisconnect(con)
    message(paste(&amp;quot;WEB SCRAP FOR COORDINATES SEARCH FINISHED.&amp;quot;,
                ccount, &amp;quot;ENTRIES NOT FOUND&amp;quot;))
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Para almacenar los datos elegí usar &lt;a href=&#34;https://www.sqlite.org/index.html&#34; target=&#34;_blank&#34;&gt;SQLite&lt;/a&gt; a través del paquete R &lt;a href=&#34;https://rsqlite.r-dbi.org/&#34; target=&#34;_blank&#34;&gt;RSQLite&lt;/a&gt;. Si no estas familiarizado con las bases de datos SQL te recomiendo que comiences con una búsqueda general en Google y luego regresar a la documentación de SQLite y el paquete R. Elegí SQLite porque necesitaba tener algo ligero y portátil que nos permitiera mover la información fácilmente de un país a otro en lugar de una base de datos centralizada donde pudiéramos almacenar todo, pero se puede aplicar un enfoque muy similar usando otros tipos de bases de datos SQL.&lt;/p&gt;
&lt;p&gt;La función &lt;code&gt;dbConnect()&lt;/code&gt; genera el archivo SQLite si aún no existe. Luego le damos a SQLite la orden de crear la tabla &lt;code&gt;orgs&lt;/code&gt; si aún no existe, y la estructura para dicha tabla. A continuación buscamos las coordenadas de las entradas una a una usando &lt;code&gt;coords_from_city()&lt;/code&gt; y finalmente lo enviamos a la base de datos. De esa manera podríamos detener el proceso en cualquier momento y continuar más tarde simplemente recuperando la tabla &lt;code&gt;orgs&lt;/code&gt; de la base de datos, comparándola con nuestros datos originales y avanzando desde lo que falta. Para eso, la columna &lt;code&gt;ID&lt;/code&gt; es fundamental, es la columna que nos permite vincular una entrada entre los datos originales, el data frame de R y la tabla SQL.&lt;/p&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://blog.rwhitedwarf.com/post/2022/map_any_region_with_ggplot2_part_II/maps_webscrap_to_sqlite.png&#34; alt=&#34;Función webscrap_to_sqlite() en detalle&#34; /&gt;
&lt;/p&gt;
&lt;p&gt;Nuestra función también tiene una variable &lt;code&gt;ccount&lt;/code&gt; que cuenta cada vez que no se encuentra una entrada. De esa forma, una vez finalizada la consulta, imprimirá la cantidad de entradas que no fueron encontradas. Las razones para no encontrar una entrada pueden ser muchas, entre las más comunes que encontré están las siguientes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Error en la ortografía del nombre de la ciudad o exceso de información (es decir, valor &amp;ldquo;Praga, Distrito 3&amp;rdquo; cuando el nombre de la ciudad es simplemente &amp;ldquo;Praga&amp;rdquo;).&lt;/li&gt;
&lt;li&gt;La ortografía incorrecta del nombre del Estado, Región y/o Condado.&lt;/li&gt;
&lt;li&gt;La ciudad buscada simplemente no está en la base de datos de Open Street Maps (sucedió especialmente para pueblos muy pequeños).&lt;/li&gt;
&lt;li&gt;Interrupciones de la conexión a internet. Esta es particularmente importante porque, a veces, ejecutar la consulta por segunda o tercera vez encontraría ciudades que no se encontraron la primera vez.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Para volver a leer los datos a R desde SQL, simplemente necesitamos hacer una conexión a la base de datos, leer la tabla y cerrar la conexión. La función &lt;code&gt;combine_df_sql&lt;/code&gt; se encarga de eso y al mismo tiempo une nuestros datos originales con los datos almacenados en la base de datos por el ID y el nombre de la ciudad. Esto fue importante para el proyecto porque queríamos mantener las coordenadas de las ciudades separadas del resto de la información debido a algunas razones prácticas internas. Pero creo que mantener todos los datos en SQL a la vez puede facilitar muchas cosas. Entre otros, podría identificar cuándo se encontró una ciudad en particular en el pasado y recuperar las coordenadas de la base de datos directamente en lugar de hacer una conexión con nominatim. Lo hice para algunos países y reduce considerablemente el tiempo de consulta. Para la presente publicación, decidí mostrar la versión separada de los datos para brindar más herramientas al lector.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;combine_df_sql &amp;lt;- function(db.file, original.data){
    require(dplyr)
    require(RSQLite)
    if(is.character(original.data)){
        if(grepl(&#39;.csv&#39;, original.data, fixed = T)){
            df &amp;lt;- read.csv(original.data)
        }
        else{
            stop(&amp;quot;Incorrect file format for data&amp;quot;)
        }
    }
    else if(is.data.frame(original.data)){
        df &amp;lt;- original.data
    }
    else{
        stop(&amp;quot;Incorrect data format&amp;quot;)
    }
    con &amp;lt;- dbConnect(drv=RSQLite::SQLite(), dbname = db.file)
    db &amp;lt;- dbReadTable(con, &amp;quot;orgs&amp;quot;)
    dbDisconnect(con)
    result &amp;lt;- left_join(df, db, by = c(&#39;ID&#39;, &#39;City&#39;))
    return(result)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Otro detalle de nuestra función es la capacidad de leer desde el archivo &lt;code&gt;csv&lt;/code&gt; o desde un &lt;code&gt;data.frame&lt;/code&gt;. Dado que estábamos trabajando principalmente con archivos csv y usé data frames para los pruebas unitarias, estos 2 formatos fueron suficientes. Siéntanse libres de modificar o ampliar la función para los formatos de datos que puedan necesitarse.&lt;/p&gt;
&lt;h2 id=&#34;datos-faltantes&#34;&gt;Datos faltantes&lt;/h2&gt;
&lt;p&gt;Como se mencionó anteriormente, a veces los resultados de la consulta estaban incompletos y era necesaria una segunda o tercera ejecución, pero con menos filas. Algunas otras veces sólo necesitaba parar la consulta y continuar mas tarde desde donde la dejamos. Sin embargo, otras veces los datos estaban incompletos o incorrectos y esto se podía solucionar más tarde con el responsable de los datos. Los 3 escenarios me forzaban a leer el archivo csv a R, luego la tabla de la base de datos y compararlos para filtrar los valores faltantes. Así que creé la función &lt;code&gt;compare_db_data&lt;/code&gt; para comparar la base de datos (db) con los datos originales.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;compare_db_data &amp;lt;- function(db.file, dat){
    require(dplyr)
    require(RSQLite)
    if(is.character(dat)){
        if(grepl(&#39;.csv&#39;, dat, fixed = T)){
            df &amp;lt;- read.csv(dat)
        }
        else{
            stop(&amp;quot;Incorrect file format for data&amp;quot;)
        }
    }
    else if(is.data.frame(dat)){
        df &amp;lt;- dat
    }
    else{
        stop(&amp;quot;Incorrect data format&amp;quot;)
    }
    con &amp;lt;- dbConnect(drv=RSQLite::SQLite(), dbname = db.file)
    db &amp;lt;- dbReadTable(con, &amp;quot;orgs&amp;quot;)
    dbDisconnect(con)
    filtered &amp;lt;- filter(df, !(as.character(ID) %in%
                              as.character(db$ID)))
    filtered
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Como se mencionó anteriormente, a veces Open Street Maps simplemente no tiene registro de ciertas &amp;ldquo;ciudades&amp;rdquo; (de hecho, sucedió solo con pueblos o poblaciones realmente pequeñas). Para solucionar eso, la función &lt;code&gt;add_coords_manually&lt;/code&gt; toma un archivo csv con una estructura particular para agregar los datos que faltan. El archivo csv debe tener las siguientes columnas:
- Columna &lt;code&gt;ID&lt;/code&gt; nombrada exactamente así y que contiene la misma ID que los datos originales.
- Una columna que contiene el nombre de la ciudad
- Columnas que contienen la Latitud y Longitud donde queremos señalar la ciudad
- Un valor para &lt;code&gt;osm_name&lt;/code&gt;. Esto podría dejarse vacío o podemos proporcionar el valor que queremos en esta punto. Lo importante es tener la columna presente en el archivo csv.&lt;/p&gt;
&lt;p&gt;Luego, como en la función anterior, le pasamos a &lt;code&gt;add_coords_manualmente&lt;/code&gt; el nombre del archivo csv con la información complementaria, el nombre de la base de datos SQLite y los nombres de las columnas donde tenemos los valores para los nombres de &lt;code&gt;city&lt;/code&gt;, &lt;code&gt;osm_name&lt;/code&gt; , &lt;code&gt;lat&lt;/code&gt; y &lt;code&gt;long&lt;/code&gt;, todos con formato de string. El resto de la función es autodescriptiva, siempre que se tengan conocimientos básicos de sintaxis SQL.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;add_coords_manually &amp;lt;- function(csv_file, db.name,
                                city, osm_name, lat, lon){
    require(tidyverse)
    require(RSQLite)
    csv_dat &amp;lt;- read_csv(csv_file)
    csv_len &amp;lt;- length(csv_dat$ID)
    con &amp;lt;- dbConnect(drv=RSQLite::SQLite(), dbname=db.name)
    for(i in 1:csv_len){
        dbSendQuery(con, &#39;INSERT OR IGNORE INTO orgs
                      (ID, City, osm_name, lon, lat)
                      VALUES (?, ?, ?, ?, ?);&#39;,
                    list(csv_dat[[&#39;ID&#39;]][i],
                         csv_dat[[city]][i],
                         csv_dat[[osm_name]][i],
                         csv_dat[[lat]][i],
                         csv_dat[[lon]][i]))
    }
    dbDisconnect(con)
    print(paste(csv_len, &#39;inserted&#39;))
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;siguientes-pasos&#34;&gt;Siguientes pasos&lt;/h2&gt;
&lt;p&gt;Si eres nuevo en R, probablemente habrás notado que uno de los puntos fuertes de R que estoy usando mucho aquí es el uso de funciones. Los primeros mapas que creamos en el proyecto los hicimos escribiendo scripts con unos pocos cientos de líneas. Eso nos dio la base para crear las funciones necesarias y, por lo tanto, el resto de los mapas fueron posibles usando solo unas pocas líneas. Algunos de los scripts para el web scrapping de las coordenadas constan de menos de 10 líneas de código. Eso es posible usando las funciones anteriores y algunas otras creadas para casos especiales o particulares. No compartiré absolutamente todo, pero quiero dar una idea de cómo hacer que el proceso sea más eficiente. Siempre puedes crear más funciones para tus casos particulares o modificar mis funciones propuestas para adaptarlas a tu situación particular.&lt;/p&gt;
&lt;p&gt;Y hablando de extensibilidad, mientras escribía este blog descubrí una librería que no conocía, &lt;a href=&#34;https://github.com/r-tmap/tmaptools&#34; target=&#34;_blank&#34;&gt;tmaptools&lt;/a&gt; que contiene la función [geocode_OSM](&lt;a href=&#34;https://www.rdocumentation&#34; target=&#34;_blank&#34;&gt;https://www.rdocumentation&lt;/a&gt;. org/packages/tmap/versions/1.6-1/topics/geocode_OSM) que usa nominatim para recuperar las coordenadas del punto buscado. La función tiene un formato de búsqueda más fácil de usar y más posibilidades para el valor de retorno, mientras que mi opción &lt;code&gt;coords_from_city()&lt;/code&gt; se mantiene bastante rígida y aún con el formato original que se imaginó hace unos años cuando la creé. Si realmente te interesa el tema te invito a revisar el paquete. Yo mismo he estado ocupado manteniendo el código y creando mapas, por lo que tengo muy poco tiempo para hacer mejoras al proyecto original. Pero esa es exactamente mi tarea principal en este momento, así que si hago algún cambio en las funciones presentadas aquí usando el paquete &lt;a href=&#34;https://github.com/r-tmap/tmaptools&#34; target=&#34;_blank&#34;&gt;tmaptools&lt;/a&gt;, puedes estar seguro de que crearé un breve publicación para compartirlo.&lt;/p&gt;
&lt;p&gt;Luego, una vez que tenemos las coordenadas de nuestras ciudades objetivo y sabemos cómo hacer el mapa básico, el siguiente paso es agregar las ciudades al mapa base. En la próxima publicación, les mostraré cómo lo hice y una función para que el proceso sea más rápido y eficiente.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Map any region in the world with R - Part I: The basic map</title>
      <link>https://blog.rwhitedwarf.com/post/map_any_region_with_ggplot2_part_i/</link>
      <pubDate>Sat, 08 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://blog.rwhitedwarf.com/post/map_any_region_with_ggplot2_part_i/</guid>
      <description>&lt;p&gt;You can find all the posts on this series under the tag &lt;a href=&#34;https://blog.rwhitedwarf.com/tags/maps-app/&#34; target=&#34;_blank&#34;&gt;maps-app&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;You can also find the current state of the project under &lt;a href=&#34;https://github.com/teotenn&#34; target=&#34;_blank&#34;&gt;my GitHub&lt;/a&gt; repo &lt;a href=&#34;https://github.com/teotenn/mapic&#34; target=&#34;_blank&#34;&gt;mapic&lt;/a&gt; (including the Spanish versions).&lt;/p&gt;
&lt;h2 id=&#34;scope-of-this-post&#34;&gt;Scope of this post&lt;/h2&gt;
&lt;p&gt;When you prepare for a job interview one of the questions they always tell you to prepare is &amp;ldquo;What are you most proud of?&amp;rdquo;. Personally I&amp;rsquo;ve never been asked that question in a job interview but it kept me thinking. Some years ago I developed the R code for the creation of maps of infrastructure for a Political Sciences project, and I can say that this is one of the projects I&amp;rsquo;m most proud of. However, it is also true what they say to developers, that &lt;strong&gt;nobody cares about how you did it&lt;/strong&gt;. The final user only cared about what was done, while the research team about what are the possibilities.&lt;/p&gt;
&lt;p&gt;The project taught me so much in terms of technical skills that I have decided to &lt;strong&gt;share the how&lt;/strong&gt; in case it can help somebody else. It is also my way to contribute to the R community since I myself learned R and programming thanks to the kind people who post their experience on the web (and to the ones who have the patience to answer questions in StackOverflow too). Due to the confidentiality agreement of the client, I also cannot share a git repository.&lt;/p&gt;
&lt;p&gt;We created maps of data showing changes over a span of time for different countries and pointing at all kinds of cities. That basically means that we need to &lt;strong&gt;map any region of the world with R&lt;/strong&gt;. Today there are all kinds of packages and techniques to do that. I will share the strategy I used with &lt;a href=&#34;https://cran.r-project.org/web/packages/ggplot2/index.html&#34; target=&#34;_blank&#34;&gt;ggplot2&lt;/a&gt; and &lt;a href=&#34;https://cran.r-project.org/web/packages/maps/index.html&#34; target=&#34;_blank&#34;&gt;maps&lt;/a&gt; packages, using support of &lt;a href=&#34;https://www.openstreetmap.org/&#34; target=&#34;_blank&#34;&gt;Open Street Map&lt;/a&gt; to obtain the coordinates of cities and finally making it interactive with &lt;a href=&#34;https://shiny.rstudio.com/&#34; target=&#34;_blank&#34;&gt;shiny&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The project itself is quite long for a single post, and just recently I managed to extract the base code I created and make it public, without compromising any privacy issues. On the other hand, it is a live project that I am currently working on. Therefore, I decided to share my path and experiences along the creation process of the Shiny app. The posts are not only about the Shiny app, but the package I created behind it. I will touch topics of functions crafting, creation of the maps, classes of objects, etc., as well as any interesting issue that appear on the way. It is my way to contribute to the R community and at the same time keeping the project documented for myself.&lt;/p&gt;
&lt;p&gt;This first post is asbout the creation of &lt;strong&gt;The basic map&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;I hope you all enjoy it. Feel free to leave any kind of comment and/or question at the end.&lt;/p&gt;
&lt;h2 id=&#34;background&#34;&gt;Background&lt;/h2&gt;
&lt;p&gt;When I joined the team all what they knew is that the wanted to make maps of infrastructure (say hospitals, cafes, churches, public offices, etc., but the project can basically be applied to anything countable per city). The maps should change in time according to the data (usually growth) and it should be possible to apply it for any country and thus, any kind of city of that particular country can be listed there. This last point represents a challenge because to make a map you need the coordinates of a particular point to map, but instead we got address in the best scenario, or only city name in the worst. Therefore, we left it to the level of city and decided to work with that.&lt;/p&gt;
&lt;p&gt;Most R packages to make maps have granularity up to some regions and major cities per country, and we are talking about countries where somebody has develop some R package for that. However, even the best packages would miss some cities or some countries some times. We needed to standardize everything without the need of changing packages according to the particular country. Before I joined, the team attempted to use Google Maps and excel, but the amount of data became messy and the flexibility to edit the maps was pretty limited. And they didn&amp;rsquo;t want to add copyright issues to the list of limitations. Therefore I proposed to use R. Of course, nobody in the team had ever heard about it before. We could had used any other tool, I learned that both, Python and JavaScript have some decent possibilities. But R is what I have been using for the last 10 years and is what I wanted to use for this project. And so I started to code.&lt;/p&gt;
&lt;p&gt;The first couple of maps were custom code for a particular country with decent styles. But it quickly evolved into a set of functions and arguments to maintain the same standards for each map. The support of graphic designers also took the styles to a very professional level. After a few months we had very professional maps that could be done in couple of hrs (or less) with a couple of lines of code. Each map per each country with the desired span of years to be printed.&lt;/p&gt;
&lt;p&gt;I don&amp;rsquo;t think I will share every single detail of it, but at least I want to show how we went from the basic map to its dynamic form mapping over a span of time, and how I wrapped it all together in a couple of functions to make it quickly replicable for any given data set. Let me know what you think.&lt;/p&gt;
&lt;h2 id=&#34;how-to-create-a-map-of-any-country-in-r-using-the-library-maps&#34;&gt;How to create a map of any country in R using the library maps&lt;/h2&gt;
&lt;p&gt;The first step is to create the basic map of a country. Here is the function to achieve exactly that.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(maps)
library(ggplot2)

## make a df with only the country to overlap
map_data_es &amp;lt;- map_data(&#39;world&#39;)[map_data(&#39;world&#39;)$region == &amp;quot;Spain&amp;quot;,]

## The map (maps + ggplot2 )
ggplot() +
    ## First layer: worldwide map
    geom_polygon(data = map_data(&amp;quot;world&amp;quot;),
                 aes(x=long, y=lat, group = group),
                 color = &#39;#9c9c9c&#39;, fill = &#39;#f3f3f3&#39;) +
    ## Second layer: Country map
    geom_polygon(data = map_data_es,
                 aes(x=long, y=lat, group = group),
                 color = &#39;red&#39;, fill = &#39;pink&#39;) +
    coord_map() +
    coord_fixed(1.3,
                xlim = c(-13.5, 8.5),
                ylim = c(34, 45)) +
    ggtitle(&amp;quot;A map of Spain&amp;quot;) +
    theme(panel.background =element_rect(fill = &#39;blue&#39;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://blog.rwhitedwarf.com/post/2022/map_any_region_with_ggplot2_part_I/basic_map-1.png&#34; alt=&#34;plot of chunk basic_map&#34; /&gt;
&lt;/p&gt;
&lt;p&gt;We are using the library &lt;a href=&#34;https://cran.r-project.org/web/packages/maps/index.html&#34; target=&#34;_blank&#34;&gt;maps&lt;/a&gt; in combination with &lt;a href=&#34;https://cran.r-project.org/web/packages/ggplot2/index.html&#34; target=&#34;_blank&#34;&gt;ggplot2&lt;/a&gt;. The &lt;code&gt;maps&lt;/code&gt; package contains coordinates system for a map of the whole world separated by countries (although political borders might not be fully up to date). It can as well do the maps, but for that we are making use of &lt;code&gt;ggplot2&lt;/code&gt; support here.&lt;/p&gt;
&lt;p&gt;We start by extracting the data relevant to the country we want to map, in this case &lt;code&gt;Spain&lt;/code&gt;. It is of course important to pass the name of the country in the same way that it is written in &lt;code&gt;map_data(&#39;world&#39;)$region&lt;/code&gt;. You can use the function &lt;code&gt;unique()&lt;/code&gt; to find the exact names of all the countries included in the packages (&lt;code&gt;unique(map_data(&#39;world&#39;)$region)&lt;/code&gt; gives 252 countries at the moment of writing this post).&lt;/p&gt;
&lt;p&gt;Once we have the data for the one particular country, we could simply map it directly using &lt;code&gt;geom_polygon()&lt;/code&gt; however, that would map Spain surrounded by empty space around it. To place it in the context of its neighborhood, we apply two layers of &lt;code&gt;geom_polygon()&lt;/code&gt;: first one with the map of the whole world and secondly the map of the country only.&lt;/p&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://blog.rwhitedwarf.com/post/2022/map_any_region_with_ggplot2_part_I/maps_BasicMap.png&#34; alt=&#34;The basic map code explained&#34; /&gt;
&lt;/p&gt;
&lt;p&gt;Then we need to tell &lt;code&gt;ggplot&lt;/code&gt; to use a coordinates system to create maps instead of just polygons. For that we use &lt;a href=&#34;https://ggplot2.tidyverse.org/reference/coord_map.html&#34; target=&#34;_blank&#34;&gt;coord_map()&lt;/a&gt; function and then we pass the details of the map ratio, and limits in X and Y to the function &lt;code&gt;coord_fixed()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Up to here we can have our map. &lt;code&gt;ggplot&lt;/code&gt; is basically plotting what we are specifying inside the coordinates system, everything around it (the oceans) will be just empty and it will be filled in by the default grids and gray colors of &lt;code&gt;ggplot()&lt;/code&gt;. Thus, we need to define the color of the Oceans as the background color for the whole plot. That&amp;rsquo;s what the last line of code does.&lt;/p&gt;
&lt;p&gt;Of course there are a lot of improvements to do. So far I have given exaggerated colors to make obvious for the reader which piece of code controls what. In that sense you can see that you can simply pass the names of the colors, which applies the defaults, or you can be more specific and provide the html notation of the color (i.e., &lt;code&gt;&#39;#9c9c9c&#39;&lt;/code&gt;). So, let&amp;rsquo;s now improve the visuals and at the same time create a function to plot any country we want to.&lt;/p&gt;
&lt;h2 id=&#34;function-to-create-the-basic-map-in-r&#34;&gt;Function to create the basic map in R&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;map_country &amp;lt;- function(country, x_limits = NULL, y_limits = NULL){
    ## Verifying the arguments passed to the function
    if(!is.character(country)) stop(&amp;quot;Name of the country should be character&amp;quot;)
    if(length(country) != 1) stop(&amp;quot;Function supports only one country per map&amp;quot;)
    ## Load libraries
    require(maps)
    require(ggplot2)
    if(!country %in% map_data(&#39;world&#39;)$region) stop(&#39;Country name not recognized\nTo see a list of recognized countries run &amp;lt;unique(maps::map_data(&amp;quot;world&amp;quot;)$region)&amp;gt;&#39;)
    ## If coords limits missing, print worldwide map with coordinates system to allow
    ## User observe coords for reference
    if(missing(x_limits) || missing(y_limits)) {
        warning(&amp;quot;X and/or Y limits not provided.\nPrinting worldwide map.&amp;quot;)
        map_country_theme &amp;lt;- theme(panel.background = element_rect(fill = &#39;#4e91d2&#39;))
    }
    else {
        if(length(x_limits) != 2 || length(y_limits) != 2 ||
           !all(grepl(&#39;^-?[0-9.]+$&#39;, c(x_limits, y_limits)))){
            stop(&amp;quot;Limits for X and Y coords should be provided as vectors with two numeric values&amp;quot;)
        }
        else {
            ## All the received inputs are correct.
            ## Let&#39;s define our custom theme for the final map 
            map_country_theme &amp;lt;- theme_bw() +
                theme(panel.background = element_rect(fill = &#39;#4e91d2&#39;),
                      legend.position = &#39;none&#39;,
                      panel.grid.major = element_blank(),
                      panel.grid.minor = element_blank(),
                      axis.line = element_line(colour = &amp;quot;black&amp;quot;),
                      axis.title.x=element_blank(),
                      axis.text.x=element_blank(),
                      axis.ticks.x=element_blank(),
                      axis.title.y=element_blank(),
                      axis.text.y=element_blank(),
                      axis.ticks.y=element_blank())
        }
    }
    ## make a df with only the country to overlap
    map_data_country &amp;lt;- map_data(&#39;world&#39;)[map_data(&#39;world&#39;)$region == country,]
    ## The map (maps + ggplot2 )
    ggplot() +
        ## First layer: worldwide map
        geom_polygon(data = map_data(&amp;quot;world&amp;quot;),
                     aes(x=long, y=lat, group = group),
                     color = &#39;#9c9c9c&#39;, fill = &#39;#f3f3f3&#39;) +
        ## Second layer: Country map
        geom_polygon(data = map_data_country,
                     aes(x=long, y=lat, group = group),
                     color = &#39;#4d696e&#39;, fill = &#39;#8caeb4&#39;) +
        coord_map() +
        coord_fixed(1.3,
                    xlim = x_limits,
                    ylim = y_limits) +
        ggtitle(paste0(&amp;quot;A map of &amp;quot;, country)) +
        scale_x_continuous(n.breaks = 20) +
        scale_y_continuous(n.breaks = 20) +
        map_country_theme
}

## Test the function with a different country
map_country(&amp;quot;Germany&amp;quot;, c(-2, 22), c(47, 55))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://blog.rwhitedwarf.com/post/2022/map_any_region_with_ggplot2_part_I/function_map-1.png&#34; alt=&#34;plot of chunk function_map&#34; /&gt;
&lt;/p&gt;
&lt;p&gt;Although the function might seem complicated at first, it is in fact the same code as we used to create the map, but instead of typing directly the name of the country or the limits for X and Y, we replace them with the arguments &lt;code&gt;country&lt;/code&gt;, &lt;code&gt;x_limits&lt;/code&gt; and &lt;code&gt;y_limits&lt;/code&gt; respectively; in that way all the parts were we had the string &lt;code&gt;&amp;quot;Spain&amp;quot;&lt;/code&gt; we now have the argument &lt;code&gt;country&lt;/code&gt;, and so on. These are the only arguments that we need to change when we want to map a different country. You can define more arguments in case you want to have more possibilities to be editable, for example, we could define an argument &lt;code&gt;country_color&lt;/code&gt; to specify the color we want for the target country. In our case we wanted to keep the same standards for all the maps due to branding reasons and thus, we rather wanted to have the exact same colors and styles for all of our maps.&lt;/p&gt;
&lt;p&gt;There are also some additions on the top before the actual code to make the maps, all the &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; statements that are simply used to validate that the information passed by the user is the info that we actually need to make the function work. If any incorrect argument is passed to the function, we stop the process and write a message of what is wrong using the function &lt;code&gt;stop()&lt;/code&gt;. For the case that no limits of either X or Y are defined, I send a warning message using &lt;code&gt;warning()&lt;/code&gt;. In that case the process continues but we define a &lt;code&gt;theme()&lt;/code&gt; that allows the user to see the country in the context of the worldwide map, with excess of values in the X and Y axes to provide the points of reference and give an idea of where to set the limits. By the end, when we ensure that all the values are fine, we define the final theme that we actually want to apply. About that, probably I should make special mention of &lt;code&gt;!all(grepl(&#39;^-?[0-9.]+$&#39;, c(x_limits, y_limits))))&lt;/code&gt;: it is used to ensure that X and Y limits are of type numeric. See the visualization of the code below together with the help of the function(s) you don&amp;rsquo;t understand for a more detail explanation. Feel free to test the errors and warnings by providing to the function no country names or letters where there should be numbers, etc.&lt;/p&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://blog.rwhitedwarf.com/post/2022/map_any_region_with_ggplot2_part_I/maps_FunctionMap.png&#34; alt=&#34;Code of the function explained&#34; /&gt;
&lt;/p&gt;
&lt;p&gt;The lower part of the function is exactly the same as our first map, replacing the actual values for the arguments. We also have changed the colors for more specific ones. Almost by the end of the function we have added &lt;code&gt;scale_x_continuous(n.breaks = 20)&lt;/code&gt; which will add 20 marks of the X axis scale (same for Y). We want to use it to ensure that, in case the user doesn&amp;rsquo;t have idea of which limit values to choose, it can have a good approach regarding the position of the target country. In case that both limits for X and Y are passed to the function, our other theme will mask this 20 breaks with &lt;code&gt;axis.text.x = element_blank()&lt;/code&gt; and &lt;code&gt;axis.ticks.x = element_blank()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The final line is the test that our function can plot a map other than Spain, in this case I chose Germany. We can basically choose any country included in the &lt;code&gt;maps&lt;/code&gt; package and now make the map with the same standards in one line of R code.&lt;/p&gt;
&lt;h2 id=&#34;final-remarks&#34;&gt;Final remarks&lt;/h2&gt;
&lt;p&gt;Here I am somehow showing one of the methods I use to create functions: I basically write first the code of what I want to achieve and once it does exactly what I want, I wrap it in a function, replacing the arguments that the user will need to modify later. Then I think what could go wrong and create the corresponding warnings an errors. It is a good practice to do that not only for the user to know better how to use the function, but also for yourself, it proves very useful when we need to debug code. Another good practice in R functions is the call to the libraries inside the function using &lt;code&gt;require()&lt;/code&gt;. Even if you are writing many functions that use the same libraries, is good to repeat it on each function, or per script, to make it self contained and again, help yourself in the debugging process. Not long ago I started collaborating in a project where there was no call to the libraries per function, but rather only at the top level when the main action of the program was called. This made almost impossible for me to test and debug code so, the first activity I did as a new member of the team was to spend 2 full working days adding &lt;code&gt;require()&lt;/code&gt; where necessary.&lt;/p&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://blog.rwhitedwarf.com/post/2022/map_any_region_with_ggplot2_part_I/maps_CompareCode.png&#34; alt=&#34;Code of the function explained&#34; /&gt;
&lt;/p&gt;
&lt;p&gt;I hope you get some fun mapping different countries. Because different countries have different sizes and shapes, one way to improve the visuals related to this is by adjusting the ratio, for example, my own map of Germany looks out of shape, but it improves considerably if instead of 1.3 we give a ratio of 1.4, check the documentation to learn more about it.&lt;/p&gt;
&lt;p&gt;Once that we have the basic map, we could add the cities were we want to add data values. Unfortunately, for cities there are many limitations, specially for countries where no special packages has been created to be mapped, and even there, most packages of particular countries don&amp;rsquo;t contain all the cities, especially minor ones. Thus, in our second part I will show how I tackled this problem doing some web scrapping to open street maps.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
