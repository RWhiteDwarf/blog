[{"content":"Introducción El análisis exploratorio de datos (EDA en inglés, \u0026ldquo;Exploratory Data Analysis\u0026rdquo;) es una de las herramientas más útiles en varias áreas de análisis de datos. El concepto de EDA ha sido utilizado popularmente en los últimos años para referirse a los procesos de exploración primaria de un grupo de datos. Por lo tanto, no existe una fórmula o receta para realizar una exploración, sea general o exhaustiva. Una exploración correcta depende de las habilidades del analista tanto para entender los datos como para utilizar las herramientas adecuadas. Este post no pretende ser una explicación detallada de como realizar un EDA, más bien intento compartir una de mis experiencias haciendo haciendo ayuda de la programación funcional.\nLa información que presento aquí son los resultados del primer EDA que realicé cuando decidí cambiar mi carrera hacía el análisis de datos. Es una serie de datos obtenidos del Instituto Nacional de Estadística, Geografía e Informática de México, contiene información sobre la cantidad, expresada en miles de dolares, de las exportaciones por año de cada estado. Me pareció un ejemplo adecuado ya que yo no tengo mucho conocimiento en economía o exportación, por lo tanto este ejemplo no contiene ningún análisis numérico detallado o complicado, si no mas bien una exploración general de los datos obtenidos. Los datos han sido tomados de la pagina oficial de INEGI en formato de excel. El INEGI es una de las bases de datos más importantes de México, su web contiene bases de datos públicas en temas de geografía y estadística. Si estas buscando datos para practicar tus habilidades en R o como analista de datos te recomiendo darle un vistazo. Aquí presento una versión de los datos que yo mismo he arreglado para su uso en R, los cuales pueden ser descargados en formato CSV desde mi repositorio de github INEGI-export.\nEl proceso de EDA resulta útil no sólo para profesionales analistas de datos, si no en un amplio rango de actividades para conocer y entender los datos que se manejan. En muchos casos los análisis de datos incluyen complicadas fórmula matemáticas en grandes series numéricas que no son entendidas, simplemente procesadas y reducidas a pequeños números que representan algo, como medias, rangos, estadísticos, etc. El análisis exploratorio de datos nos permite entender un poco mas que significan esos número, de donde vienen, y que se puede extraer de ellos. Los datos son siempre generados en base a la información, el EDA es una herramienta para entender esa información.\nAnálisis exploratorio (Exploratory Data Analysis, EDA) Vamos a comenzar llamando directamente las librerías o módulos (en R library) que necesitamos para hacer nuestro análisis, y leyendo los archivos CSV en la memoria de R. Esto puede ser realizado conforme se va utilizando, sin embargo es recomendable importar todas las librerías y archivos al inicio de nuestro código o script, para evitar errores o problemas de organización.\nlibrary(tidyverse) library(cowplot) path.to.files \u0026lt;- \u0026quot;https://raw.githubusercontent.com/teotenn/INEGI-export/master/\u0026quot; export.rows \u0026lt;- read_csv(paste0(path.to.files, \u0026quot;exportations_activity_rows.csv\u0026quot;)) export.cols \u0026lt;- read_csv(paste0(path.to.files, \u0026quot;exportations_activity_cols.csv\u0026quot;)) Las librerías son básicamente programas escritos en R que contienen el código necesario para realizar, o más bien llamar ciertas funciones especificas de cada librería. En español son popularmente conocidas como paquetes o módulos. En este caso vamos a utilizar tidyverse y cowplot. La librería cowplot nos va a ayudar a colocar varias gráficas de forma fácil y ordenada en un sólo espacio.\nEn cuanto a la librería tidyverse ofrece enormes ventajas (aunque también pocas desventajas) para el análisis de datos. Al llamar esta librería incluye una serie de librerías que contienen diferentes tipos de herramientas para facilitar y organizar el análisis de datos. En este post vamos a utilizar principalmente:\nggplot2 Que facilita la creación de gráficas con el sistema de capas (The Language of Graphics escrito por Leland Wilkinson, 2000) dplyr que nos ayuda a mandar resultados de un proceso al siguiente utilizando los famosos %\u0026gt;% tibble que facilita la manipulación de tablas, transformando los tradicionales data.frame de R a un formato mas amigable visualmente. Si lo deseas, también podrías llamar estas tres librerías de una por una en lugar de llamar todo el tidyverse de principio. El resultado será el mismo.\nEntre otras desventajas de estos paquetes es que no funcionan muy bien cuando la cantidad de datos es muy grande (miles de millones de filas), en cuyo caso se recomiendan otras herramientas como Data Table que funciona de forma un poco mas similar al tradicional data.frame de R. Más información sobre tidyverse puede ser encontrada en su página oficial, (https://www.tidyverse.org/) o en el e-book R for data science escrito por uno de los creadores de la librería. Un buen libro en español es R para profesionales de los datos.\nOrganizando los datos Lo primero que debemos hacer es organizar los datos a un formato que sea mas amigable con R, y también con nuestras necesidades de análisis. Como ya he mencionado antes, yo manipulé los datos con anterioridad para tenerlos en un formato amigable con R. Por otro lado, algunas variables presentan nombres demasiado largos, por lo que he decididos reducirlos un poco para facilitar mi trabajo.\nEste análisis lo realicé primordialmente en inglés, por lo tanto he decidido mantener el código en inglés por facilidad para mi por un lado, pero también por el beneficio de ser mas amigable con R en general, y de generar nombres mas cortos. Así pues, algunos valores se mantendrán en español y otros han sido traducidos para la manipulación de los datos.\nEl siguiente bloque contiene la traducción de las actividades de exportación, para generar nombres en inglés mas accesibles. Lo primero fue guardar los nombres en español en un vector, para utilizarlos más tarde en la traducción; también generamos un vector del mismo tamaño, con su equivalente en Inglés (en exactamente el mismo orden).\n## Nombres en español en un vector colnames(export.cols) \u0026gt; [1] \u0026quot;state\u0026quot; \u0026gt; [2] \u0026quot;year\u0026quot; \u0026gt; [3] \u0026quot;Exportaciones totales\u0026quot; \u0026gt; [4] \u0026quot;Industria alimentaria\u0026quot; \u0026gt; [5] \u0026quot;Industria de las bebidas y el tabaco\u0026quot; \u0026gt; [6] \u0026quot;Fabricación de insumos textiles y acabado de textiles\u0026quot; \u0026gt; [7] \u0026quot;Fabricación de productos textiles, excepto prendas de vestir\u0026quot; \u0026gt; [8] \u0026quot;Fabricación de prendas de vestir\u0026quot; \u0026gt; [9] \u0026quot;Industria del papel\u0026quot; \u0026gt; [10] \u0026quot;Industria química\u0026quot; \u0026gt; [11] \u0026quot;Industria del plástico y del hule\u0026quot; \u0026gt; [12] \u0026quot;Fabricación de productos a base de minerales no metálicos\u0026quot; \u0026gt; [13] \u0026quot;Industrias metálicas básicas\u0026quot; \u0026gt; [14] \u0026quot;Fabricación de productos metálicos\u0026quot; \u0026gt; [15] \u0026quot;Fabricación de maquinaria y equipo\u0026quot; \u0026gt; [16] \u0026quot;Fabricación de equipo de computación, comunicación, medición y de otros equipos, componentes y accesorios electrónicos\u0026quot; \u0026gt; [17] \u0026quot;Fabricación de equipo de transporte\u0026quot; \u0026gt; [18] \u0026quot;Fabricación de muebles, colchones y persianas\u0026quot; \u0026gt; [19] \u0026quot;Otras industrias manufactureras\u0026quot; \u0026gt; [20] \u0026quot;Subsectores no especificados\u0026quot; \u0026gt; [21] \u0026quot;Minería de minerales metálicos y no metálicos, excepto petróleo y gas\u0026quot; \u0026gt; [22] \u0026quot;Curtido y acabado de cuero y piel, y fabricación de productos de cuero, piel y materiales sucedáneos\u0026quot; \u0026gt; [23] \u0026quot;Industria de la madera\u0026quot; \u0026gt; [24] \u0026quot;Impresión e industrias conexas\u0026quot; \u0026gt; [25] \u0026quot;Fabricación de accesorios, aparatos eléctricos y equipo de generación de energía eléctrica\u0026quot; \u0026gt; [26] \u0026quot;Extracción de petróleo y gas\u0026quot; \u0026gt; [27] \u0026quot;Fabricación de productos derivados del petróleo y del carbón\u0026quot; categorias \u0026lt;- colnames(export.cols)[3:27] ## Equivalentes en inglés activities.en \u0026lt;- c(\u0026quot;Total\u0026quot;, \u0026quot;Food\u0026quot;, \u0026quot;Drinks and tobacco\u0026quot;, \u0026quot;Textiles\u0026quot;, \u0026quot;Textile products\u0026quot;, \u0026quot;Tailoring\u0026quot;, \u0026quot;Paper\u0026quot;, \u0026quot;Chemistry\u0026quot;, \u0026quot;Plastic\u0026quot;, \u0026quot;Minerals based\u0026quot;, \u0026quot;Metal industry\u0026quot;, \u0026quot;Metal products\u0026quot;, \u0026quot;Machinery\u0026quot;, \u0026quot;Electronics\u0026quot;, \u0026quot;Transport equipment\u0026quot;, \u0026quot;Furniture\u0026quot;, \u0026quot;Other manufactures\u0026quot;, \u0026quot;Not specified\u0026quot;, \u0026quot;Mining\u0026quot;, \u0026quot;Leather\u0026quot;, \u0026quot;Wood\u0026quot;, \u0026quot;Printing\u0026quot;, \u0026quot;Electricity\u0026quot;, \u0026quot;Petroleum\u0026quot;, \u0026quot;Petroleum products\u0026quot;) Para cambiar los nombres de las columnas, podemos hacerlo directamente con la función colnames, seleccionando la posición de los valores que queremos cambiar (en este caso, 3 al 27) y colocando ahí los nuevos valores en inglés.\n## Cambio de nombres colnames(export.cols)[3:27] \u0026lt;- activities.en Para cambiar los valores en export.rows vamos a necesitar la conversión de las expresiones en español a las mismas en inglés. Aquí he utilizado herramientas de programación basada en funciones (Functional Programming) para generar primero la función principal para traducir translate. Aquí le estoy diciendo a translate exactamente lo que necesito hacer, sin preocuparme si R puede hacerlo o no. Por ejemplo, utilizo la función equivalent, que no existe en R, pero que, basado en mis expectaciones, debe buscar el equivalente en inglés de la frase en español. Así pues, basado en translatete, vamos llenando los huecos, creando la función equivalent que haga exactamente lo que necesito.\ntranslate \u0026lt;- function(vector.es){ vector.en \u0026lt;- c() for (i in 1:length(vector.es)){ expression.es \u0026lt;- vector.es[i] expression.en \u0026lt;- equivalent(expression.es) ## \u0026quot;equivalent\u0026quot; toma expression.es y regresa el ## equivalente en ingles vector.en \u0026lt;- append(vector.en, expression.en) } vector.en } equivalent \u0026lt;- function(expression.es){ position \u0026lt;- match(expression.es, categorias) expression.en \u0026lt;- activities.en[position] expression.en } ## Probando nuestra nueva función equivalent(\u0026quot;Impresión e industrias conexas\u0026quot;) \u0026gt; [1] \u0026quot;Printing\u0026quot; Como podemos ver, equivalent toma la expresión de nuestro vector en español, y arroja el equivalente que le hemos elegido en inglés.\ntranslate(categorias) \u0026gt; [1] \u0026quot;Total\u0026quot; \u0026quot;Food\u0026quot; \u0026quot;Drinks and tobacco\u0026quot; \u0026gt; [4] \u0026quot;Textiles\u0026quot; \u0026quot;Textile products\u0026quot; \u0026quot;Tailoring\u0026quot; \u0026gt; [7] \u0026quot;Paper\u0026quot; \u0026quot;Chemistry\u0026quot; \u0026quot;Plastic\u0026quot; \u0026gt; [10] \u0026quot;Minerals based\u0026quot; \u0026quot;Metal industry\u0026quot; \u0026quot;Metal products\u0026quot; \u0026gt; [13] \u0026quot;Machinery\u0026quot; \u0026quot;Electronics\u0026quot; \u0026quot;Transport equipment\u0026quot; \u0026gt; [16] \u0026quot;Furniture\u0026quot; \u0026quot;Other manufactures\u0026quot; \u0026quot;Not specified\u0026quot; \u0026gt; [19] \u0026quot;Mining\u0026quot; \u0026quot;Leather\u0026quot; \u0026quot;Wood\u0026quot; \u0026gt; [22] \u0026quot;Printing\u0026quot; \u0026quot;Electricity\u0026quot; \u0026quot;Petroleum\u0026quot; \u0026gt; [25] \u0026quot;Petroleum products\u0026quot; translate toma todos los elementos en el vector, y nos arroja sus equivalentes en inglés. Así pues, para transformar todos los valores en la columna Descripción a su equivalente en inglés he decidido generar una nueva columna, utilizando mi función translate. Esto es muy fácil utilizando mutate\n(export.rows \u0026lt;- mutate(export.rows, Activity = translate(`Descripción`))) \u0026gt; # A tibble: 5,255 × 6 \u0026gt; Código Descripción state year USD Activity \u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026gt; 1 NA Exportaciones totales Aguascalientes 2007 4389841 Total \u0026gt; 2 NA Exportaciones totales Aguascalientes 2008 4456893 Total \u0026gt; 3 NA Exportaciones totales Aguascalientes 2009 3951108 Total \u0026gt; 4 NA Exportaciones totales Aguascalientes 2010 5647929 Total \u0026gt; 5 NA Exportaciones totales Aguascalientes 2011 6051640 Total \u0026gt; 6 NA Exportaciones totales Aguascalientes 2012 6183782 Total \u0026gt; 7 NA Exportaciones totales Aguascalientes 2013 6726207 Total \u0026gt; 8 NA Exportaciones totales Aguascalientes 2014 8466007 Total \u0026gt; 9 NA Exportaciones totales Aguascalientes 2015 8495445 Total \u0026gt; 10 NA Exportaciones totales Aguascalientes 2016 7870962 Total \u0026gt; # … with 5,245 more rows Exploración visual Ahora para empezar formalmente nuestro EDA, vamos a darle un vistazo a los totales por estado, utilizando nuestra tabla export.cols. Aquí utilizamos los famosos pipe %\u0026gt;% que mandan los resultados de un proceso, al siguiente proceso, por ejemplo, si queremos ver los totales por estado, podemos pedirle a R que haga lo siguiente\ntoma la tabla export.cols %\u0026gt;% agrupa los datos por estado (state) %\u0026gt;% redúcelos a la sumatoria del total, nómbrala total export %\u0026gt;% organiza en forma descendente basado en total export %\u0026gt;% muestra en pantalla todo (n = Inf) La versión en R utilizando el paquete dplyr es:\nexport.cols %\u0026gt;% group_by(state) %\u0026gt;% summarise(`total export` = sum(Total)) %\u0026gt;% arrange(desc(`total export`)) %\u0026gt;% print(n = Inf) \u0026gt; # A tibble: 32 × 2 \u0026gt; state `total export` \u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026gt; 1 Chihuahua 466861927 \u0026gt; 2 Baja California 398935507 \u0026gt; 3 Coahuila de Zaragoza 355638907 \u0026gt; 4 Nuevo León 330267052 \u0026gt; 5 Tamaulipas 284435973 \u0026gt; 6 Campeche 264100465 \u0026gt; 7 Jalisco 213931233 \u0026gt; 8 México 188357470 \u0026gt; 9 Sonora 179661021 \u0026gt; 10 Guanajuato 167191962 \u0026gt; 11 Puebla 127934390 \u0026gt; 12 Tabasco 115797563 \u0026gt; 13 San Luis Potosí 94812554 \u0026gt; 14 Querétaro 88633615 \u0026gt; 15 Aguascalientes 79688240 \u0026gt; 16 Veracruz de Ignacio de la Llave 68556313 \u0026gt; 17 Morelos 37397175 \u0026gt; 18 Zacatecas 34010223 \u0026gt; 19 Ciudad de México 32037661 \u0026gt; 20 Hidalgo 19504479 \u0026gt; 21 Durango 17431796 \u0026gt; 22 Yucatán 14496875 \u0026gt; 23 Michoacán de Ocampo 13411397 \u0026gt; 24 Chiapas 13291536 \u0026gt; 25 Tlaxcala 12987607 \u0026gt; 26 Oaxaca 11023551 \u0026gt; 27 Sinaloa 7825439 \u0026gt; 28 Guerrero 5918438 \u0026gt; 29 Colima 2518028 \u0026gt; 30 Baja California Sur 2303491 \u0026gt; 31 Nayarit 1146388 \u0026gt; 32 Quinta Roo 517674 Gracias a la agrupación de tidyverse, podemos utilizar estas herramientas con muchas otras funciones, entre otras, podemos mandar resultados a un gráfico ggplot\n## Visualización export.cols %\u0026gt;% group_by(state) %\u0026gt;% summarise(`total export` = sum(Total)) %\u0026gt;% ggplot() + geom_bar(aes(y = `total export`, x = reorder(state, `total export`, FUN = abs), fill = `total export`), stat = 'identity') + coord_flip() En el bloque anterior comenzamos con algo similar, y mandamos los resultados a ggplot(), así que ya no es necesario especificar dentro de la función ggplot de donde tomar los datos, por lo tanto esta función se queda vacía. geom_bar genera un gráfico de barras, que de forma típica toma los valores numéricos en el eje Y y los valores categóricos en el eje X. Esto lo especificamos dentro de la función aes (por \u0026ldquo;aestetics\u0026rdquo;, o estética). Otra de las ventajas es que podemos llamar funciones dentro de funciones de gráficos ggplot, por ejemplo, en x utilizo la función reorder para ordenar los resultados por los valores de total export, basado en el valor absoluto (FUN = abs). También, dentro de aes he declarado fill = total export para que llene las barras en base a los valores de total export. Es importante no confundir fill con color, el cual cambia simplemente los contornos de las barras. También es importante especificar fill dentro de aes cuando queremos darle un valor basado en nuestros datos categóricos; o bien, se puede colocar fuera de aes para darle un valor constante. stat = 'identity' y coord_flip() nos ayudan a ordenar las barras, y cambiar el eje de las Y por X, respectivamente.\nAhora podemos hacer lo mismo pero por categoría, usando nuestra otra tabla export.rows\nexport.rows %\u0026gt;% filter(Activity != \u0026quot;Total\u0026quot;) %\u0026gt;% group_by(Activity) %\u0026gt;% summarise(Total = sum(USD)) %\u0026gt;% arrange(desc(Total)) %\u0026gt;% print(n = Inf) \u0026gt; # A tibble: 24 × 2 \u0026gt; Activity Total \u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026gt; 1 Transport equipment 1226859499 \u0026gt; 2 Electronics 747959073 \u0026gt; 3 Petroleum 397933968 \u0026gt; 4 Electricity 208582754 \u0026gt; 5 Other manufactures 147915402 \u0026gt; 6 Machinery 136957553 \u0026gt; 7 Chemistry 133570853 \u0026gt; 8 Metal industry 117915995 \u0026gt; 9 Metal products 82889135 \u0026gt; 10 Food 81653585 \u0026gt; 11 Plastic 80126816 \u0026gt; 12 Mining 52953993 \u0026gt; 13 Not specified 51470567 \u0026gt; 14 Tailoring 43913959 \u0026gt; 15 Drinks and tobacco 31059501 \u0026gt; 16 Minerals based 30584505 \u0026gt; 17 Furniture 19883596 \u0026gt; 18 Petroleum products 14565067 \u0026gt; 19 Paper 13876523 \u0026gt; 20 Leather 9863853 \u0026gt; 21 Printing 6915538 \u0026gt; 22 Textiles 6260722 \u0026gt; 23 Textile products 4954252 \u0026gt; 24 Wood 1959275 Para variar un poco y hacerlo mas didáctico, vamos a cambiar algunos detalles, manteniéndolo simple:\nVamos a colocar fill afuera de aes Vamos a cambiar el valor de color para observar la diferencia Vamos a renombrar el eje de las X Vamos a darle un título export.rows %\u0026gt;% filter(Activity != \u0026quot;Total\u0026quot;) %\u0026gt;% group_by(Activity) %\u0026gt;% summarise(Total = sum(USD)) %\u0026gt;% ggplot() + geom_bar(aes(y = Total, x = reorder(Activity, Total, FUN = abs)), fill = \u0026quot;darkblue\u0026quot;, color = \u0026quot;purple\u0026quot;, stat = 'identity') + labs(title = \u0026quot;Exportaciones totales por actividad\u0026quot;, x = \u0026quot;Activity\u0026quot;) + coord_flip() Ahora de manera fácil e intuitiva podemos observar que cambios en el código fueron responsables de que cambios en el gráfico.\nPor último, podemos hacer algo similar con las exportaciones totales por año.\nexport.cols %\u0026gt;% group_by(year) %\u0026gt;% summarise(`total export` = sum(Total)) %\u0026gt;% print(n = Inf) \u0026gt; # A tibble: 12 × 2 \u0026gt; year `total export` \u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026gt; 1 2007 237809741 \u0026gt; 2 2008 257967777 \u0026gt; 3 2009 198234125 \u0026gt; 4 2010 258504747 \u0026gt; 5 2011 299732519 \u0026gt; 6 2012 320014188 \u0026gt; 7 2013 329562705 \u0026gt; 8 2014 347559680 \u0026gt; 9 2015 337170197 \u0026gt; 10 2016 324901419 \u0026gt; 11 2017 351726063 \u0026gt; 12 2018 387442789 Ahora en lugar de hacer un gráfico de barras, vamos a hacer líneas y puntos. Vamos a cambiar otro detalle: en lugar de especificar aes dentro del geometric, que en este caso tendría que escribirse dos veces exactamente lo mismo, uno dentro de geom_line y otro en geom_point, podemos especificarlo dentro de la función principal del gráfico ggplot(), de esta forma los valores que especifiquemos ahí serán tomados como los valores principales, y no necesitamos darle mas detalles a geom_line ni geom_point.\n## Visualization export.rows %\u0026gt;% filter(Activity == \u0026quot;Total\u0026quot;) %\u0026gt;% group_by(year) %\u0026gt;% summarise(Total = sum(USD)) %\u0026gt;% ggplot(aes(x = year, y = Total)) + geom_line() + geom_point() Podemos hacer lo mismo por estado. Aquí, debido a la complejidad de los nombres de algunos estados, he decidido abreviar los nombres de cada estado a sólo 6 letras, usando la función abbreviate\n## Por estado export.rows %\u0026gt;% filter(Activity == \u0026quot;Total\u0026quot;) %\u0026gt;% group_by(year, state) %\u0026gt;% summarise(Total = sum(USD)) %\u0026gt;% ggplot(aes(x = year, y = Total)) + geom_line(aes(colour = abbreviate(state, 6)))+ geom_point(aes(colour = abbreviate(state, 6))) Gracias a abbreviate los nombres de los estados se pueden entender, sin embargo, a pesar de los colores y el texto, es difícil apreciar propiamente 32 líneas (número total de estados en el país).\nPor otro lado nos gustaría ver si cada año fue el mismo estado o la misma actividad produciendo la mayor cantidad de dolares en exportaciones, o si esto cambió con el tiempo. Debido a la complejidad de nuestro gráfico anterior, necesitamos un acercamiento diferente:\n## Principal estado en cada año export.cols %\u0026gt;% group_by(year) %\u0026gt;% filter(Total == max(Total)) %\u0026gt;% select(year, state, Total) %\u0026gt;% arrange(year) \u0026gt; # A tibble: 12 × 3 \u0026gt; # Groups: year [12] \u0026gt; year state Total \u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026gt; 1 2007 Baja California 31858677 \u0026gt; 2 2008 Baja California 32988913 \u0026gt; 3 2009 Baja California 26741828 \u0026gt; 4 2010 Chihuahua 34633881 \u0026gt; 5 2011 Chihuahua 38446014 \u0026gt; 6 2012 Chihuahua 41764861 \u0026gt; 7 2013 Chihuahua 43770979 \u0026gt; 8 2014 Chihuahua 45594451 \u0026gt; 9 2015 Chihuahua 40302945 \u0026gt; 10 2016 Chihuahua 43342067 \u0026gt; 11 2017 Chihuahua 46491551 \u0026gt; 12 2018 Chihuahua 51944047 Los resultados son interesantes: el principal exportador hasta 2009 es Baja California, y después Chihuahua. Sin embargo, si observamos las principales actividades exportadores, tenemos en primer lugar a Campeche hasta 2013 y después es Coahuila. Parece ser que ciertas actividades no tienen mucha diferencia en la cantidad de ingresos entre ellas, y por eso ciertas combinaciones resultan en mayor nivel de exportación para ciertos estados. Por ejemplo, Capeche es el principal exportador de Petroleo, y se mantiene en primer lugar cuando ordenamos por actividad, sin embargo pasa al sexto lugar cuando ordenamos por estado.\n## Activity export.rows %\u0026gt;% filter(Activity != \u0026quot;Total\u0026quot;) %\u0026gt;% group_by(year) %\u0026gt;% filter(USD == max(USD)) %\u0026gt;% arrange(year) %\u0026gt;% select(Activity, state, year) \u0026gt; # A tibble: 12 × 3 \u0026gt; # Groups: year [12] \u0026gt; Activity state year \u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026gt; 1 Petroleum Campeche 2007 \u0026gt; 2 Petroleum Campeche 2008 \u0026gt; 3 Petroleum Campeche 2009 \u0026gt; 4 Petroleum Campeche 2010 \u0026gt; 5 Petroleum Campeche 2011 \u0026gt; 6 Petroleum Campeche 2012 \u0026gt; 7 Petroleum Campeche 2013 \u0026gt; 8 Transport equipment Coahuila de Zaragoza 2014 \u0026gt; 9 Transport equipment Coahuila de Zaragoza 2015 \u0026gt; 10 Transport equipment Coahuila de Zaragoza 2016 \u0026gt; 11 Transport equipment Coahuila de Zaragoza 2017 \u0026gt; 12 Transport equipment Coahuila de Zaragoza 2018 Sería interesante cambiar la manera de analizar los datos y observar los principales exportadores junto con las principales actividades.\nVisualizaciones interactivas utilizando funciones En el área del análisis de datos, el uso de funciones resulta útil en varios casos. Como vimos anteriormente, nuestra función translate nos ayudó a aplicarla en cada elemento de un vector (en este caso, una columna). Este procesos de aplicar una función en todos los elementos de una lista se conoce tradicionalmente en el albur de programación como \u0026ldquo;map\u0026rdquo;. Otra uso importante de funciones personalizadas es para hacer más eficiente el análisis, por ejemplo cuando necesitamos repetir un proceso mas de una vez.\nEn programación se tienen estándares al escribir código sobre no repetirte a ti mismo, y se crean funciones o macros para básicamente cualquier tarea que deba ser repetida al menos una vez. Como analista de datos esto no es estrictamente necesario, sin embargo nos ahorra tiempo y esfuerzo y al mismo tiempo nos ayuda a entender mejor el lenguaje de programación que estamos utilizando para analizar nuestros datos.\nComo ejemplo, supongamos que queremos hacer visualizaciones de las principales actividades por estado, por ejemplo, actividades que generen mas de 5 millones de dolares. Podríamos escribir lo siguiente\nexport.rows %\u0026gt;% filter(Activity != \u0026quot;Total\u0026quot;) %\u0026gt;% group_by(state, Activity) %\u0026gt;% summarise(Total = sum(USD)) %\u0026gt;% filter(state == \u0026quot;Chihuahua\u0026quot; \u0026amp; Total \u0026gt;= 5000000) %\u0026gt;% ggplot() + geom_bar(aes(y = Total, x = reorder(Activity, Total, FUN = abs), fill = Total), stat = 'identity') + coord_flip() + labs(title = \u0026quot;Chihuahua\u0026quot;, y = \u0026quot;Total USD\u0026quot;, x = NULL) + theme(legend.position=\u0026quot;none\u0026quot;) Sin embargo, tendríamos que repetir el mismo bloque de código por cada estado que queremos visualizar, o si queremos cambiar el límite de 5 millones. La mejor opción en este caso es generar una función que nos permita hacer lo mismo cambiando simplemente las variables que queremos. La manera mas fácil es repetir el código anterior dentro de una función, cambiando el nombre \u0026ldquo;Chihuahua\u0026rdquo; por una variable que podamos modificar cada vez que llamemos la función, vamos a llamarla estado. Por otro lado, en lugar de filtrar sólo actividades que producen mas de 5 millones de dolares, vamos a permitir que este filtro también sea interactivo, sin embargo tomando el valor de 5 millones por default.\nVeamos el siguiente bloque para entender mejor.\n## Funcion para ver principal actividad por estado plot_state \u0026lt;- function(estado, USD_min = 5000000){ export.rows %\u0026gt;% filter(Activity != \u0026quot;Total\u0026quot;) %\u0026gt;% group_by(state, Activity) %\u0026gt;% summarise(Total = sum(USD)) %\u0026gt;% filter(state == estado \u0026amp; Total \u0026gt;= USD_min) %\u0026gt;% ggplot() + geom_bar(aes(y = Total, x = reorder(Activity, Total, FUN = abs), fill = Total), stat = 'identity') + coord_flip() + labs(title = estado, y = \u0026quot;Total USD\u0026quot;, x = NULL) + theme(legend.position=\u0026quot;none\u0026quot;) } El nombre de nuestra función es plot_state y lo definimos como cualquier otro objeto en R, utilizando \u0026lt;- y la función function. Dentro de los paréntesis de function debemos colocar nuestras variables, aquellos valores que podrán ser modificados al llamar la función. En este caso definimos estado que nos ayudará a seleccionar el estado a visualizar, y USD_min para definir la cantidad mínima de dolares a visualizar (por ejemplo, si hacemos USD_min = 0 nuestra función graficaría todas las actividades, siempre y cuando produzcan mas de cero). También podemos ver que aquí he definido USD_min = 5000000, esto genera un valor por default, es decir, si llamamos nuestra función plot_state(\u0026quot;Chihuahua\u0026quot;) obtendremos las actividades que producen mas de 5 millones en Chiuahua, sin embargo, si llamamos plot_state(\u0026quot;Chihuahua\u0026quot;, USD_min = 8000) obtendremos todas las actividades que producen mas de 8 mil.\nUna vez definido el nombre y las variables de nuestra función, podemos especificar el cuerpo dentro de corchetes {}, es decir, la función de nuestra función. En este caso podemos observar que el código que forma el cuerpo de la función es exactamente el mismo que utilizamos para visualizar Chihuahua, los únicos cambios son que en el sitio donde habíamos escrito \u0026ldquo;Chihuahua\u0026rdquo; y \u0026ldquo;5000000\u0026rdquo;, ahora están estado y USD_min. Hay dos consideraciones que deben ser tomadas en cuenta al crear una función de este tipo en R: primero que los valores definidos dentro del cuerpo de una función, en este caso estado y USD_min, sólo existen dentro del cuerpo de la función. Si vamos a la consola y tecleamos ls() veremos que estos objetos no existen en la memoria donde estamos trabajando. Otro aspecto importante es que en R, a diferencia de otros lenguajes de programación, una función puede tomar cualquier objeto que exista en la memoria donde es ejecutado. Por ejemplo, en este caso nuestra función utiliza la tabla export.rows. Si esta tabla no existiera (por ejemplo, si no la hemos creado vía read_csv), nuestra función generará un error.\nEs importante entender el proceso de como la ejecución de funciones busca los valores, para no cometer errores. Al ser ejecutada, la función buscará valores de los objetos PRIMERO dentro del cuerpo de la función, y al no encontrarlos, irá a buscarlos a la memoria general o global de R, que es donde estamos trabajando, si tampoco existen aquí, generará un error. Esto significa que si dentro de la función otorgamos un valor diferente a export.rows, la función utilizará su nuevo valor. Veamos un ejemplo:\nprimeros \u0026lt;- function(){ head(export.rows) } primeros() \u0026gt; # A tibble: 6 × 6 \u0026gt; Código Descripción state year USD Activity \u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026gt; 1 NA Exportaciones totales Aguascalientes 2007 4389841 Total \u0026gt; 2 NA Exportaciones totales Aguascalientes 2008 4456893 Total \u0026gt; 3 NA Exportaciones totales Aguascalientes 2009 3951108 Total \u0026gt; 4 NA Exportaciones totales Aguascalientes 2010 5647929 Total \u0026gt; 5 NA Exportaciones totales Aguascalientes 2011 6051640 Total \u0026gt; 6 NA Exportaciones totales Aguascalientes 2012 6183782 Total Generamos una función sin variables, que nos devuelve los primeros valores en export.rows. En este caso, export.rows no existe dentro del cuerpo de la función, por lo tanto R lo busca en la memoria general, encuentra nuestra tabla, y la utiliza. Sin embargo esto podría cambiar, veamos:\nprimeros \u0026lt;- function(){ export.rows \u0026lt;- c(1:100) head(export.rows) } primeros() \u0026gt; [1] 1 2 3 4 5 6 Ahora que le hemos dado un valor a export.rows dentro del cuerpo de la función, el resultado es diferente. Sin embargo, el objeto export.rows en la memoria general no cambió\nhead(export.rows) \u0026gt; # A tibble: 6 × 6 \u0026gt; Código Descripción state year USD Activity \u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026gt; 1 NA Exportaciones totales Aguascalientes 2007 4389841 Total \u0026gt; 2 NA Exportaciones totales Aguascalientes 2008 4456893 Total \u0026gt; 3 NA Exportaciones totales Aguascalientes 2009 3951108 Total \u0026gt; 4 NA Exportaciones totales Aguascalientes 2010 5647929 Total \u0026gt; 5 NA Exportaciones totales Aguascalientes 2011 6051640 Total \u0026gt; 6 NA Exportaciones totales Aguascalientes 2012 6183782 Total En este ejemplo perecería estúpido, sin embargo al generar funciones muy largas, que utilizan objetos que tenemos creados en la memoria, es fácil cometer errores y otorgarle un valor a un objeto que ya existe y que necesitamos dentro de la función. Diferentes lenguajes de programación protegen esto de diferentes maneras, por ejemplo en python, para llamar un objeto de la memoria general dentro de una función, es necesario utilizar el comando global, lo cual le indica que debe buscar este objeto en el ambiente global, y resulta más fácil para nosotros el notar que objetos estamos utilizando desde el ambiente global. En R es importante ser conscientes de nuestros objetos globales y locales.\nContinuando con nuestro EDA, podemos ver que ahora nuestra función facilita la visualización por estado:\nplot_state(\u0026quot;Chihuahua\u0026quot;) Podemos utilizar el paquete cowplot para observar varios estados juntos en un sólo gráfico.\nplot_grid( plot_state(\u0026quot;Chihuahua\u0026quot;) , plot_state(\u0026quot;Baja California\u0026quot;), plot_state(\u0026quot;Coahuila de Zaragoza\u0026quot;), plot_state(\u0026quot;Nuevo León\u0026quot;), plot_state(\u0026quot;Tamaulipas\u0026quot;), plot_state(\u0026quot;Campeche\u0026quot;, USD_min = 10000), ncol = 2) La función plot_grid resulta útil y conveniente, organiza varios gráficos de forma simétrica, podemos especificar el número de columnas ncol o número de filas nrow en las que nuestros gráficos deben ser visualizados.\nA pesar de que cada estado obtiene sus principales ingresos en exportaciones a partir de diferentes actividades, podemos observar que en general, electrodomésticos (Electronics) y Equipo de Transporte (Transport equipment) son las principales actividades. Otras actividades como Maquinaria (Machinery) y metalúrgica (Metal products) también tienen la tendencia de estar entre los primeros lugares. Así pues, es claro que hay una tendencia entre los 5 principales exportadores con el tipo de actividades exportadoras. Solo para el caso de Campeche, en el sexto lugar es diferente: su principal actividad de exportación es Petroleo, la cual no aparece en las otras gráficas entre las principales actividades de exportación. Sin embargo, si observamos las principales actividades a lo largo del tiempo, exportación de petroleo se encuentra en el tercer lugar:\nexport.rows %\u0026gt;% filter(Activity == \u0026quot;Electronics\u0026quot; | Activity == \u0026quot;Transport equipment\u0026quot; | Activity == \u0026quot;Petroleum\u0026quot;) %\u0026gt;% group_by(year, Activity) %\u0026gt;% summarise(`Total per activity` = sum(USD)) %\u0026gt;% ggplot(aes(x = year, y = `Total per activity`)) + geom_line(aes(colour = Activity)) + geom_point(aes(colour = Activity)) Al menos desde 2007, exportación de petroleo genera menos ingresos que exportación de electrodomésticos y equipo de transporte. Otro detalle interesante que es claro en nuestra última gráfica es que a partir de 2009, la exportación en equipo de transporte ha incrementado año con año. Esto explica por que estados donde la principal actividad de exportación es equipo de transporte están en los primeros lugares como exportadores.\nPodemos generar otra función similar a plot_state pero por actividad, plot_activity para observar los principales estados exportadores de petroleo.\n## Funcion para ver principal estado por actividad plot_activity \u0026lt;- function(activity, USD_min = 5000000){ export.cols %\u0026gt;% select(state, year, activity) %\u0026gt;% group_by(state) %\u0026gt;% summarise(Total = sum(!!sym(activity))) %\u0026gt;% filter(Total \u0026gt;= USD_min) %\u0026gt;% ggplot() + geom_bar(aes(y = Total, x = reorder(state, Total, FUN = abs), fill = Total), stat = 'identity') + coord_flip() + labs(title = activity, y = \u0026quot;Total USD\u0026quot;, x = NULL) + theme(legend.position=\u0026quot;none\u0026quot;) } plot_activity(\u0026quot;Petroleum\u0026quot;) Sólo 4 estados exportaron más de 5,000 millones de USD en petroleo.\nplot_grid( plot_state(\u0026quot;Campeche\u0026quot;, USD_min = 1000000), plot_state(\u0026quot;Tabasco\u0026quot;, USD_min = 1000000), plot_state(\u0026quot;Veracruz de Ignacio de la Llave\u0026quot;), plot_state(\u0026quot;Chiapas\u0026quot;, USD_min = 1000000)) Parece ser que la economía de Tabasco, Campeche y Chiapas dependen en alto grado de la extracción de petroleo, diferente a Veracruz, que tiene otras actividades mas fuertes como productos químicos, metalurgia y alimentación.\n","date":"2022-11-29","permalink":"https://blog.rwhitedwarf.com/es/post/eda_inegi_datos/","tags":["ggplot2","R basics","R funciones","R tips","data analysis"],"title":"EDA de datos de INEGI"},{"content":"Acerca de este post. Este es mi primer post en español. Es en realidad la traducción de un post que escribí originalmente en inglés hace un par de meses. Pueden ver el post original aqui. Espero que sea útil para la comunidad hispanohablante de usuarios de R.\nEste post se basa en un trabajo reciente donde mi tarea fue la revisión y depuración de piezas de código pequeñas o simples que pueden resultar en consejos prácticos y rápidos para otros usuarios de R, especialmente principiantes o personas sin mucha experiencia en el uso de R.\nCon ese objetivo en mente, mientras recuperaba un poco de mi tiempo libre y un poco de estabilidad mental, y celebraba mi nuevo puesto como programador en R, decidí crear publicaciones simples pero útiles llamadas mini tutoriales, comenzando con un ejemplo muy simple, incluso tonto, pero útil.\nMini tutorial: Hacer lógico cualquier texto (make_logical_any_string). Una función para hacer lógica cualquier texto en R.\nmake_logical_any_string \u0026lt;- function(texto){ texto \u0026lt;- as.character(texto) resultado_logico \u0026lt;- as.logical(texto) if(is.na(resultado_logico)){resultado_logico \u0026lt;- FALSE} return(resultado_logico) } La función toma cualquier valor, lo convierte en texto (character) y devuelve TRUE SÓLO SI el valor adopta cualquiera de las siguientes formas: \u0026quot;T\u0026quot;, \u0026quot;TRUE\u0026quot;, \u0026quot;true\u0026quot;, \u0026quot;true\u0026quot; o TRUE, el último el valor lógico, no en formato texto.\nLógica de la función La función as.character() convierte cualquier forma de texto \u0026ldquo;true\u0026rdquo; listado arriba en un TRUE lógico. Si el texto es \u0026quot;False\u0026quot; o sus formas equivalentes, la función devolverá FALSE. Si se pasa cualquier otro valor a la función, el resultado será NA. Por lo tanto, necesitamos modificar los resultados cuando se producen NA, ya que necesitamos un resultado de Verdadero/Falso. Así que implementamos if(is.na(resultado_logico)){resultado_logico \u0026lt;- FALSE} que obligará a cualquier otra cadena de texto a devolver FALSE.\nEstamos usando este código para ejecutar scripts de R en la consola que pasa una serie de argumentos para su funcionamiento, algunos de los cuales deben ser \u0026ldquo;TRUE\u0026rdquo; solo cuando se especifica, y \u0026ldquo;FALSE\u0026rdquo; en cualquier otro caso, de ahí el truco de convertir cualquier otro valor a FALSE en lugar de NA.\nAlgo importante a tomar en cuenta es que los argumentos siempre se pasan al script R como texto y, por lo tanto, escribí el ejemplo para esta publicación convirtiendo todo en texto en la primera línea de la función, lo cual no es necesario en nuestro código original ejecutado en el Terminal. De esta forma, si se le pasa algún número a la función, también devolverá FALSE, emulando lo que pasaría si se ingresa un número en la consola. Este comportamiento es diferente para la función as.logical(), que devuelve FALSE si ingresa el valor numérico 0 y TRUE si se ingresa cualquier otro valor numérico.\n","date":"2022-09-18","permalink":"https://blog.rwhitedwarf.com/es/post/minitut_hacer_bool/","tags":["minitutorial","R funciones","R tips"],"title":"Mini tutorial: hacer tipo lógico cualquier texto"}]