<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>R con White Dwarf</title>
    <link>https://blog.rwhitedwarf.com/es/</link>
    <description>Recent content on R con White Dwarf</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Fri, 24 Mar 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.rwhitedwarf.com/es/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Webscrap e iteraciones con R</title>
      <link>https://blog.rwhitedwarf.com/es/post/webscrap_e_iteracion_con_r/</link>
      <pubDate>Fri, 24 Mar 2023 00:00:00 +0000</pubDate>
      
      <guid>https://blog.rwhitedwarf.com/es/post/webscrap_e_iteracion_con_r/</guid>
      <description>&lt;h2 id=&#34;sobre-este-post&#34;&gt;Sobre este post&lt;/h2&gt;
&lt;p&gt;Estamos creando mapas de datos que muestran los cambios durante un período de tiempo para diferentes países y orientado a todo tipo de ciudades. Esto básicamente significa que necesitamos &lt;strong&gt;mapear cualquier región del mundo con R&lt;/strong&gt;. Hoy en día existen todo tipo de paquetes y técnicas para hacerlo. Quiero compartir la estrategia que utilicé con &lt;a href=&#34;https://cran.r-project.org/web/packages/ggplot2/index.html&#34; target=&#34;_blank&#34;&gt;ggplot2&lt;/a&gt; y &lt;a href=&#34;https://cran.r-project.org/web/packages/maps/index.html&#34; target=&#34;_blank&#34;&gt;maps&lt;/a&gt;, utilizando el soporte de &lt;a href=&#34;https://www.openstreetmap.org/&#34; target=&#34;_blank&#34;&gt;Open Street Map&lt;/a&gt; para obtener las coordenadas de las ciudades y finalmente hacerlo interactivo con &lt;a href=&#34;https://shiny.rstudio.com/&#34; target=&#34;_blank&#34;&gt;shiny&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Estas publicaciones comparten mi camino en la creación de la aplicación Shiny. Es un proyecto vivo en el que estoy trabajando actualmente y decidí compartir mis experiencias durante el proceso de creación. Estas publicaciones no son sólo acerca de Shiny apps, si no más bien sobre la creación del paquete detrás, incluyendo temas sobre la generación de funciones, creación de los mapas, clases de objetos, entre otros, incluyendo cualquier tema interesante que aparezca en el camino. Es mi manera de contribuir a la comunidad de R y al mismo tiempo documentar el proyecto en si mismo.&lt;/p&gt;
&lt;p&gt;Pueden encontrar todas las publicaciones en este tema bajo la etiqueta &lt;a href=&#34;https://blog.rwhitedwarf.com/tags/maps-app/&#34; target=&#34;_blank&#34;&gt;maps-app&lt;/a&gt; (incluyendo las versiones en inglés).&lt;/p&gt;
&lt;p&gt;También pueden encontrar el estado actual del proyecto en &lt;a href=&#34;https://github.com/teotenn&#34; target=&#34;_blank&#34;&gt;mi GitHub&lt;/a&gt; repo &lt;a href=&#34;https://github.com/teotenn/mapic&#34; target=&#34;_blank&#34;&gt;mapic&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Este post está escrito originalmente en español, desde el aeropuerto de Amsterdam, de camino a México. Espero que lo disfruten. Siéntanse libres de dejar cualquier tipo de comentario y/o pregunta al final.&lt;/p&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://blog.rwhitedwarf.com/post/2022/map_any_region_with_ggplot2_part_I/maps_DrawingMap.png&#34; alt=&#34;R Maps&#34; /&gt;
&lt;/p&gt;
&lt;h2 id=&#34;motivación&#34;&gt;Motivación&lt;/h2&gt;
&lt;p&gt;Como mencioné en los posts anteriores de la serie, he estado trabajando últimamente en el código para la creación de los mapas y he hecho cambios que incrementan la eficiencia de las funciones, la lectura del código, y facilitan su uso, al mismo tiempo que me permite extender las funciones mas allá de cómo fueron originalmente diseñadas.&lt;/p&gt;
&lt;p&gt;He mencionado en algunas ocasiones que el código evolucionó poco a poco a partir de scripts creados para generar el mapa específico de algún país. Por lo tanto, las primeras funciones son más bien una colección de los pasos utilizados para generar el mapa, atrapados en forma de funciones para automatizar el proceso.&lt;/p&gt;
&lt;p&gt;Por este motivo había querido hacer cambios para adecuar las funciones a paradigmas mas adecuados a la programación funcional, que es el punto fuerte de R. Sin embargo, la prioridad era generar los mapas, así que la mayoría de mi tiempo iba dirigido a la creación de los mapas y el debug del código cuando era necesario. A esto debo agregar que este proyecto es parte de un trabajo voluntario para una ONG, de la cual pasé a ser el director de la división de investigación, lo que me generaba aún mas responsabilidades y trabajo. Y todo como trabajo secundario, separado de mi fuente principal de ingresos (que también esta basada en R).&lt;/p&gt;
&lt;p&gt;Sin embargo, para bien o para mal, 2022 fue un año lleno de cambios y retos para mi y mi familia, lo que me obligó a dejar de lado el proyecto por un tiempo, resignar mi posición como director de la división, y enfocarme únicamente a mi carrera, mi salud y mi familia. Esto resultó en que, al recuperar la estabilidad en mi vida, me encontré con mas tiempo libre y menos obligaciones para re pensar el código y trabajar en ello. Adicionalmente, mi trabajo principal tuvo un giro que fue de la estadística a mas orientado a la programación en R, lo cual me ha dado mas herramientas para mejorar el código, y me ha motivado a retomar viejas lecciones sobre programación funcional y, sobre todo, iteración.&lt;/p&gt;
&lt;p&gt;Esto me permitió mejorar las dos funciones principales: la encargada del webscrapping y la que manda los datos a SQLite. Puedes encontrar las funciones originales en el post anterior &lt;a href=&#34;https://blog.rwhitedwarf.com/es/post/2022/mapa_de_cualquier_region_con_ggplot2_i/&#34; target=&#34;_blank&#34;&gt;Mapa de cualquier región del mundo con R - Parte I: El mapa base&lt;/a&gt; y compararlos con las nuevas funciones mejoradas en este.&lt;/p&gt;
&lt;h2 id=&#34;webscrapp-a-sqlite&#34;&gt;Webscrapp a SQLite&lt;/h2&gt;
&lt;p&gt;La función &lt;code&gt;webscrap_to_sqlite&lt;/code&gt; se encarga de enviar las coordenadas encontradas por Open Street Map a nuestra base de datos. La función como está definida originalmente es poco efectiva, ya que hace cada operación línea por línea. También es muy rígida en la forma en la que dirige los valores de las regiones, tanto su petición a la API como la colocación de los valores en la base de datos, lo que hace cualquier extensión o modificación muy complicada.&lt;/p&gt;
&lt;p&gt;Por lo tanto, es la función que recibió mas cambios, fue prácticamente re escrita desde ceros, haciendo la búsqueda mas eficiente, permitiendo también búsqueda interna de los datos ya almacenados; mas flexible, lidiando con los parámetros de las regiones de forma mas clara; y mas entendible, mejorando el estilo del código.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;webscrap_to_sqlite &amp;lt;- function(db.name,
                               dat,
                               city = &amp;quot;City&amp;quot;,
                               country = &amp;quot;Country&amp;quot;,
                               region = NULL,
                               state = NULL,
                               county = NULL,
                               db_backup_after = 10) {
  ## Cargas las liberarias necesarias
  require(RSQLite)
  require(dplyr)

  ## 1. Conexion a la DB
  con &amp;lt;- dbConnect(drv = SQLite(), dbname = db.name)
  dbExecute(conn = con,
            &amp;quot;CREATE TABLE IF NOT EXISTS orgs
                    (ID INTEGER UNIQUE,
                     City TEXT,
                     Country TEXT, 
                     Region TEXT,
                     State TEXT,
                     County TEXT,
                     osm_name TEXT,
                     lon REAL,
                     lat REAL)&amp;quot;)
  db &amp;lt;- as_tibble(dbReadTable(con, &amp;quot;orgs&amp;quot;))

  ## 2. Filtrado de los datos
  new_coords &amp;lt;- data.frame()
  dat_local &amp;lt;- compare_db_data(db.name, dat)
  df_len &amp;lt;- nrow(dat_local)

  ## 3. Mientras haya filas en DF repetimos:
  if (df_len != 0) {
    ## 3.1 Definir tamaño de la sub-muestra
    dat_local &amp;lt;- dat_local[c(1:db_backup_after), ]
    dat_local &amp;lt;- filter(dat_local, rowSums(is.na(dat_local)) != ncol(dat_local))

    ## 3.2 for loop para el webscrapping
    for (i in 1:nrow(dat_local)) {
      print(paste0(&amp;quot;Searching entry &amp;quot;, dat_local[[&amp;quot;ID&amp;quot;]][i]))
      
      ## 3.3 Abstracción de la info
      rg &amp;lt;- ifelse(is.null(region), &amp;quot;&amp;quot;, dat_local[[region]][i])
      st &amp;lt;- ifelse(is.null(state), &amp;quot;&amp;quot;, dat_local[[state]][i])
      ct &amp;lt;- ifelse(is.null(county), &amp;quot;&amp;quot;, dat_local[[county]][i])
      rcity &amp;lt;- dat_local[[city]][i]
      rcountry &amp;lt;- dat_local[[country]][i]

      ## 3.4 Obtener las coordenadas
      ## 3.4.1. Primero buscamos si ya existen en DB
      search_query &amp;lt;- filter(db, City == rcity, Country == rcountry,
                             Region == rg, State == st, County == ct)
      if (nrow(search_query != 0)) {
        coords &amp;lt;- search_query[1, ]
        coords$ID &amp;lt;- dat_local[[&amp;quot;ID&amp;quot;]][i]
        print(&amp;quot;Found from memory&amp;quot;)
        
        ## 3.4.2 Si aun no existen, busca en OSM API
      } else {
        coords &amp;lt;- coords_from_city(rcity, rcountry,
                                   Region = rg, State = st, County = ct)
        coords &amp;lt;- cbind(ID = dat_local[[&amp;quot;ID&amp;quot;]][i],
                        City = rcity,
                        Country = rcountry,
                        Region = rg,
                        State = st,
                        County = ct,
                        coords)
      }
      new_coords &amp;lt;- rbind(new_coords, coords)
    }

    ## Y envía sólo los nuevos resultados a la DB
    dbWriteTable(con, &amp;quot;orgs&amp;quot;, new_coords, append = TRUE)
    dbDisconnect(con)

    ## 3.4.3 Repetir
    webscrap_to_sqlite(db.name = db.name,
                       dat = dat,
                       city = city,
                       country = country,
                       region = region,
                       state = state,
                       county = county,
                       db_backup_after = db_backup_after)

    ## 4. Terminar la iteracion
  } else {
    db_final &amp;lt;- import_db_as_df(db.name)
    size &amp;lt;- nrow(db_final)
    not_found &amp;lt;- nrow(db_final[is.na(db_final$lat), ])
    message(paste(&amp;quot;Search finished.\n&amp;quot;,
                  size, &amp;quot;entries searched.\n&amp;quot;,
                  not_found, &amp;quot;ENTRIES NOT FOUND&amp;quot;))
  }
}        
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;La función comienza llamando a las librerías necesarias y (1) conectándose a la base de datos, creándola si es necesario. (2) Luego genero dos data frames, uno vacío que almacenará nuevas coordenadas y otro relativo que contiene únicamente los datos que aún no existen en la base de datos. (3) Así pues, mientras haya datos en esta última data frame, la función continuará repitiéndose.&lt;/p&gt;
&lt;p&gt;(3.1) Luego definimos la sub-muestra, que es un sub conjunto de &lt;code&gt;dat_local&lt;/code&gt; del tamaño de &lt;code&gt;db_backup_after&lt;/code&gt; y nos enfocamos únicamente en esta sub-muestra. (3.2) Sobre esa sub muestra hacemos las iteraciones utilizando &lt;code&gt;for&lt;/code&gt; para obtener las coordenadas. Primero (3.3) preparamos la información como strings y después (3.4) buscamos las coordenadas. (3.4.1) Si ya existen en la base de datos lo tomamos de ahí, y si no (3.4.2) se buscan utilizado &lt;code&gt;coords_from_city&lt;/code&gt;. Finalmente, (3.4.3) repetimos todo de nuevo permitiendo a la función llamarse a si misma.&lt;/p&gt;
&lt;p&gt;Dado que en el paso 2 se filtran los datos que aún no están en la base de datos y en 3 se colocan los resultados de nuevas búsquedas en un data frame vacío, la función se llama a sí misma y aplica únicamente para cada sub conjunto de datos. Cuando finalmente &lt;code&gt;compare_db_data&lt;/code&gt; arroja 0 valores por que todos los datos que se ingresaron a la función ya están contenidos en la base de datos, podemos salir de la función. En este caso decidí importar de nuevo los datos desde SQLite para obtener detalles de la búsqueda, y terminar la iteración enviando un mensaje al usuario sobre el total de entradas y la cantidad de las cuales no fueron encontradas.&lt;/p&gt;
&lt;p&gt;Si comparamos esta función con la propuesta en mi post anterior, la función es completamente diferente pero el resultado final es el mismo. Los argumentos utilizados por la función también son los mismo y toman los mismos valores, lo cual evita conflictos para el usuario. El único parámetro nuevo es &lt;code&gt;db_backup_after&lt;/code&gt; que nos permite controlar a cada cuantas filas se realiza la iteración. Un valor mas pequeño significa más iteraciones, lo que resultado en un mayor uso de la memoria local, pero también mayor agilidad para encontrar datos que ya existen en la DB. Por otro lado, un valor mas alto reduce el número de iteraciones pero incrementa el número de conexiones a la API. Por este motivo le he otorgado un valor pre definido de 10. Esto, además de ser un valor balanceado, también reduce la confusión del usuario que podría no estar familiarizado con los cambios.&lt;/p&gt;
&lt;h2 id=&#34;remover-valores-faltantes-de-la-base-de-datos&#34;&gt;Remover valores faltantes de la base de datos&lt;/h2&gt;
&lt;p&gt;En la propuesta anterior, únicamente las coordenadas encontradas eran enviadas a la base de datos, y las no encontradas se ignoraban. En la propuesta presente, todas las entradas se envían a la DB. Por lo tanto, es importante tener alguna opción para remover las entradas no encontradas.&lt;/p&gt;
&lt;p&gt;Para ello generé la función &lt;code&gt;remove_na_from_db&lt;/code&gt;, una función muy simple pero que le otorga al usuario una propuesta remover &lt;code&gt;NA&lt;/code&gt;s automáticamente.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;remove_na_from_db &amp;lt;- function(db.file) {
  require(RSQLite)
  con &amp;lt;- dbConnect(drv = RSQLite::SQLite(), dbname = db.file)
  dbExecute(conn = con,
            &amp;quot;DELETE FROM orgs WHERE lon IS NULL OR trim(lon) = &#39;&#39;;&amp;quot;)
  dbDisconnect(con)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;La función es únicamente una conexión a la base de datos que envía la orden de remover filas donde el campo &lt;code&gt;lon&lt;/code&gt; está vacío, en sintaxis de SQLite. Esto es la manera mas segura, directa y rápida de hacerlo. También podríamos importar los datos de nuevo a R, filtrarlos y enviarlos de nuevo a SQLite, pero esto requeriría mayor uso de la memoria local, mayor cantidad de código y un mayor riesgo ya que requeriría re-escribir la base de datos a SQLite por completo. El poder de la librería &lt;code&gt;RSQLite&lt;/code&gt; (o cualquier otra librería que conecta a R con SQL) está precisamente en la posibilidad de pasar ordenes escritas y ejecutadas directamente en SQL.&lt;/p&gt;
&lt;h2 id=&#34;la-obtención-de-las-coordenadas&#34;&gt;La obtención de las coordenadas&lt;/h2&gt;
&lt;p&gt;La función &lt;code&gt;coords_from_city&lt;/code&gt; también recibió cambios considerables en lectura del código y flexibilidad, y un poco menores en funcionamiento y eficiencia.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;coords_from_city &amp;lt;- function(city = NULL,
                             country_code,
                             region = NULL,
                             state = NULL,
                             county = NULL) {
  require(&amp;quot;RJSONIO&amp;quot;)

  ## 1. Abstracción de regiones para OSM
  CityCoded &amp;lt;- gsub(&amp;quot; &amp;quot;, &amp;quot;%20&amp;quot;, City) 
  CountryCoded &amp;lt;- paste(&amp;quot;&amp;amp;countrycodes=&amp;quot;, CountryTwoLetter, sep = &amp;quot;&amp;quot;)
  extras &amp;lt;- c(city = City, state = State, region = Region, county = County)
  extrasCoded &amp;lt;- &amp;quot;&amp;quot;
  if (!is.null(extras)) {
    for (i in 1:length(extras)) {
      if (extras[i] != &amp;quot;&amp;quot; &amp;amp;&amp;amp; !is.na(extras[i]) &amp;amp;&amp;amp; !grepl(&amp;quot;^\\s*$&amp;quot;, extras[i])) {
        valCoded &amp;lt;- gsub(&amp;quot; &amp;quot;, &amp;quot;%20&amp;quot;, extras[i])
        extrasCoded &amp;lt;- paste0(extrasCoded, &amp;quot;&amp;amp;&amp;quot;, names(extras)[i], &amp;quot;=&amp;quot;, valCoded)
      }
    }
  }

  ## 2. Respuesta
  link &amp;lt;- paste(
    &amp;quot;http://nominatim.openstreetmap.org/search?city=&amp;quot;
  , extrasCoded
  , CountryCoded
  , &amp;quot;&amp;amp;format=json&amp;quot;
  , sep = &amp;quot;&amp;quot;
  )

  response &amp;lt;- try({fromJSON(link)},
                  silent = TRUE)

  if (class(response) == &amp;quot;try-error&amp;quot;) {
    stop(response[1])
  } else if (class(response) == &amp;quot;response&amp;quot;) {
    response_status &amp;lt;- http_status(response)
    if (response_status$category != &amp;quot;Success&amp;quot;) {
      stop(response_status$message)
    }
  } else if (is.list(response)) {

    ## 3. Organización de los resultados
    if (length(response) == 0) {
      message(paste(&amp;quot;No results found for&amp;quot;, extrasCoded))
      coords &amp;lt;- data.frame(&amp;quot;lon&amp;quot; = NA, &amp;quot;lat&amp;quot; = NA, &amp;quot;osm_name&amp;quot; = as.character(NA))
      
    } else if (length(response) == 1) {
      message(paste(&amp;quot;Found&amp;quot;, response[[1]]$display_name))
      coords &amp;lt;- data.frame(
        lon = response[[1]]$lon,
        lat = response[[1]]$lat,
        osm_name = response[[1]]$display_name
      )
      
    } else {
      message(paste(&amp;quot;Several entries found for&amp;quot;, city, country_code))
      coords &amp;lt;- data.frame(
        lon = response[[1]]$lon,
        lat = response[[1]]$lat,
        osm_name = response[[1]]$display_name
      )
    }
    
    ## 4. Salida como data frame
    return(coords)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; Error: &amp;lt;text&amp;gt;:68:0: unexpected end of input
&amp;gt; 66:     return(coords)
&amp;gt; 67: }
&amp;gt;    ^
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;El principal cambio está en la sección 1, en lugar de pasar cada una de las regiones como su propio string y darles formato una por una, las he abstraído todas en un solo vector. Esto reduce la cantidad de código, el uso de memoria, y nos permite incluir la ciudad en la lista, convirtiéndolo también en un valor opcional. La razón por la que las había preparado por separado publicación anterior es simplemente porque la función creció lentamente: al principio solo necesitábamos ciudad, pero luego tuvimos que usar algunos campos adicionales según el país en el que trabajábamos. Para facilitarme las cosas, simplemente agregué cada campo de región según fuera necesario. Ahora que tengo tiempo para trabajar en el código, esta fue la primera función que modifiqué.&lt;/p&gt;
&lt;p&gt;El paso 2 ahora imprime mensajes que nos ayudan a identificar el error cuando se trata de la conexión, al mismo tiempo que detiene el proceso. Ya sea un error local de conexión, o problemas del lado del API, obtendremos un mensaje y el proceso se detendrá, lo cual debe evitar tiempos de espera largos cuando no hay conexión y se está haciendo la búsqueda de muchas localidades.&lt;/p&gt;
&lt;p&gt;El paso 3 cambia un poco la organización de los resultados, devolviendo siempre un data frame con las mismas columnas cuando los resultados no fueron encontrados, pero ahora con los campos vacíos en dicho caso. Esto ayuda a las funciones presentadas anteriormente para llenar la base de datos. Adicionalmente, cuando muchos resultados fueron encontrados, se imprime esta información en pantalla; por ahora es sólo como información. La idea es mantener este espacio para realizar cambios en el futuro que nos permitan seleccionar la opción de manera interactiva. Esto es algo que aún necesito pensar y planear por que, por un lado quiero utilizarlo en una aplicación Shiny, y por otro lado queremos mantener la habilidad de que el web scrapping suceda automáticamente con menor intervención posible.&lt;/p&gt;
&lt;p&gt;Como ya he mencionado antes, estas nuevas funciones también nos permiten realizar búsquedas con el valor de ciudad vacío. Este fue un requisito solicitado en la última versión, ya que algunos usuarios comenzaron a hacer mapas por regiones, mientras que otros, al no encontrar ciudades muy pequeñas, decidieron agrupar los datos por región. Gracias a los cambios realizados en &lt;code&gt;coords_from_city&lt;/code&gt;, la función &lt;code&gt;webscrap_to_sqlite&lt;/code&gt; ahora puede obtener resultados cuando el valor para ciudad es &lt;code&gt;NA&lt;/code&gt;, considerando que se encuentren las coordenadas para la región o el estado. Aquí es importante mencionar que se recomienda utilizar el argumento &lt;code&gt;state&lt;/code&gt; para la búsqueda de regiones, por alguna razón, esto función mejor en la API de OSM. Como ejemplo, la búsqueda &lt;code&gt;coords_from_city(state = &amp;quot;Castilla La Mancha&amp;quot;, country_code = &amp;quot;ES&amp;quot;)&lt;/code&gt; nos arroja los resultados esperados, a pesar de que España no tiene estados; sin embargo si hacemos &lt;code&gt;coords_from_city(region = &amp;quot;Castilla La Mancha&amp;quot;, country_code = &amp;quot;ES&amp;quot;)&lt;/code&gt; nominatim no encuentra los resultados.&lt;/p&gt;
&lt;h2 id=&#34;conclusiones&#34;&gt;Conclusiones&lt;/h2&gt;
&lt;p&gt;Estos cambios han resultado muy importantes para agilizar el proceso de la búsqueda de coordenadas y la automatización de la creación de mapas. Por otro lado, me permitió darle mas estilo al código y mejorar su eficiencia. Ya que mi principal proyecto por ahora es convertirlo en una aplicación Shiny, era importante para mi el mejorar el código y la eficiencia antes de lidiar con los detalles del server. Ya que este es un trabajo reciente que he realizado en los últimos meses, decidí compartirlo de inmediato ahora que tengo fresca la información de los cambios. Espero que pueda a ayudar a mas de uno a hacer código mas abstracto y practicar recursión.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Referencia: Dockerizando shinny apps</title>
      <link>https://blog.rwhitedwarf.com/es/post/referencia_dockerizar_shinny_apps/</link>
      <pubDate>Sat, 11 Feb 2023 00:00:00 +0000</pubDate>
      
      <guid>https://blog.rwhitedwarf.com/es/post/referencia_dockerizar_shinny_apps/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://youtube.com/@AndrewCouch&#34; target=&#34;_blank&#34;&gt;Andrew Couch&lt;/a&gt; tiene un video genial sobre como &lt;a href=&#34;https://youtu.be/ARd5IldVFUs&#34; target=&#34;_blank&#34;&gt;poner una aplicación shiny en docker&lt;/a&gt;. El video está en inglés, pero bien vale la pena. Va desde lo más básico, sin asumir ningún conocimiento de docker, lo cual es la situación de muchos usuarios de R como yo mismo. Últimamente he estado trabajando en unas aplicaciones Shiny y a pesar de que nunca he necesitado de Docker, ya puedo preveer el momento en que esto cambiará, por lo que decidí comenzar a aprender como usarlo. Andrew toca unos puntos muy buenos de cómo la mayoría de tutoriales en la web asumen que el lector ya conoce Docker y van a partir de ahí. A pesar de que esos tutoriales son fáciles de seguir, es difícil entender que estamos haciendo y el por qué. Esto genera mas problemas a futuro para extender y debuggear la aplicación. Andrew comparte su experiencia en busca de información sólida y luego procede a dar el tutorial donde explica las partes básicas, comandos y el código de un archivo Docker.&lt;/p&gt;
&lt;p&gt;También recomienda una entrada de &lt;a href=&#34;https://www.statworx.com/en/content-hub/blog/how-to-dockerize-shinyapps/&#34; target=&#34;_blank&#34;&gt;statworx&lt;/a&gt; (también en inglés) que es claramente la inspiración para su video. La entrada contiene información necesaria para dockerizar tu primera aplicación shiny. El texto es corto y claro, y hace un complemento al video. Si tienes problemas con el inglés, está es la entrada ideal para ti ya que puede ser traducida fácilmente.&lt;/p&gt;
&lt;p&gt;Tal vez intentaré dockerizar alguna aplicación de prueba siguiendo las instrucciones y comparta mi experiencia aquí, siempre y cuando encuentre algo nuevo que agregue valor a los links compartidos. De lo contrario pueden utilizar dichos links como las bases y esperar a mi post de como dockerizar utilizando Guix, que es mi principal objetivo por ahora con el propósito de hacer mi aplicación reproducible. Manténganse en órbita.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>EDA de datos de INEGI</title>
      <link>https://blog.rwhitedwarf.com/es/post/eda_inegi_datos/</link>
      <pubDate>Tue, 29 Nov 2022 00:00:00 +0000</pubDate>
      
      <guid>https://blog.rwhitedwarf.com/es/post/eda_inegi_datos/</guid>
      <description>&lt;h2 id=&#34;introducción&#34;&gt;Introducción&lt;/h2&gt;
&lt;p&gt;El análisis exploratorio de datos (EDA en inglés, &amp;ldquo;Exploratory Data
Analysis&amp;rdquo;) es una de las herramientas más útiles en varias áreas
de análisis de datos. El concepto de EDA ha sido utilizado
popularmente en los últimos años para referirse a los procesos de
exploración primaria de un grupo de datos. Por lo tanto, no existe
una fórmula o receta para realizar una exploración, sea general o
exhaustiva. Una exploración correcta depende de las habilidades del analista tanto
para entender los datos como para utilizar las herramientas
adecuadas. Este post no pretende ser una explicación detallada
de como realizar un EDA, más bien intento compartir una de mis
experiencias haciendo haciendo ayuda de la programación funcional.&lt;/p&gt;
&lt;p&gt;La información que presento aquí son los resultados del primer
EDA que realicé cuando decidí cambiar mi carrera hacía el análisis
de datos. Es una serie de datos obtenidos del Instituto Nacional
de Estadística, Geografía e Informática de México, contiene información sobre
la cantidad, expresada en miles de dolares, de las exportaciones por año de
cada estado. Me pareció un ejemplo adecuado ya que yo no tengo
mucho conocimiento en economía o exportación, por lo tanto este
ejemplo no contiene ningún análisis numérico detallado o complicado,
si no mas bien una exploración general de los datos obtenidos.
Los datos han sido tomados de la pagina oficial de &lt;a href=&#34;https://www.inegi.org.mx/&#34; target=&#34;_blank&#34;&gt;INEGI&lt;/a&gt; en formato
de excel. El INEGI es una de las bases de datos más importantes de México,
su web contiene bases de datos públicas en temas de geografía y
estadística. Si estas buscando datos para practicar tus habilidades
en R o como analista de datos te recomiendo darle un vistazo.
Aquí presento una versión de los datos que yo mismo he arreglado para
su uso en R, los cuales pueden ser descargados en formato CSV
desde mi repositorio de github &lt;a href=&#34;https://github.com/teotenn/INEGI-export&#34; target=&#34;_blank&#34;&gt;INEGI-export&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://blog.rwhitedwarf.com/post/2022/EDA_INEGI_data/INEGI.jpg&#34; alt=&#34;INEGI&#34; /&gt;
&lt;/p&gt;
&lt;p&gt;El proceso de EDA resulta útil no sólo para profesionales analistas
de datos, si no en un amplio rango de actividades para conocer y
entender los datos que se manejan. En muchos casos los análisis de
datos incluyen complicadas fórmula matemáticas en grandes series
numéricas que no son entendidas, simplemente procesadas y reducidas
a pequeños números que representan algo, como medias, rangos,
estadísticos, etc. El análisis exploratorio de datos nos permite
entender un poco mas que significan esos número, de donde vienen,
y que se puede extraer de ellos. Los datos son siempre generados en
base a la información, el EDA es una herramienta para entender esa
información.&lt;/p&gt;
&lt;h2 id=&#34;análisis-exploratorio-exploratory-data-analysis-eda&#34;&gt;Análisis exploratorio (Exploratory Data Analysis, EDA)&lt;/h2&gt;
&lt;p&gt;Vamos a comenzar llamando directamente las librerías o módulos
(en R &lt;code&gt;library&lt;/code&gt;) que necesitamos para hacer nuestro análisis, y
leyendo los archivos CSV en la memoria de R. Esto puede ser
realizado conforme se va utilizando, sin embargo es recomendable
importar todas las librerías y archivos al inicio de nuestro código
o script, para evitar errores o problemas de organización.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;  library(tidyverse)
  library(cowplot)

  path.to.files &amp;lt;- &amp;quot;https://raw.githubusercontent.com/teotenn/INEGI-export/master/&amp;quot;
  export.rows &amp;lt;- read_csv(paste0(path.to.files, &amp;quot;exportations_activity_rows.csv&amp;quot;))
  export.cols &amp;lt;- read_csv(paste0(path.to.files, &amp;quot;exportations_activity_cols.csv&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Las librerías son básicamente programas escritos en R que contienen
el código necesario para realizar, o más bien llamar ciertas funciones especificas
de cada librería. En español son popularmente conocidas como
paquetes o módulos. En este caso vamos a utilizar &lt;code&gt;tidyverse&lt;/code&gt; y
&lt;code&gt;cowplot&lt;/code&gt;. La librería &lt;code&gt;cowplot&lt;/code&gt; nos va a ayudar a colocar varias gráficas de forma
fácil y ordenada en un sólo espacio.&lt;/p&gt;
&lt;p&gt;En cuanto a la librería &lt;code&gt;tidyverse&lt;/code&gt; ofrece enormes ventajas (aunque también
pocas desventajas) para el análisis de datos. Al llamar esta
librería incluye una serie de librerías que contienen diferentes
tipos de herramientas para facilitar y organizar el análisis de
datos. En este post vamos a utilizar principalmente:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ggplot2&lt;/code&gt; Que facilita la creación de gráficas con el sistema de capas (The Language of Graphics escrito por Leland Wilkinson, 2000)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dplyr&lt;/code&gt; que nos ayuda a mandar resultados de un proceso al siguiente utilizando los famosos &lt;code&gt;%&amp;gt;%&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tibble&lt;/code&gt; que facilita la manipulación de tablas, transformando los tradicionales &lt;code&gt;data.frame&lt;/code&gt; de R a un formato mas amigable visualmente.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Si lo deseas, también podrías llamar estas tres librerías de una por una en
lugar de llamar todo el tidyverse de principio. El resultado será el mismo.&lt;/p&gt;
&lt;p&gt;Entre otras desventajas de estos paquetes es que no funcionan
muy bien cuando la cantidad de datos es muy grande (miles de
millones de filas), en cuyo caso se recomiendan otras herramientas
como &lt;a href=&#34;https://cran.r-project.org/web/packages/data.table/vignettes/datatable-intro.html&#34; target=&#34;_blank&#34;&gt;Data Table&lt;/a&gt; que funciona de forma un poco mas similar al tradicional
&lt;code&gt;data.frame&lt;/code&gt; de R. Más información sobre &lt;code&gt;tidyverse&lt;/code&gt; puede ser
encontrada en su página oficial,
(&lt;a href=&#34;https://www.tidyverse.org/&#34; target=&#34;_blank&#34;&gt;https://www.tidyverse.org/&lt;/a&gt;) o en el e-book &lt;a href=&#34;https://r4ds.had.co.nz/&#34; target=&#34;_blank&#34;&gt;R for data science&lt;/a&gt;
escrito por uno de los creadores de la librería. Un buen libro en
español es &lt;a href=&#34;https://www.datanalytics.com/libro_r/index.html&#34; target=&#34;_blank&#34;&gt;R para profesionales de los datos&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;organizando-los-datos&#34;&gt;Organizando los datos&lt;/h3&gt;
&lt;p&gt;Lo primero que debemos hacer es organizar los datos a un formato que sea mas amigable con R, y también con nuestras necesidades de análisis. Como ya he mencionado antes, yo manipulé los datos con anterioridad para tenerlos en un formato amigable con R. Por otro lado, algunas variables presentan nombres demasiado largos, por lo que he decididos reducirlos un poco para facilitar mi trabajo.&lt;/p&gt;
&lt;p&gt;Este análisis lo realicé primordialmente en inglés, por lo tanto
he decidido mantener
el código en inglés por facilidad para mi por un lado, pero también
por el beneficio de ser mas amigable con R en general, y de generar
nombres mas cortos. Así pues, algunos valores se mantendrán en español
y otros han sido traducidos para la manipulación de los datos.&lt;/p&gt;
&lt;p&gt;El siguiente bloque contiene la traducción de las actividades de exportación,
para generar nombres en inglés mas accesibles. Lo
primero fue guardar los nombres en español en un vector, para
utilizarlos más tarde en la traducción; también generamos un vector
del mismo tamaño, con su equivalente en Inglés (en exactamente el mismo orden).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;   ## Nombres en español en un vector
   colnames(export.cols)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;  [1] &amp;quot;state&amp;quot;                                                                                                                 
&amp;gt;  [2] &amp;quot;year&amp;quot;                                                                                                                  
&amp;gt;  [3] &amp;quot;Exportaciones totales&amp;quot;                                                                                                 
&amp;gt;  [4] &amp;quot;Industria alimentaria&amp;quot;                                                                                                 
&amp;gt;  [5] &amp;quot;Industria de las bebidas y el tabaco&amp;quot;                                                                                  
&amp;gt;  [6] &amp;quot;Fabricación de insumos textiles y acabado de textiles&amp;quot;                                                                 
&amp;gt;  [7] &amp;quot;Fabricación de productos textiles, excepto prendas de vestir&amp;quot;                                                          
&amp;gt;  [8] &amp;quot;Fabricación de prendas de vestir&amp;quot;                                                                                      
&amp;gt;  [9] &amp;quot;Industria del papel&amp;quot;                                                                                                   
&amp;gt; [10] &amp;quot;Industria química&amp;quot;                                                                                                     
&amp;gt; [11] &amp;quot;Industria del plástico y del hule&amp;quot;                                                                                     
&amp;gt; [12] &amp;quot;Fabricación de productos a base de minerales no metálicos&amp;quot;                                                             
&amp;gt; [13] &amp;quot;Industrias metálicas básicas&amp;quot;                                                                                          
&amp;gt; [14] &amp;quot;Fabricación de productos metálicos&amp;quot;                                                                                    
&amp;gt; [15] &amp;quot;Fabricación de maquinaria y equipo&amp;quot;                                                                                    
&amp;gt; [16] &amp;quot;Fabricación de equipo de computación, comunicación, medición y de otros equipos, componentes y accesorios electrónicos&amp;quot;
&amp;gt; [17] &amp;quot;Fabricación de equipo de transporte&amp;quot;                                                                                   
&amp;gt; [18] &amp;quot;Fabricación de muebles, colchones y persianas&amp;quot;                                                                         
&amp;gt; [19] &amp;quot;Otras industrias manufactureras&amp;quot;                                                                                       
&amp;gt; [20] &amp;quot;Subsectores no especificados&amp;quot;                                                                                          
&amp;gt; [21] &amp;quot;Minería de minerales metálicos y no metálicos, excepto petróleo y gas&amp;quot;                                                 
&amp;gt; [22] &amp;quot;Curtido y acabado de cuero y piel, y fabricación de productos de cuero, piel y materiales sucedáneos&amp;quot;                  
&amp;gt; [23] &amp;quot;Industria de la madera&amp;quot;                                                                                                
&amp;gt; [24] &amp;quot;Impresión e industrias conexas&amp;quot;                                                                                        
&amp;gt; [25] &amp;quot;Fabricación de accesorios, aparatos eléctricos y equipo de generación de energía eléctrica&amp;quot;                            
&amp;gt; [26] &amp;quot;Extracción de petróleo y gas&amp;quot;                                                                                          
&amp;gt; [27] &amp;quot;Fabricación de productos derivados del petróleo y del carbón&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;   categorias &amp;lt;- colnames(export.cols)[3:27]

   ## Equivalentes en inglés 
   activities.en &amp;lt;- c(&amp;quot;Total&amp;quot;, &amp;quot;Food&amp;quot;, &amp;quot;Drinks and tobacco&amp;quot;,
                   &amp;quot;Textiles&amp;quot;, &amp;quot;Textile products&amp;quot;, &amp;quot;Tailoring&amp;quot;,
                   &amp;quot;Paper&amp;quot;, &amp;quot;Chemistry&amp;quot;, &amp;quot;Plastic&amp;quot;,
                   &amp;quot;Minerals based&amp;quot;, &amp;quot;Metal industry&amp;quot;, &amp;quot;Metal products&amp;quot;,
                   &amp;quot;Machinery&amp;quot;, &amp;quot;Electronics&amp;quot;, &amp;quot;Transport equipment&amp;quot;,
                   &amp;quot;Furniture&amp;quot;, &amp;quot;Other manufactures&amp;quot;, &amp;quot;Not specified&amp;quot;,
                   &amp;quot;Mining&amp;quot;, &amp;quot;Leather&amp;quot;, &amp;quot;Wood&amp;quot;,
                   &amp;quot;Printing&amp;quot;, &amp;quot;Electricity&amp;quot;, &amp;quot;Petroleum&amp;quot;,
                   &amp;quot;Petroleum products&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Para cambiar los nombres de las columnas, podemos hacerlo
directamente con la función &lt;code&gt;colnames&lt;/code&gt;, seleccionando la posición
de los valores que queremos cambiar (en este caso, 3 al 27) y
colocando ahí los nuevos valores en inglés.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;   ## Cambio de nombres
   colnames(export.cols)[3:27] &amp;lt;- activities.en
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Para cambiar los valores en &lt;code&gt;export.rows&lt;/code&gt; vamos a necesitar la
conversión de las expresiones en español a las mismas en inglés.
Aquí he utilizado herramientas de programación basada en funciones
(Functional Programming) para generar primero la función
principal para traducir &lt;code&gt;translate&lt;/code&gt;. Aquí le estoy diciendo a
&lt;code&gt;translate&lt;/code&gt; exactamente lo que necesito hacer, sin preocuparme si
R puede hacerlo o no. Por ejemplo, utilizo la función &lt;code&gt;equivalent&lt;/code&gt;,
que no existe en R, pero que, basado en mis expectaciones, debe
buscar el equivalente en inglés de la frase en español. Así pues,
basado en &lt;code&gt;translatete&lt;/code&gt;, vamos llenando los huecos, creando la
función &lt;code&gt;equivalent&lt;/code&gt; que haga exactamente lo que necesito.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;   translate &amp;lt;- function(vector.es){
    vector.en &amp;lt;- c()
    for (i in 1:length(vector.es)){
        expression.es &amp;lt;- vector.es[i]
        expression.en &amp;lt;- equivalent(expression.es)
        ## &amp;quot;equivalent&amp;quot; toma expression.es y regresa el
        ## equivalente en ingles
        vector.en &amp;lt;- append(vector.en, expression.en)
    }
    vector.en
   }
   
  equivalent &amp;lt;- function(expression.es){
      position &amp;lt;- match(expression.es, categorias)
      expression.en &amp;lt;- activities.en[position]
      expression.en
  }

## Probando nuestra nueva función
   equivalent(&amp;quot;Impresión e industrias conexas&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; [1] &amp;quot;Printing&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Como podemos ver, &lt;code&gt;equivalent&lt;/code&gt; toma la expresión de nuestro vector
en español, y arroja el equivalente que le hemos elegido en inglés.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;   translate(categorias)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;  [1] &amp;quot;Total&amp;quot;               &amp;quot;Food&amp;quot;                &amp;quot;Drinks and tobacco&amp;quot; 
&amp;gt;  [4] &amp;quot;Textiles&amp;quot;            &amp;quot;Textile products&amp;quot;    &amp;quot;Tailoring&amp;quot;          
&amp;gt;  [7] &amp;quot;Paper&amp;quot;               &amp;quot;Chemistry&amp;quot;           &amp;quot;Plastic&amp;quot;            
&amp;gt; [10] &amp;quot;Minerals based&amp;quot;      &amp;quot;Metal industry&amp;quot;      &amp;quot;Metal products&amp;quot;     
&amp;gt; [13] &amp;quot;Machinery&amp;quot;           &amp;quot;Electronics&amp;quot;         &amp;quot;Transport equipment&amp;quot;
&amp;gt; [16] &amp;quot;Furniture&amp;quot;           &amp;quot;Other manufactures&amp;quot;  &amp;quot;Not specified&amp;quot;      
&amp;gt; [19] &amp;quot;Mining&amp;quot;              &amp;quot;Leather&amp;quot;             &amp;quot;Wood&amp;quot;               
&amp;gt; [22] &amp;quot;Printing&amp;quot;            &amp;quot;Electricity&amp;quot;         &amp;quot;Petroleum&amp;quot;          
&amp;gt; [25] &amp;quot;Petroleum products&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;translate&lt;/code&gt; toma todos los elementos en el vector, y nos arroja sus
equivalentes en inglés. Así pues, para transformar todos los
valores en la columna &lt;code&gt;Descripción&lt;/code&gt; a su equivalente en inglés he
decidido generar una nueva columna, utilizando mi función
&lt;code&gt;translate&lt;/code&gt;. Esto es muy fácil utilizando &lt;code&gt;mutate&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;  (export.rows &amp;lt;- mutate(export.rows,
                         Activity = translate(`Descripción`)))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; # A tibble: 5,255 × 6
&amp;gt;    Código Descripción           state           year     USD Activity
&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;                 &amp;lt;chr&amp;gt;          &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;   
&amp;gt;  1     NA Exportaciones totales Aguascalientes  2007 4389841 Total   
&amp;gt;  2     NA Exportaciones totales Aguascalientes  2008 4456893 Total   
&amp;gt;  3     NA Exportaciones totales Aguascalientes  2009 3951108 Total   
&amp;gt;  4     NA Exportaciones totales Aguascalientes  2010 5647929 Total   
&amp;gt;  5     NA Exportaciones totales Aguascalientes  2011 6051640 Total   
&amp;gt;  6     NA Exportaciones totales Aguascalientes  2012 6183782 Total   
&amp;gt;  7     NA Exportaciones totales Aguascalientes  2013 6726207 Total   
&amp;gt;  8     NA Exportaciones totales Aguascalientes  2014 8466007 Total   
&amp;gt;  9     NA Exportaciones totales Aguascalientes  2015 8495445 Total   
&amp;gt; 10     NA Exportaciones totales Aguascalientes  2016 7870962 Total   
&amp;gt; # … with 5,245 more rows
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;exploración-visual&#34;&gt;Exploración visual&lt;/h3&gt;
&lt;p&gt;Ahora para empezar formalmente nuestro EDA, vamos a darle un vistazo
a los totales por estado, utilizando nuestra tabla &lt;code&gt;export.cols&lt;/code&gt;.
Aquí utilizamos los famosos pipe &lt;code&gt;%&amp;gt;%&lt;/code&gt; que mandan los resultados
de un proceso, al siguiente proceso, por ejemplo, si queremos ver
los totales por estado, podemos pedirle a R que haga lo siguiente&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   toma la tabla export.cols %&amp;gt;%
      agrupa los datos por estado (state) %&amp;gt;%
      redúcelos a la sumatoria del total, nómbrala total export %&amp;gt;%
      organiza en forma descendente basado en total export %&amp;gt;%
      muestra en pantalla todo (n = Inf)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;La versión en R utilizando el paquete &lt;code&gt;dplyr&lt;/code&gt; es:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;export.cols %&amp;gt;%
    group_by(state) %&amp;gt;%
    summarise(`total export` = sum(Total)) %&amp;gt;%
    arrange(desc(`total export`)) %&amp;gt;%
    print(n = Inf)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; # A tibble: 32 × 2
&amp;gt;    state                           `total export`
&amp;gt;    &amp;lt;chr&amp;gt;                                    &amp;lt;dbl&amp;gt;
&amp;gt;  1 Chihuahua                            466861927
&amp;gt;  2 Baja California                      398935507
&amp;gt;  3 Coahuila de Zaragoza                 355638907
&amp;gt;  4 Nuevo León                           330267052
&amp;gt;  5 Tamaulipas                           284435973
&amp;gt;  6 Campeche                             264100465
&amp;gt;  7 Jalisco                              213931233
&amp;gt;  8 México                               188357470
&amp;gt;  9 Sonora                               179661021
&amp;gt; 10 Guanajuato                           167191962
&amp;gt; 11 Puebla                               127934390
&amp;gt; 12 Tabasco                              115797563
&amp;gt; 13 San Luis Potosí                       94812554
&amp;gt; 14 Querétaro                             88633615
&amp;gt; 15 Aguascalientes                        79688240
&amp;gt; 16 Veracruz de Ignacio de la Llave       68556313
&amp;gt; 17 Morelos                               37397175
&amp;gt; 18 Zacatecas                             34010223
&amp;gt; 19 Ciudad de México                      32037661
&amp;gt; 20 Hidalgo                               19504479
&amp;gt; 21 Durango                               17431796
&amp;gt; 22 Yucatán                               14496875
&amp;gt; 23 Michoacán de Ocampo                   13411397
&amp;gt; 24 Chiapas                               13291536
&amp;gt; 25 Tlaxcala                              12987607
&amp;gt; 26 Oaxaca                                11023551
&amp;gt; 27 Sinaloa                                7825439
&amp;gt; 28 Guerrero                               5918438
&amp;gt; 29 Colima                                 2518028
&amp;gt; 30 Baja California Sur                    2303491
&amp;gt; 31 Nayarit                                1146388
&amp;gt; 32 Quinta Roo                              517674
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Gracias a la agrupación de tidyverse, podemos utilizar estas
herramientas con muchas otras funciones, entre otras, podemos
mandar resultados a un gráfico &lt;code&gt;ggplot&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;   ## Visualización
  export.cols %&amp;gt;%
      group_by(state) %&amp;gt;%
      summarise(`total export` = sum(Total)) %&amp;gt;%
      ggplot() +
      geom_bar(aes(y = `total export`,
                   x = reorder(state, `total export`, FUN = abs),
                   fill = `total export`),
               stat = &#39;identity&#39;) +
      coord_flip()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://blog.rwhitedwarf.com/post/2022/EDA_INEGI_data/primer-ggplot-1.png&#34; alt=&#34;plot of chunk primer-ggplot&#34; /&gt;
&lt;/p&gt;
&lt;p&gt;En el bloque anterior comenzamos con algo similar, y mandamos los
resultados a &lt;code&gt;ggplot()&lt;/code&gt;, así que ya no es necesario especificar
dentro de la función &lt;code&gt;ggplot&lt;/code&gt; de donde tomar los datos, por lo
tanto esta función se queda vacía. &lt;code&gt;geom_bar&lt;/code&gt; genera un gráfico de barras,
que de forma típica toma los valores numéricos en el eje Y y los
valores categóricos en el eje X. Esto lo especificamos dentro de
la función &lt;code&gt;aes&lt;/code&gt; (por &amp;ldquo;aestetics&amp;rdquo;, o estética). Otra de las ventajas es que podemos llamar funciones dentro de funciones de gráficos
ggplot, por ejemplo, en &lt;code&gt;x&lt;/code&gt; utilizo la función &lt;code&gt;reorder&lt;/code&gt; para
ordenar los resultados por los valores de &lt;code&gt;total export&lt;/code&gt;, basado
en el valor absoluto (&lt;code&gt;FUN = abs&lt;/code&gt;). También, dentro de &lt;code&gt;aes&lt;/code&gt; he
declarado &lt;code&gt;fill = total export&lt;/code&gt; para que llene las barras en base
a los valores de &lt;code&gt;total export&lt;/code&gt;. Es importante no confundir &lt;code&gt;fill&lt;/code&gt;
con &lt;code&gt;color&lt;/code&gt;, el cual cambia simplemente los contornos de las
barras. También es importante especificar &lt;code&gt;fill&lt;/code&gt; dentro de &lt;code&gt;aes&lt;/code&gt;
cuando queremos darle un valor basado en nuestros datos categóricos; o bien,
se puede colocar fuera de &lt;code&gt;aes&lt;/code&gt; para darle un valor constante.
&lt;code&gt;stat = &#39;identity&#39;&lt;/code&gt; y &lt;code&gt;coord_flip()&lt;/code&gt; nos ayudan a ordenar las
barras, y cambiar el eje de las Y por X, respectivamente.&lt;/p&gt;
&lt;p&gt;Ahora podemos hacer lo mismo pero por categoría,
usando nuestra otra tabla &lt;code&gt;export.rows&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;export.rows %&amp;gt;%
    filter(Activity != &amp;quot;Total&amp;quot;) %&amp;gt;%
    group_by(Activity) %&amp;gt;%
    summarise(Total = sum(USD)) %&amp;gt;%
    arrange(desc(Total)) %&amp;gt;%
    print(n = Inf)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; # A tibble: 24 × 2
&amp;gt;    Activity                 Total
&amp;gt;    &amp;lt;chr&amp;gt;                    &amp;lt;dbl&amp;gt;
&amp;gt;  1 Transport equipment 1226859499
&amp;gt;  2 Electronics          747959073
&amp;gt;  3 Petroleum            397933968
&amp;gt;  4 Electricity          208582754
&amp;gt;  5 Other manufactures   147915402
&amp;gt;  6 Machinery            136957553
&amp;gt;  7 Chemistry            133570853
&amp;gt;  8 Metal industry       117915995
&amp;gt;  9 Metal products        82889135
&amp;gt; 10 Food                  81653585
&amp;gt; 11 Plastic               80126816
&amp;gt; 12 Mining                52953993
&amp;gt; 13 Not specified         51470567
&amp;gt; 14 Tailoring             43913959
&amp;gt; 15 Drinks and tobacco    31059501
&amp;gt; 16 Minerals based        30584505
&amp;gt; 17 Furniture             19883596
&amp;gt; 18 Petroleum products    14565067
&amp;gt; 19 Paper                 13876523
&amp;gt; 20 Leather                9863853
&amp;gt; 21 Printing               6915538
&amp;gt; 22 Textiles               6260722
&amp;gt; 23 Textile products       4954252
&amp;gt; 24 Wood                   1959275
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Para variar un poco y hacerlo mas didáctico, vamos a cambiar
algunos detalles, manteniéndolo simple:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Vamos a colocar &lt;code&gt;fill&lt;/code&gt; afuera de &lt;code&gt;aes&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Vamos a cambiar el valor de &lt;code&gt;color&lt;/code&gt; para observar la diferencia&lt;/li&gt;
&lt;li&gt;Vamos a renombrar el eje de las X&lt;/li&gt;
&lt;li&gt;Vamos a darle un título&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;export.rows %&amp;gt;%
    filter(Activity != &amp;quot;Total&amp;quot;) %&amp;gt;%
    group_by(Activity) %&amp;gt;%
    summarise(Total = sum(USD)) %&amp;gt;%
    ggplot() +
    geom_bar(aes(y = Total,
                 x = reorder(Activity, Total, FUN = abs)),
             fill = &amp;quot;darkblue&amp;quot;,
             color = &amp;quot;purple&amp;quot;,
             stat = &#39;identity&#39;) +
    labs(title = &amp;quot;Exportaciones totales por actividad&amp;quot;,
         x = &amp;quot;Activity&amp;quot;) +
    coord_flip()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://blog.rwhitedwarf.com/post/2022/EDA_INEGI_data/new-plot-1.png&#34; alt=&#34;plot of chunk new-plot&#34; /&gt;
&lt;/p&gt;
&lt;p&gt;Ahora de manera fácil e intuitiva podemos observar que cambios
en el código fueron responsables de que cambios en el gráfico.&lt;/p&gt;
&lt;p&gt;Por último, podemos hacer algo similar con las exportaciones
totales por año.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;export.cols %&amp;gt;%
    group_by(year) %&amp;gt;%
    summarise(`total export` = sum(Total)) %&amp;gt;%
    print(n = Inf)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; # A tibble: 12 × 2
&amp;gt;     year `total export`
&amp;gt;    &amp;lt;dbl&amp;gt;          &amp;lt;dbl&amp;gt;
&amp;gt;  1  2007      237809741
&amp;gt;  2  2008      257967777
&amp;gt;  3  2009      198234125
&amp;gt;  4  2010      258504747
&amp;gt;  5  2011      299732519
&amp;gt;  6  2012      320014188
&amp;gt;  7  2013      329562705
&amp;gt;  8  2014      347559680
&amp;gt;  9  2015      337170197
&amp;gt; 10  2016      324901419
&amp;gt; 11  2017      351726063
&amp;gt; 12  2018      387442789
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ahora en lugar de hacer un gráfico de barras, vamos a hacer líneas
y puntos. Vamos a cambiar otro detalle: en lugar de especificar
&lt;code&gt;aes&lt;/code&gt; dentro del geometric, que en este caso tendría que escribirse dos
veces exactamente lo mismo, uno dentro de &lt;code&gt;geom_line&lt;/code&gt; y otro en &lt;code&gt;geom_point&lt;/code&gt;,
podemos especificarlo dentro de la función principal del gráfico
&lt;code&gt;ggplot()&lt;/code&gt;, de esta forma los valores que especifiquemos ahí serán
tomados como los valores principales, y no necesitamos darle mas
detalles a &lt;code&gt;geom_line&lt;/code&gt; ni &lt;code&gt;geom_point&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;   ## Visualization
export.rows %&amp;gt;%
    filter(Activity == &amp;quot;Total&amp;quot;) %&amp;gt;%
    group_by(year) %&amp;gt;%
    summarise(Total = sum(USD)) %&amp;gt;%
    ggplot(aes(x = year, y = Total)) +
    geom_line() +
    geom_point() 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://blog.rwhitedwarf.com/post/2022/EDA_INEGI_data/ggplot-detailed-1.png&#34; alt=&#34;plot of chunk ggplot-detailed&#34; /&gt;
&lt;/p&gt;
&lt;p&gt;Podemos hacer lo mismo por estado. Aquí, debido a la complejidad de
los nombres de algunos estados, he decidido abreviar los nombres
de cada estado a sólo 6 letras, usando la función &lt;code&gt;abbreviate&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;   ## Por estado
export.rows %&amp;gt;%
    filter(Activity == &amp;quot;Total&amp;quot;) %&amp;gt;%
    group_by(year, state) %&amp;gt;%
    summarise(Total = sum(USD)) %&amp;gt;%
    ggplot(aes(x = year, y = Total)) +
    geom_line(aes(colour = abbreviate(state, 6)))+
    geom_point(aes(colour = abbreviate(state, 6)))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://blog.rwhitedwarf.com/post/2022/EDA_INEGI_data/abbreviate-1.png&#34; alt=&#34;plot of chunk abbreviate&#34; /&gt;
&lt;/p&gt;
&lt;p&gt;Gracias a &lt;code&gt;abbreviate&lt;/code&gt; los nombres de los estados se pueden
entender, sin embargo, a pesar de los colores y el texto, es
difícil apreciar propiamente 32 líneas (número total de estados en el país).&lt;/p&gt;
&lt;p&gt;Por otro lado nos gustaría ver si cada año fue el mismo estado o
la misma
actividad produciendo la mayor cantidad de dolares en exportaciones, o
si esto cambió con el tiempo. Debido a la complejidad de nuestro
gráfico anterior, necesitamos un acercamiento diferente:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;   ## Principal estado en cada año
export.cols %&amp;gt;%
    group_by(year) %&amp;gt;%
    filter(Total == max(Total)) %&amp;gt;%
    select(year, state, Total) %&amp;gt;%
    arrange(year)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; # A tibble: 12 × 3
&amp;gt; # Groups:   year [12]
&amp;gt;     year state              Total
&amp;gt;    &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;              &amp;lt;dbl&amp;gt;
&amp;gt;  1  2007 Baja California 31858677
&amp;gt;  2  2008 Baja California 32988913
&amp;gt;  3  2009 Baja California 26741828
&amp;gt;  4  2010 Chihuahua       34633881
&amp;gt;  5  2011 Chihuahua       38446014
&amp;gt;  6  2012 Chihuahua       41764861
&amp;gt;  7  2013 Chihuahua       43770979
&amp;gt;  8  2014 Chihuahua       45594451
&amp;gt;  9  2015 Chihuahua       40302945
&amp;gt; 10  2016 Chihuahua       43342067
&amp;gt; 11  2017 Chihuahua       46491551
&amp;gt; 12  2018 Chihuahua       51944047
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Los resultados son interesantes: el principal exportador hasta 2009
es Baja California, y después Chihuahua. Sin embargo, si observamos
las principales actividades exportadores, tenemos en primer lugar
a Campeche hasta 2013 y después  es Coahuila. Parece ser que
ciertas actividades no tienen mucha diferencia en la cantidad de
ingresos entre ellas, y por eso ciertas combinaciones resultan
en mayor nivel de exportación para ciertos estados. Por ejemplo,
Capeche es el principal exportador de Petroleo, y se mantiene en
primer lugar cuando ordenamos por actividad, sin embargo pasa al
sexto lugar cuando ordenamos por estado.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;## Activity
export.rows %&amp;gt;%
    filter(Activity != &amp;quot;Total&amp;quot;) %&amp;gt;%
    group_by(year) %&amp;gt;%
    filter(USD == max(USD)) %&amp;gt;%
    arrange(year) %&amp;gt;%
    select(Activity, state, year)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; # A tibble: 12 × 3
&amp;gt; # Groups:   year [12]
&amp;gt;    Activity            state                 year
&amp;gt;    &amp;lt;chr&amp;gt;               &amp;lt;chr&amp;gt;                &amp;lt;dbl&amp;gt;
&amp;gt;  1 Petroleum           Campeche              2007
&amp;gt;  2 Petroleum           Campeche              2008
&amp;gt;  3 Petroleum           Campeche              2009
&amp;gt;  4 Petroleum           Campeche              2010
&amp;gt;  5 Petroleum           Campeche              2011
&amp;gt;  6 Petroleum           Campeche              2012
&amp;gt;  7 Petroleum           Campeche              2013
&amp;gt;  8 Transport equipment Coahuila de Zaragoza  2014
&amp;gt;  9 Transport equipment Coahuila de Zaragoza  2015
&amp;gt; 10 Transport equipment Coahuila de Zaragoza  2016
&amp;gt; 11 Transport equipment Coahuila de Zaragoza  2017
&amp;gt; 12 Transport equipment Coahuila de Zaragoza  2018
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Sería interesante cambiar la manera de analizar los datos y
observar los principales exportadores junto con las principales
actividades.&lt;/p&gt;
&lt;h2 id=&#34;visualizaciones-interactivas-utilizando-funciones&#34;&gt;Visualizaciones interactivas utilizando funciones&lt;/h2&gt;
&lt;p&gt;En el área del análisis de datos, el uso de funciones resulta útil
en varios casos. Como vimos anteriormente, nuestra función
&lt;code&gt;translate&lt;/code&gt; nos ayudó a aplicarla en cada elemento de un vector
(en este caso, una columna). Este procesos de aplicar una función
en todos los elementos de una lista se conoce tradicionalmente en
el albur de programación como &amp;ldquo;map&amp;rdquo;. Otra uso importante de
funciones personalizadas es para hacer más eficiente el análisis,
por ejemplo cuando necesitamos repetir un proceso mas de una vez.&lt;/p&gt;
&lt;p&gt;En programación se tienen estándares al escribir código sobre no repetirte
a ti mismo, y se crean funciones o macros para básicamente cualquier
tarea que deba ser repetida al menos una vez. Como analista de datos
esto no es estrictamente necesario, sin embargo nos ahorra tiempo y
esfuerzo y al mismo tiempo nos ayuda a entender mejor el lenguaje
de programación que estamos utilizando para analizar nuestros datos.&lt;/p&gt;
&lt;p&gt;Como ejemplo, supongamos que queremos hacer visualizaciones de
las principales actividades por estado, por ejemplo, actividades
que generen mas de 5 millones de dolares. Podríamos escribir lo
siguiente&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;  export.rows %&amp;gt;%
      filter(Activity != &amp;quot;Total&amp;quot;) %&amp;gt;%
      group_by(state, Activity)  %&amp;gt;%
      summarise(Total = sum(USD)) %&amp;gt;%
      filter(state == &amp;quot;Chihuahua&amp;quot; &amp;amp;
             Total &amp;gt;= 5000000) %&amp;gt;%
      ggplot() +
      geom_bar(aes(y = Total,
                   x = reorder(Activity, Total, FUN = abs),
                   fill = Total),
               stat = &#39;identity&#39;) +
      coord_flip() +
      labs(title = &amp;quot;Chihuahua&amp;quot;,
           y = &amp;quot;Total USD&amp;quot;, x = NULL) +
      theme(legend.position=&amp;quot;none&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://blog.rwhitedwarf.com/post/2022/EDA_INEGI_data/five-mil-code-1.png&#34; alt=&#34;plot of chunk five-mil-code&#34; /&gt;
&lt;/p&gt;
&lt;p&gt;Sin embargo, tendríamos que repetir el mismo bloque de código por
cada estado que queremos visualizar, o si queremos cambiar el límite de 5 millones.
La mejor opción en este caso
es generar una función que nos permita hacer lo mismo cambiando
simplemente las variables que queremos. La manera mas fácil es repetir
el código anterior dentro de una función, cambiando el nombre
&amp;ldquo;Chihuahua&amp;rdquo; por una variable que podamos modificar cada vez que
llamemos la función, vamos a llamarla &lt;code&gt;estado&lt;/code&gt;. Por otro lado,
en lugar de filtrar sólo actividades
que producen mas de 5 millones de dolares, vamos a permitir que
este filtro también sea interactivo, sin embargo tomando el valor
de 5 millones por default.&lt;/p&gt;
&lt;p&gt;Veamos el siguiente bloque para entender mejor.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;  ## Funcion para ver principal actividad por estado
  plot_state &amp;lt;- function(estado, USD_min = 5000000){
      export.rows %&amp;gt;%
          filter(Activity != &amp;quot;Total&amp;quot;) %&amp;gt;%
          group_by(state, Activity)  %&amp;gt;%
          summarise(Total = sum(USD)) %&amp;gt;%
          filter(state == estado &amp;amp;
                 Total &amp;gt;= USD_min) %&amp;gt;%
          ggplot() +
          geom_bar(aes(y = Total,
                       x = reorder(Activity, Total, FUN = abs),
                       fill = Total),
                   stat = &#39;identity&#39;) +
          coord_flip() +
          labs(title = estado,
               y = &amp;quot;Total USD&amp;quot;, x = NULL) +
          theme(legend.position=&amp;quot;none&amp;quot;)
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;El nombre de nuestra función es &lt;code&gt;plot_state&lt;/code&gt; y lo definimos como
cualquier otro objeto en R, utilizando &lt;code&gt;&amp;lt;-&lt;/code&gt; y la función
&lt;code&gt;function&lt;/code&gt;. Dentro de los paréntesis de &lt;code&gt;function&lt;/code&gt; debemos colocar
nuestras variables, aquellos valores que podrán ser modificados al
llamar la función. En este caso definimos &lt;code&gt;estado&lt;/code&gt; que nos ayudará
a seleccionar el estado a visualizar, y &lt;code&gt;USD_min&lt;/code&gt; para definir
la cantidad mínima de dolares a visualizar (por ejemplo, si hacemos
&lt;code&gt;USD_min = 0&lt;/code&gt; nuestra función graficaría todas las actividades,
siempre y cuando produzcan mas de cero). También podemos ver que
aquí he definido &lt;code&gt;USD_min = 5000000&lt;/code&gt;, esto genera un valor por
default, es decir, si llamamos nuestra función
&lt;code&gt;plot_state(&amp;quot;Chihuahua&amp;quot;)&lt;/code&gt; obtendremos las actividades que producen
mas de 5 millones en Chiuahua, sin embargo, si llamamos
&lt;code&gt;plot_state(&amp;quot;Chihuahua&amp;quot;, USD_min = 8000)&lt;/code&gt; obtendremos todas las
actividades que producen mas de 8 mil.&lt;/p&gt;
&lt;p&gt;Una vez definido el nombre y las variables de nuestra función,
podemos especificar el cuerpo dentro de corchetes &lt;code&gt;{}&lt;/code&gt;, es decir,
la función de nuestra función. En este caso podemos observar que
el código que forma el cuerpo de la función es exactamente el mismo
que utilizamos para visualizar Chihuahua, los únicos cambios son
que en el sitio donde habíamos escrito &amp;ldquo;Chihuahua&amp;rdquo; y &amp;ldquo;5000000&amp;rdquo;,
ahora están &lt;code&gt;estado&lt;/code&gt; y &lt;code&gt;USD_min&lt;/code&gt;. Hay dos consideraciones que deben
ser tomadas en cuenta al crear una función de este tipo en R:
primero que los valores definidos dentro del cuerpo de una función,
en este caso &lt;code&gt;estado&lt;/code&gt; y &lt;code&gt;USD_min&lt;/code&gt;, sólo existen dentro del cuerpo
de la función. Si vamos a la consola y tecleamos &lt;code&gt;ls()&lt;/code&gt; veremos que
estos objetos no existen en la memoria donde estamos trabajando.
Otro aspecto importante es que en R, a diferencia de otros
lenguajes de programación, una función puede tomar cualquier objeto
que exista en la memoria donde es ejecutado. Por ejemplo, en este
caso nuestra función utiliza la tabla &lt;code&gt;export.rows&lt;/code&gt;. Si esta tabla
no existiera (por ejemplo, si no la hemos creado vía &lt;code&gt;read_csv&lt;/code&gt;),
nuestra función generará un error.&lt;/p&gt;
&lt;p&gt;Es importante entender el proceso de como la ejecución de funciones
busca los valores, para no cometer errores. Al ser ejecutada, la
función buscará valores de los objetos PRIMERO dentro del cuerpo
de la función, y al no encontrarlos, irá a buscarlos a la memoria
general o global de R, que es donde estamos trabajando, si tampoco
existen aquí, generará un error. Esto significa que
si dentro de la función otorgamos un valor diferente a
&lt;code&gt;export.rows&lt;/code&gt;, la función utilizará su nuevo valor. Veamos un
ejemplo:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;  primeros &amp;lt;- function(){
      head(export.rows)
  }

  primeros()
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; # A tibble: 6 × 6
&amp;gt;   Código Descripción           state           year     USD Activity
&amp;gt;    &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;                 &amp;lt;chr&amp;gt;          &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;   
&amp;gt; 1     NA Exportaciones totales Aguascalientes  2007 4389841 Total   
&amp;gt; 2     NA Exportaciones totales Aguascalientes  2008 4456893 Total   
&amp;gt; 3     NA Exportaciones totales Aguascalientes  2009 3951108 Total   
&amp;gt; 4     NA Exportaciones totales Aguascalientes  2010 5647929 Total   
&amp;gt; 5     NA Exportaciones totales Aguascalientes  2011 6051640 Total   
&amp;gt; 6     NA Exportaciones totales Aguascalientes  2012 6183782 Total
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Generamos una función sin variables, que nos devuelve los primeros
valores en &lt;code&gt;export.rows&lt;/code&gt;. En este caso, &lt;code&gt;export.rows&lt;/code&gt; no existe
dentro del cuerpo de la función, por lo tanto R lo busca en la
memoria general, encuentra nuestra tabla, y la utiliza. Sin embargo
esto podría cambiar, veamos:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;  primeros &amp;lt;- function(){
      export.rows &amp;lt;- c(1:100)
      head(export.rows)
  }

  primeros()
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; [1] 1 2 3 4 5 6
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ahora que le hemos dado un valor a &lt;code&gt;export.rows&lt;/code&gt; dentro del
cuerpo de la función, el resultado es diferente. Sin embargo,
el objeto &lt;code&gt;export.rows&lt;/code&gt; en la memoria general no cambió&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;  head(export.rows)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; # A tibble: 6 × 6
&amp;gt;   Código Descripción           state           year     USD Activity
&amp;gt;    &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;                 &amp;lt;chr&amp;gt;          &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;   
&amp;gt; 1     NA Exportaciones totales Aguascalientes  2007 4389841 Total   
&amp;gt; 2     NA Exportaciones totales Aguascalientes  2008 4456893 Total   
&amp;gt; 3     NA Exportaciones totales Aguascalientes  2009 3951108 Total   
&amp;gt; 4     NA Exportaciones totales Aguascalientes  2010 5647929 Total   
&amp;gt; 5     NA Exportaciones totales Aguascalientes  2011 6051640 Total   
&amp;gt; 6     NA Exportaciones totales Aguascalientes  2012 6183782 Total
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;En este ejemplo perecería estúpido, sin embargo al generar
funciones muy largas, que utilizan objetos que tenemos creados en
la memoria, es fácil cometer errores y otorgarle un valor a un
objeto que ya existe y que necesitamos dentro de la función.
Diferentes lenguajes de programación protegen esto de diferentes
maneras, por ejemplo en python, para llamar un objeto de la memoria
general dentro de una función, es necesario utilizar el comando
&lt;code&gt;global&lt;/code&gt;, lo cual le indica que debe buscar este objeto en el ambiente
global, y resulta más fácil para nosotros el notar
que objetos estamos utilizando desde el ambiente global. En R
es importante ser conscientes de nuestros objetos globales y
locales.&lt;/p&gt;
&lt;p&gt;Continuando con nuestro EDA, podemos ver que ahora nuestra función
facilita la visualización por estado:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;   plot_state(&amp;quot;Chihuahua&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://blog.rwhitedwarf.com/post/2022/EDA_INEGI_data/plot-chihuahua-1.png&#34; alt=&#34;plot of chunk plot-chihuahua&#34; /&gt;
&lt;/p&gt;
&lt;p&gt;Podemos utilizar el paquete &lt;code&gt;cowplot&lt;/code&gt; para observar varios estados
juntos en un sólo gráfico.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;   plot_grid(
    plot_state(&amp;quot;Chihuahua&amp;quot;) ,
    plot_state(&amp;quot;Baja California&amp;quot;),
    plot_state(&amp;quot;Coahuila de Zaragoza&amp;quot;),
    plot_state(&amp;quot;Nuevo León&amp;quot;),
    plot_state(&amp;quot;Tamaulipas&amp;quot;),
    plot_state(&amp;quot;Campeche&amp;quot;, USD_min = 10000),
    ncol = 2)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://blog.rwhitedwarf.com/post/2022/EDA_INEGI_data/varios-estados-1.png&#34; alt=&#34;plot of chunk varios-estados&#34; /&gt;
&lt;/p&gt;
&lt;p&gt;La función &lt;code&gt;plot_grid&lt;/code&gt; resulta útil y conveniente, organiza varios
gráficos de forma simétrica, podemos especificar el número de
columnas &lt;code&gt;ncol&lt;/code&gt; o número de filas &lt;code&gt;nrow&lt;/code&gt; en las que nuestros
gráficos deben ser visualizados.&lt;/p&gt;
&lt;p&gt;A pesar de que cada estado obtiene sus principales ingresos en
exportaciones a partir de diferentes actividades, podemos observar
que en general, electrodomésticos (Electronics) y Equipo de
Transporte (Transport equipment) son las principales actividades.
Otras actividades como Maquinaria (Machinery) y metalúrgica
(Metal products) también tienen la tendencia de estar entre los
primeros lugares. Así pues, es claro que hay una tendencia entre
los 5 principales exportadores con el tipo de actividades
exportadoras. Solo para el caso de Campeche, en el sexto lugar es
diferente: su principal actividad de exportación es Petroleo, la
cual no aparece en las otras gráficas entre las principales
actividades de exportación. Sin embargo, si observamos las
principales actividades a lo largo del tiempo, exportación de
petroleo se encuentra en el tercer lugar:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;   export.rows %&amp;gt;%
    filter(Activity == &amp;quot;Electronics&amp;quot; |
           Activity == &amp;quot;Transport equipment&amp;quot; |
           Activity == &amp;quot;Petroleum&amp;quot;) %&amp;gt;%
    group_by(year, Activity) %&amp;gt;%
    summarise(`Total per activity` = sum(USD)) %&amp;gt;%
    ggplot(aes(x = year, y = `Total per activity`)) +
    geom_line(aes(colour = Activity)) +
    geom_point(aes(colour = Activity))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://blog.rwhitedwarf.com/post/2022/EDA_INEGI_data/3-activities-1.png&#34; alt=&#34;plot of chunk 3-activities&#34; /&gt;
&lt;/p&gt;
&lt;p&gt;Al menos desde 2007, exportación de petroleo genera menos ingresos
que exportación de electrodomésticos y equipo de transporte. Otro
detalle interesante que es claro en nuestra última gráfica es que
a partir de 2009, la exportación en equipo de transporte ha
incrementado año con año. Esto explica por que estados donde la
principal actividad de exportación es equipo de transporte están
en los primeros lugares como exportadores.&lt;/p&gt;
&lt;p&gt;Podemos generar otra función similar a &lt;code&gt;plot_state&lt;/code&gt; pero por
actividad, &lt;code&gt;plot_activity&lt;/code&gt; para observar los principales estados
exportadores de petroleo.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;  ## Funcion para ver principal estado por actividad
  plot_activity &amp;lt;- function(activity, USD_min = 5000000){
      export.cols %&amp;gt;%
          select(state, year, activity) %&amp;gt;%
          group_by(state)  %&amp;gt;%
          summarise(Total = sum(!!sym(activity))) %&amp;gt;%
          filter(Total &amp;gt;= USD_min) %&amp;gt;%
          ggplot() +
          geom_bar(aes(y = Total,
                       x = reorder(state,
                                   Total, FUN = abs),
                       fill = Total),
                   stat = &#39;identity&#39;) +
          coord_flip() +
          labs(title = activity,
               y = &amp;quot;Total USD&amp;quot;, x = NULL) +
          theme(legend.position=&amp;quot;none&amp;quot;)
  }

   plot_activity(&amp;quot;Petroleum&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://blog.rwhitedwarf.com/post/2022/EDA_INEGI_data/plot-activity-fun-1.png&#34; alt=&#34;plot of chunk plot-activity-fun&#34; /&gt;
&lt;/p&gt;
&lt;p&gt;Sólo 4 estados exportaron más de 5,000 millones de USD en petroleo.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;   plot_grid(
    plot_state(&amp;quot;Campeche&amp;quot;, USD_min = 1000000),
    plot_state(&amp;quot;Tabasco&amp;quot;, USD_min = 1000000),
    plot_state(&amp;quot;Veracruz de Ignacio de la Llave&amp;quot;),
    plot_state(&amp;quot;Chiapas&amp;quot;, USD_min = 1000000))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://blog.rwhitedwarf.com/post/2022/EDA_INEGI_data/activity-states-1.png&#34; alt=&#34;plot of chunk activity-states&#34; /&gt;
&lt;/p&gt;
&lt;p&gt;Parece ser que la economía de Tabasco, Campeche y Chiapas dependen
en alto grado de la extracción de petroleo, diferente a Veracruz,
que tiene otras actividades mas fuertes como productos químicos,
metalurgia y alimentación.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Acerca de R White Dwarf</title>
      <link>https://blog.rwhitedwarf.com/es/about/</link>
      <pubDate>Sun, 06 Nov 2022 00:00:00 +0000</pubDate>
      
      <guid>https://blog.rwhitedwarf.com/es/about/</guid>
      <description>&lt;p&gt;&lt;strong&gt;White Dwarf&lt;/strong&gt; esta comprometido con promover el uso de R y llevarlo a mas personas.&lt;/p&gt;
&lt;h2 id=&#34;manuel-teodoro-tenango-teoten&#34;&gt;Manuel Teodoro Tenango (teoten)&lt;/h2&gt;
&lt;p&gt;Teoten es estadstico y analista de datos con estudios en ecologa y ciencias ambientales. Cuando no est trabajando por dinero o idealismo (voluntariado) est programando y aprendiendo cosas nuevas. La programacin ha sido su pasin y pasatiempo por mucho tiempo, pero a partir de 2022 se convirti en su trabajo de tiempo completo. Es promotor del software libre y fan de R. Adems est interesado en Common Lisp y Julia.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Mapa de cualquier región del mundo con R - Parte II: obteniendo las coordenadas.</title>
      <link>https://blog.rwhitedwarf.com/es/post/mapa_de_cualquier_region_con_ggplot2ii/</link>
      <pubDate>Fri, 04 Nov 2022 00:00:00 +0000</pubDate>
      
      <guid>https://blog.rwhitedwarf.com/es/post/mapa_de_cualquier_region_con_ggplot2ii/</guid>
      <description>&lt;p&gt;Pueden encontrar todas las publicaciones en este tema bajo la etiqueta &lt;a href=&#34;https://blog.rwhitedwarf.com/tags/maps-app/&#34; target=&#34;_blank&#34;&gt;maps-app&lt;/a&gt; (incluyendo las versiones en inglés).&lt;/p&gt;
&lt;p&gt;También pueden encontrar el estado actual del proyecto en &lt;a href=&#34;https://github.com/teotenn&#34; target=&#34;_blank&#34;&gt;mi GitHub&lt;/a&gt; repo &lt;a href=&#34;https://github.com/teotenn/mapic&#34; target=&#34;_blank&#34;&gt;mapic&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;sobre-este-post&#34;&gt;Sobre este post&lt;/h2&gt;
&lt;p&gt;Esta es la segunda parte de las series de cómo crear mapas de cualquier región del mundo con R. De antemano me disculpo por detalles que puedan encontrar en la traducción, el post original lo creé en Inglés y el trabajo de traducción puede ser excesivo si voy a cada detalle. Por otro lado, recomiendo un conocimiento al menos básico del idioma Inglés si se quiere tener éxito en R o programación en general. Ayuda mucho a entender la sintaxis.&lt;/p&gt;
&lt;p&gt;Estamos creando mapas de datos que muestran los cambios durante un período de tiempo para diferentes países y orientado a todo tipo de ciudades. Esto básicamente significa que necesitamos &lt;strong&gt;mapear cualquier región del mundo con R&lt;/strong&gt;. Hoy en día existen todo tipo de paquetes y técnicas para hacerlo. Quiero compartir la estrategia que utilicé con &lt;a href=&#34;https://cran.r-project.org/web/packages/ggplot2/index.html&#34; target=&#34;_blank&#34;&gt;ggplot2&lt;/a&gt; y &lt;a href=&#34;https://cran.r-project.org/web/packages/maps/index.html&#34; target=&#34;_blank&#34;&gt;maps&lt;/a&gt;, utilizando el soporte de &lt;a href=&#34;https://www.openstreetmap.org/&#34; target=&#34;_blank&#34;&gt;Open Street Map&lt;/a&gt; para obtener las coordenadas de las ciudades y finalmente hacerlo interactivo con &lt;a href=&#34;https://shiny.rstudio.com/&#34; target=&#34;_blank&#34;&gt;shiny&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Estas publicaciones comparten mi camino en la creación de la aplicación Shiny. Es un proyecto vivo en el que estoy trabajando actualmente y decidí compartir mis experiencias durante el proceso de creación. Estas publicaciones no son sólo acerca de Shiny apps, si no más bien sobre la creación del paquete detrás, incluyendo temas sobre la generación de funciones, creación de los mapas, clases de objetos, entre otros, incluyendo cualquier tema interesante que aparezca en el camino. Es mi manera de contribuir a la comunidad de R y al mismo tiempo documentar el proyecto en si mismo.&lt;/p&gt;
&lt;p&gt;Espero que lo disfruten. Siéntanse libres de dejar cualquier tipo de comentario y/o pregunta al final.&lt;/p&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://blog.rwhitedwarf.com/post/2022/map_any_region_with_ggplot2_part_I/maps_DrawingMap.png&#34; alt=&#34;R Maps&#34; /&gt;
&lt;/p&gt;
&lt;h2 id=&#34;open-street-maps-y-nominatim&#34;&gt;Open Street Maps y Nominatim&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Una búsqueda sencilla&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(&#39;RJSONIO&#39;)

site &amp;lt;- (&amp;quot;http://nominatim.openstreetmap.org/search?city=Texcoco&amp;amp;limit=9&amp;amp;format=json&amp;quot;)
(result &amp;lt;- fromJSON(site))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; [[1]]
&amp;gt; [[1]]$place_id
&amp;gt; [1] 1177116
&amp;gt; 
&amp;gt; [[1]]$licence
&amp;gt; [1] &amp;quot;Data © OpenStreetMap contributors, ODbL 1.0. https://osm.org/copyright&amp;quot;
&amp;gt; 
&amp;gt; [[1]]$osm_type
&amp;gt; [1] &amp;quot;node&amp;quot;
&amp;gt; 
&amp;gt; [[1]]$osm_id
&amp;gt; [1] 336169214
&amp;gt; 
&amp;gt; [[1]]$boundingbox
&amp;gt; [1] &amp;quot;29.619&amp;quot;       &amp;quot;29.659&amp;quot;       &amp;quot;-111.0786667&amp;quot; &amp;quot;-111.0386667&amp;quot;
&amp;gt; 
&amp;gt; [[1]]$lat
&amp;gt; [1] &amp;quot;29.639&amp;quot;
&amp;gt; 
&amp;gt; [[1]]$lon
&amp;gt; [1] &amp;quot;-111.0586667&amp;quot;
&amp;gt; 
&amp;gt; [[1]]$display_name
&amp;gt; [1] &amp;quot;Texcoco, Carbó, Sonora, México&amp;quot;
&amp;gt; 
&amp;gt; [[1]]$class
&amp;gt; [1] &amp;quot;place&amp;quot;
&amp;gt; 
&amp;gt; [[1]]$type
&amp;gt; [1] &amp;quot;village&amp;quot;
&amp;gt; 
&amp;gt; [[1]]$importance
&amp;gt; [1] 0.385
&amp;gt; 
&amp;gt; [[1]]$icon
&amp;gt; [1] &amp;quot;https://nominatim.openstreetmap.org/ui/mapicons/poi_place_village.p.20.png&amp;quot;
&amp;gt; 
&amp;gt; 
&amp;gt; [[2]]
&amp;gt; [[2]]$place_id
&amp;gt; [1] 3448536
&amp;gt; 
&amp;gt; [[2]]$licence
&amp;gt; [1] &amp;quot;Data © OpenStreetMap contributors, ODbL 1.0. https://osm.org/copyright&amp;quot;
&amp;gt; 
&amp;gt; [[2]]$osm_type
&amp;gt; [1] &amp;quot;node&amp;quot;
&amp;gt; 
&amp;gt; [[2]]$osm_id
&amp;gt; [1] 458633446
&amp;gt; 
&amp;gt; [[2]]$boundingbox
&amp;gt; [1] &amp;quot;16.551667&amp;quot;  &amp;quot;16.591667&amp;quot;  &amp;quot;-97.053333&amp;quot; &amp;quot;-97.013333&amp;quot;
&amp;gt; 
&amp;gt; [[2]]$lat
&amp;gt; [1] &amp;quot;16.571667&amp;quot;
&amp;gt; 
&amp;gt; [[2]]$lon
&amp;gt; [1] &amp;quot;-97.033333&amp;quot;
&amp;gt; 
&amp;gt; [[2]]$display_name
&amp;gt; [1] &amp;quot;Texcoco, Santa María Sola, Oaxaca, México&amp;quot;
&amp;gt; 
&amp;gt; [[2]]$class
&amp;gt; [1] &amp;quot;place&amp;quot;
&amp;gt; 
&amp;gt; [[2]]$type
&amp;gt; [1] &amp;quot;hamlet&amp;quot;
&amp;gt; 
&amp;gt; [[2]]$importance
&amp;gt; [1] 0.36
&amp;gt; 
&amp;gt; [[2]]$icon
&amp;gt; [1] &amp;quot;https://nominatim.openstreetmap.org/ui/mapicons/poi_place_village.p.20.png&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;Comenzamos con &lt;a href=&#34;https://www.openstreetmap.org/&#34; target=&#34;_blank&#34;&gt;Open Street Map&lt;/a&gt; y su API &lt;a href=&#34;https://nominatim.openstreetmap.org/ui/about.html&#34; target=&#34;_blank&#34;&gt;nominatim&lt;/a&gt;. En el código anterior podemos ver cómo realizar una consulta simple para una ciudad. Es básicamente un string (en R, &amp;ldquo;string&amp;rdquo; se utiliza para referirse a texto) largo que contiene primero la url de nominatim y al final los detalles de la búsqueda: aquí comenzamos la búsqueda de la ciudad, usando &lt;code&gt;?city=Texcoco&lt;/code&gt; que en este caso apunta a una ciudad con solo unos pocos resultados. A continuación, limitamos la cantidad de resultados a 9 con &lt;code&gt;&amp;amp;limit=9&lt;/code&gt; y finalmente solicitamos los resultados en formato JSON.&lt;/p&gt;
&lt;p&gt;Básicamente, podríamos copiar el string que estamos pasando a la variable &lt;code&gt;site&lt;/code&gt; y pegarla en el navegador web para ver los resultados directamente ahí. Siéntete libre de cambiar la ciudad &lt;code&gt;Texcoco&lt;/code&gt; a cualquier otra ciudad, y juega un poco más con el resto de los parámetros. En particular, eche un vistazo a lo que sucede cuando elimina la parte &lt;code&gt;&amp;amp;format=json&lt;/code&gt; o cuando cambia &lt;code&gt;json&lt;/code&gt; por cualquier otra cadena abstracta como &lt;code&gt;csv&lt;/code&gt; u otro formato no reconocido.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Una búsqueda más sencilla&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;city &amp;lt;- &#39;San%20Francisco&#39;
state &amp;lt;- &#39;&amp;amp;state=California&#39;
country &amp;lt;- &#39;&amp;amp;countrycodes=US&#39;
start.nominatim &amp;lt;- &amp;quot;http://nominatim.openstreetmap.org/search?city=&amp;quot;
end.nominatim &amp;lt;- &amp;quot;&amp;amp;format=json&amp;quot;

site &amp;lt;- paste0(start.nominatim, city, country, state, end.nominatim)
(result &amp;lt;- fromJSON(site))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; [[1]]
&amp;gt; [[1]]$place_id
&amp;gt; [1] 297054975
&amp;gt; 
&amp;gt; [[1]]$licence
&amp;gt; [1] &amp;quot;Data © OpenStreetMap contributors, ODbL 1.0. https://osm.org/copyright&amp;quot;
&amp;gt; 
&amp;gt; [[1]]$osm_type
&amp;gt; [1] &amp;quot;relation&amp;quot;
&amp;gt; 
&amp;gt; [[1]]$osm_id
&amp;gt; [1] 111968
&amp;gt; 
&amp;gt; [[1]]$boundingbox
&amp;gt; [1] &amp;quot;37.6403143&amp;quot;  &amp;quot;37.929811&amp;quot;   &amp;quot;-123.173825&amp;quot; &amp;quot;-122.281479&amp;quot;
&amp;gt; 
&amp;gt; [[1]]$lat
&amp;gt; [1] &amp;quot;37.7790262&amp;quot;
&amp;gt; 
&amp;gt; [[1]]$lon
&amp;gt; [1] &amp;quot;-122.419906&amp;quot;
&amp;gt; 
&amp;gt; [[1]]$display_name
&amp;gt; [1] &amp;quot;San Francisco, CAL Fire Northern Region, California, United States&amp;quot;
&amp;gt; 
&amp;gt; [[1]]$class
&amp;gt; [1] &amp;quot;boundary&amp;quot;
&amp;gt; 
&amp;gt; [[1]]$type
&amp;gt; [1] &amp;quot;administrative&amp;quot;
&amp;gt; 
&amp;gt; [[1]]$importance
&amp;gt; [1] 1.035131
&amp;gt; 
&amp;gt; [[1]]$icon
&amp;gt; [1] &amp;quot;https://nominatim.openstreetmap.org/ui/mapicons/poi_boundary_administrative.p.20.png&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;Si exploramos OSM y nominatim un poco, veremos que podemos agregar argumentos de búsqueda usando &lt;code&gt;&amp;amp;&lt;/code&gt; seguido del argumento que queremos (es decir, &lt;code&gt;state&lt;/code&gt;), el símbolo igual (&lt;code&gt;=&lt;/code&gt;) y el argumento. En mi ejemplo anterior, puede verse cómo especificamos el estado y el país de nuestra consulta. Además, es importante saber cómo pasar espacios en un nombre, por ejemplo, San Francisco pasaría como &lt;code&gt;San%20Francisco&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Con esta información básica en mente y sabiendo que el paquete &lt;code&gt;RJSONIO&lt;/code&gt; nos ayuda a recuperar los datos de la API JSON en un formato tabular compatible con R, podemos preparar fácilmente una función para buscar cualquier ciudad rápidamente, siempre que se proporcionen algunos detalles adicionales como una región, estado o condado, y especialmente importante, el país (intenta buscar ciudades como Londres o Praga sin proporcionar un país, te sorprenderá la cantidad de ciudades que existen en el mundo con esos nombres).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;coords_from_city &amp;lt;- function(City,
                             CountryTwoLetter,
                             Region = NULL,
                             State = NULL,
                             County = NULL){
    require(&#39;RJSONIO&#39;)
    CityCoded &amp;lt;- gsub(&#39; &#39;,&#39;%20&#39;,City) #remover espacios de  URLs
    CountryCoded &amp;lt;- paste(&amp;quot;&amp;amp;countrycodes=&amp;quot;, CountryTwoLetter, sep = &#39;&#39;)
    extras &amp;lt;- c(state = State, region = Region, county = County)
    extrasCoded &amp;lt;- &#39;&#39;
    if(!is.null(extras)) {
        for(i in 1:length(extras)){
            if(extras[i] != &#39;&#39; &amp;amp;&amp;amp; !is.na(extras[i]) &amp;amp;&amp;amp; !grepl(&amp;quot;^\\s*$&amp;quot;, extras[i])){
                valCoded &amp;lt;- gsub(&#39; &#39;, &#39;%20&#39;, extras[i])
                extrasCoded &amp;lt;- paste0(extrasCoded, &#39;&amp;amp;&#39;, names(extras)[i], &#39;=&#39;, valCoded)
            }
        }
    }
    ## obtener los datos
    url &amp;lt;- paste(
        &amp;quot;http://nominatim.openstreetmap.org/search?city=&amp;quot;
      , CityCoded
      , CountryCoded
      , extrasCoded
      , &amp;quot;&amp;amp;format=json&amp;quot;
      , sep=&amp;quot;&amp;quot;)
    x &amp;lt;- fromJSON(url)
    ## obtener las coordenadas
    if(is.vector(x)){
            message(paste(&#39;Found&#39;, x[[1]]$display_name))
            lon &amp;lt;- x[[1]]$lon
            lat &amp;lt;- x[[1]]$lat
            osm_name &amp;lt;- x[[1]]$display_name
            coords &amp;lt;- data.frame(&#39;lon&#39; = lon, &#39;lat&#39; = lat, &#39;osm_name&#39; = osm_name)
    }
    ## Si x no es un vector
    else{
        message(paste(&#39;No results found for&#39;, City, CountryTwoLetter))
        coords &amp;lt;- data.frame(&#39;lon&#39; = NA, &#39;lat&#39; = NA)
    }
    ## regresa un df
    coords
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Un detalle importante que debe saber es que, a menudo, proporcionar valores a los parámetros &amp;ldquo;state&amp;rdquo; o &amp;ldquo;region&amp;rdquo; arroja resultados similares, esto es particularmente útil en países donde no se usan estados o hay otras formas de organización presentes. Sin embargo, cuando el país tiene estrictamente estados, no puedes pasar el nombre de un Estado al parámetro &lt;code&gt;Region&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;La función devuelve un data frame que usaremos más adelante para crear una tabla con todos nuestros resultados. Como estamos interesados en crear mapas, solo necesitamos las coordenadas expresadas en latitud y longitud. En caso de que no se encuentre la consulta, la función completa los valores con &lt;code&gt;NA&lt;/code&gt;, que luego usaremos para realizar un seguimiento de lo que se encontró y lo que no. También mantenemos los valores dentro de &lt;code&gt;osm_name&lt;/code&gt;, que brinda suficiente información para brindarle al usuario detalles útiles sobre los resultados de la búsqueda, incluido el país de la ciudad encontrada y otros detalles como el estado o la región.&lt;/p&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://blog.rwhitedwarf.com/post/2022/map_any_region_with_ggplot2_part_II/maps_coords_from_city.png&#34; alt=&#34;Funcion coords_from_city() en detalle&#34; /&gt;
&lt;/p&gt;
&lt;p&gt;Un punto importante a considerar en &lt;code&gt;coords_from_city&lt;/code&gt; es que devuelve solo el resultado superior de la consulta. Esto significa que cuanto más información se proporcione, más preciso será su resultado. Para nuestro proyecto funciona bien porque para los países grandes siempre recopilamos suficiente información sobre regiones y estados, mientras que para los países más pequeños, las opciones a menudo son demasiado pequeñas. Pero si usamos la función, es importante saber que si se proporciona un nombre de ciudad como &lt;code&gt;Springfield&lt;/code&gt;, &lt;code&gt;country = &#39;US&#39;&lt;/code&gt; y no proporciona información sobre el estado y el condado, la función recuperara solo el primer resultado de la búsqueda, y descarta las opciones restantes.&lt;/p&gt;
&lt;h2 id=&#34;mantener-la-información-en-una-base-de-datos&#34;&gt;Mantener la información en una base de datos&lt;/h2&gt;
&lt;p&gt;La función &lt;code&gt;coords_from_city&lt;/code&gt; podría ser suficiente si necesitamos obtener información unas pocas ciudades; Podríamos utilizar la iteración de &lt;code&gt;for&lt;/code&gt; para recuperar todas las coordenadas que necesitamos y almacenarlas en un data frame para luego guardarlas en formato csv, &lt;code&gt;Rdata&lt;/code&gt; o cualquier formato que elijamos. Lo mismo ocurre cuando buscamos cientos o miles de ciudades, pero con el aumento del tamaño, el tiempo de búsqueda también aumenta. Si, por alguna razón, la sesión de R se interrumpe, la información se perdería y tendremos que comenzar de nuevo desde la fila 1. Por lo tanto, enviaremos todos los resultados a una base de datos. De esa forma, no importa cuándo detengamos el proceso o cómo suceda, los datos se almacenan de forma segura fuera de R.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;webscrap_to_sqlite &amp;lt;- function(db.name,
                               dat,
                               col.city = &#39;City&#39;,
                               col.country = &#39;Country&#39;,
                               region = NULL,
                               state = NULL,
                               county = NULL)
{
    require(RSQLite)
    df_len &amp;lt;- nrow(dat)
    ## Conexion a la db y la tabla
    con &amp;lt;- dbConnect(drv=SQLite(), dbname=db.name)
    dbExecute(conn = con,
                &amp;quot;CREATE TABLE IF NOT EXISTS orgs
                    (ID INTEGER UNIQUE,
                     City TEXT, osm_name TEXT,
                     lon REAL,lat REAL)&amp;quot;)
    ## -- Iteraciones para el webscrap -- ##
    ccount &amp;lt;- 0
    ## For loop para el webscrapping
    for(i in 1:df_len){
        rg &amp;lt;- ifelse(is.null(region), &#39;&#39;, dat[[region]][i])
        st &amp;lt;- ifelse(is.null(state), &#39;&#39;, dat[[state]][i])
        ct &amp;lt;- ifelse(is.null(county), &#39;&#39;, dat[[county]][i])
        print(paste(&#39;Entry&#39;, i))
        ## Haz el webscrap
        coords &amp;lt;- coords_from_city(dat[[col.city]][i],
                                   dat[[col.country]][i],
                                   Region = rg, State = st, County = ct)
        ## Enviar resultados a DB sólo si se encontró algo
        if(is.na(coords$lon[1])){
            ccount &amp;lt;- ccount + 1
        }
        else{
            sq &amp;lt;- dbExecute(con, &#39;INSERT OR IGNORE INTO orgs
                             (ID, City, osm_name, lon, lat)
                             VALUES (?, ?, ?, ?, ?);&#39;,
                        list(dat[[&#39;ID&#39;]][i], dat[[col.city]][i],
                             coords$osm_name, coords$lon[1], coords$lat[1]))
        }
        print(paste(&#39;Completed&#39;, (i/df_len)*100, &#39;%&#39;))
    }
    ## Cerrar la conexión
    dbDisconnect(con)
    message(paste(&amp;quot;WEB SCRAP FOR COORDINATES SEARCH FINISHED.&amp;quot;,
                ccount, &amp;quot;ENTRIES NOT FOUND&amp;quot;))
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Para almacenar los datos elegí usar &lt;a href=&#34;https://www.sqlite.org/index.html&#34; target=&#34;_blank&#34;&gt;SQLite&lt;/a&gt; a través del paquete R &lt;a href=&#34;https://rsqlite.r-dbi.org/&#34; target=&#34;_blank&#34;&gt;RSQLite&lt;/a&gt;. Si no estas familiarizado con las bases de datos SQL te recomiendo que comiences con una búsqueda general en Google y luego regresar a la documentación de SQLite y el paquete R. Elegí SQLite porque necesitaba tener algo ligero y portátil que nos permitiera mover la información fácilmente de un país a otro en lugar de una base de datos centralizada donde pudiéramos almacenar todo, pero se puede aplicar un enfoque muy similar usando otros tipos de bases de datos SQL.&lt;/p&gt;
&lt;p&gt;La función &lt;code&gt;dbConnect()&lt;/code&gt; genera el archivo SQLite si aún no existe. Luego le damos a SQLite la orden de crear la tabla &lt;code&gt;orgs&lt;/code&gt; si aún no existe, y la estructura para dicha tabla. A continuación buscamos las coordenadas de las entradas una a una usando &lt;code&gt;coords_from_city()&lt;/code&gt; y finalmente lo enviamos a la base de datos. De esa manera podríamos detener el proceso en cualquier momento y continuar más tarde simplemente recuperando la tabla &lt;code&gt;orgs&lt;/code&gt; de la base de datos, comparándola con nuestros datos originales y avanzando desde lo que falta. Para eso, la columna &lt;code&gt;ID&lt;/code&gt; es fundamental, es la columna que nos permite vincular una entrada entre los datos originales, el data frame de R y la tabla SQL.&lt;/p&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://blog.rwhitedwarf.com/post/2022/map_any_region_with_ggplot2_part_II/maps_webscrap_to_sqlite.png&#34; alt=&#34;Función webscrap_to_sqlite() en detalle&#34; /&gt;
&lt;/p&gt;
&lt;p&gt;Nuestra función también tiene una variable &lt;code&gt;ccount&lt;/code&gt; que cuenta cada vez que no se encuentra una entrada. De esa forma, una vez finalizada la consulta, imprimirá la cantidad de entradas que no fueron encontradas. Las razones para no encontrar una entrada pueden ser muchas, entre las más comunes que encontré están las siguientes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Error en la ortografía del nombre de la ciudad o exceso de información (es decir, valor &amp;ldquo;Praga, Distrito 3&amp;rdquo; cuando el nombre de la ciudad es simplemente &amp;ldquo;Praga&amp;rdquo;).&lt;/li&gt;
&lt;li&gt;La ortografía incorrecta del nombre del Estado, Región y/o Condado.&lt;/li&gt;
&lt;li&gt;La ciudad buscada simplemente no está en la base de datos de Open Street Maps (sucedió especialmente para pueblos muy pequeños).&lt;/li&gt;
&lt;li&gt;Interrupciones de la conexión a internet. Esta es particularmente importante porque, a veces, ejecutar la consulta por segunda o tercera vez encontraría ciudades que no se encontraron la primera vez.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Para volver a leer los datos a R desde SQL, simplemente necesitamos hacer una conexión a la base de datos, leer la tabla y cerrar la conexión. La función &lt;code&gt;combine_df_sql&lt;/code&gt; se encarga de eso y al mismo tiempo une nuestros datos originales con los datos almacenados en la base de datos por el ID y el nombre de la ciudad. Esto fue importante para el proyecto porque queríamos mantener las coordenadas de las ciudades separadas del resto de la información debido a algunas razones prácticas internas. Pero creo que mantener todos los datos en SQL a la vez puede facilitar muchas cosas. Entre otros, podría identificar cuándo se encontró una ciudad en particular en el pasado y recuperar las coordenadas de la base de datos directamente en lugar de hacer una conexión con nominatim. Lo hice para algunos países y reduce considerablemente el tiempo de consulta. Para la presente publicación, decidí mostrar la versión separada de los datos para brindar más herramientas al lector.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;combine_df_sql &amp;lt;- function(db.file, original.data){
    require(dplyr)
    require(RSQLite)
    if(is.character(original.data)){
        if(grepl(&#39;.csv&#39;, original.data, fixed = T)){
            df &amp;lt;- read.csv(original.data)
        }
        else{
            stop(&amp;quot;Incorrect file format for data&amp;quot;)
        }
    }
    else if(is.data.frame(original.data)){
        df &amp;lt;- original.data
    }
    else{
        stop(&amp;quot;Incorrect data format&amp;quot;)
    }
    con &amp;lt;- dbConnect(drv=RSQLite::SQLite(), dbname = db.file)
    db &amp;lt;- dbReadTable(con, &amp;quot;orgs&amp;quot;)
    dbDisconnect(con)
    result &amp;lt;- left_join(df, db, by = c(&#39;ID&#39;, &#39;City&#39;))
    return(result)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Otro detalle de nuestra función es la capacidad de leer desde el archivo &lt;code&gt;csv&lt;/code&gt; o desde un &lt;code&gt;data.frame&lt;/code&gt;. Dado que estábamos trabajando principalmente con archivos csv y usé data frames para los pruebas unitarias, estos 2 formatos fueron suficientes. Siéntanse libres de modificar o ampliar la función para los formatos de datos que puedan necesitarse.&lt;/p&gt;
&lt;h2 id=&#34;datos-faltantes&#34;&gt;Datos faltantes&lt;/h2&gt;
&lt;p&gt;Como se mencionó anteriormente, a veces los resultados de la consulta estaban incompletos y era necesaria una segunda o tercera ejecución, pero con menos filas. Algunas otras veces sólo necesitaba parar la consulta y continuar mas tarde desde donde la dejamos. Sin embargo, otras veces los datos estaban incompletos o incorrectos y esto se podía solucionar más tarde con el responsable de los datos. Los 3 escenarios me forzaban a leer el archivo csv a R, luego la tabla de la base de datos y compararlos para filtrar los valores faltantes. Así que creé la función &lt;code&gt;compare_db_data&lt;/code&gt; para comparar la base de datos (db) con los datos originales.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;compare_db_data &amp;lt;- function(db.file, dat){
    require(dplyr)
    require(RSQLite)
    if(is.character(dat)){
        if(grepl(&#39;.csv&#39;, dat, fixed = T)){
            df &amp;lt;- read.csv(dat)
        }
        else{
            stop(&amp;quot;Incorrect file format for data&amp;quot;)
        }
    }
    else if(is.data.frame(dat)){
        df &amp;lt;- dat
    }
    else{
        stop(&amp;quot;Incorrect data format&amp;quot;)
    }
    con &amp;lt;- dbConnect(drv=RSQLite::SQLite(), dbname = db.file)
    db &amp;lt;- dbReadTable(con, &amp;quot;orgs&amp;quot;)
    dbDisconnect(con)
    filtered &amp;lt;- filter(df, !(as.character(ID) %in%
                              as.character(db$ID)))
    filtered
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Como se mencionó anteriormente, a veces Open Street Maps simplemente no tiene registro de ciertas &amp;ldquo;ciudades&amp;rdquo; (de hecho, sucedió solo con pueblos o poblaciones realmente pequeñas). Para solucionar eso, la función &lt;code&gt;add_coords_manually&lt;/code&gt; toma un archivo csv con una estructura particular para agregar los datos que faltan. El archivo csv debe tener las siguientes columnas:
- Columna &lt;code&gt;ID&lt;/code&gt; nombrada exactamente así y que contiene la misma ID que los datos originales.
- Una columna que contiene el nombre de la ciudad
- Columnas que contienen la Latitud y Longitud donde queremos señalar la ciudad
- Un valor para &lt;code&gt;osm_name&lt;/code&gt;. Esto podría dejarse vacío o podemos proporcionar el valor que queremos en esta punto. Lo importante es tener la columna presente en el archivo csv.&lt;/p&gt;
&lt;p&gt;Luego, como en la función anterior, le pasamos a &lt;code&gt;add_coords_manualmente&lt;/code&gt; el nombre del archivo csv con la información complementaria, el nombre de la base de datos SQLite y los nombres de las columnas donde tenemos los valores para los nombres de &lt;code&gt;city&lt;/code&gt;, &lt;code&gt;osm_name&lt;/code&gt; , &lt;code&gt;lat&lt;/code&gt; y &lt;code&gt;long&lt;/code&gt;, todos con formato de string. El resto de la función es autodescriptiva, siempre que se tengan conocimientos básicos de sintaxis SQL.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;add_coords_manually &amp;lt;- function(csv_file, db.name,
                                city, osm_name, lat, lon){
    require(tidyverse)
    require(RSQLite)
    csv_dat &amp;lt;- read_csv(csv_file)
    csv_len &amp;lt;- length(csv_dat$ID)
    con &amp;lt;- dbConnect(drv=RSQLite::SQLite(), dbname=db.name)
    for(i in 1:csv_len){
        dbSendQuery(con, &#39;INSERT OR IGNORE INTO orgs
                      (ID, City, osm_name, lon, lat)
                      VALUES (?, ?, ?, ?, ?);&#39;,
                    list(csv_dat[[&#39;ID&#39;]][i],
                         csv_dat[[city]][i],
                         csv_dat[[osm_name]][i],
                         csv_dat[[lat]][i],
                         csv_dat[[lon]][i]))
    }
    dbDisconnect(con)
    print(paste(csv_len, &#39;inserted&#39;))
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;siguientes-pasos&#34;&gt;Siguientes pasos&lt;/h2&gt;
&lt;p&gt;Si eres nuevo en R, probablemente habrás notado que uno de los puntos fuertes de R que estoy usando mucho aquí es el uso de funciones. Los primeros mapas que creamos en el proyecto los hicimos escribiendo scripts con unos pocos cientos de líneas. Eso nos dio la base para crear las funciones necesarias y, por lo tanto, el resto de los mapas fueron posibles usando solo unas pocas líneas. Algunos de los scripts para el web scrapping de las coordenadas constan de menos de 10 líneas de código. Eso es posible usando las funciones anteriores y algunas otras creadas para casos especiales o particulares. No compartiré absolutamente todo, pero quiero dar una idea de cómo hacer que el proceso sea más eficiente. Siempre puedes crear más funciones para tus casos particulares o modificar mis funciones propuestas para adaptarlas a tu situación particular.&lt;/p&gt;
&lt;p&gt;Y hablando de extensibilidad, mientras escribía este blog descubrí una librería que no conocía, &lt;a href=&#34;https://github.com/r-tmap/tmaptools&#34; target=&#34;_blank&#34;&gt;tmaptools&lt;/a&gt; que contiene la función [geocode_OSM](&lt;a href=&#34;https://www.rdocumentation&#34; target=&#34;_blank&#34;&gt;https://www.rdocumentation&lt;/a&gt;. org/packages/tmap/versions/1.6-1/topics/geocode_OSM) que usa nominatim para recuperar las coordenadas del punto buscado. La función tiene un formato de búsqueda más fácil de usar y más posibilidades para el valor de retorno, mientras que mi opción &lt;code&gt;coords_from_city()&lt;/code&gt; se mantiene bastante rígida y aún con el formato original que se imaginó hace unos años cuando la creé. Si realmente te interesa el tema te invito a revisar el paquete. Yo mismo he estado ocupado manteniendo el código y creando mapas, por lo que tengo muy poco tiempo para hacer mejoras al proyecto original. Pero esa es exactamente mi tarea principal en este momento, así que si hago algún cambio en las funciones presentadas aquí usando el paquete &lt;a href=&#34;https://github.com/r-tmap/tmaptools&#34; target=&#34;_blank&#34;&gt;tmaptools&lt;/a&gt;, puedes estar seguro de que crearé un breve publicación para compartirlo.&lt;/p&gt;
&lt;p&gt;Luego, una vez que tenemos las coordenadas de nuestras ciudades objetivo y sabemos cómo hacer el mapa básico, el siguiente paso es agregar las ciudades al mapa base. En la próxima publicación, les mostraré cómo lo hice y una función para que el proceso sea más rápido y eficiente.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Mapa de cualquier región del mundo con R - Parte I: El mapa base</title>
      <link>https://blog.rwhitedwarf.com/es/post/mapa_de_cualquier_region_con_ggplot2_i/</link>
      <pubDate>Sat, 08 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://blog.rwhitedwarf.com/es/post/mapa_de_cualquier_region_con_ggplot2_i/</guid>
      <description>&lt;p&gt;Pueden encontrar todas las publicaciones en este tema bajo la etiqueta &lt;a href=&#34;https://blog.rwhitedwarf.com/tags/maps-app/&#34; target=&#34;_blank&#34;&gt;maps-app&lt;/a&gt; (incluyendo las versiones en inglés).&lt;/p&gt;
&lt;p&gt;También pueden encontrar el estado actual del proyecto en &lt;a href=&#34;https://github.com/teotenn&#34; target=&#34;_blank&#34;&gt;mi GitHub&lt;/a&gt; repo &lt;a href=&#34;https://github.com/teotenn/mapic&#34; target=&#34;_blank&#34;&gt;mapic&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;sobre-esta-entrada&#34;&gt;Sobre esta entrada&lt;/h2&gt;
&lt;p&gt;Cuando nos preparamos para una entrevista de trabajo, una de las preguntas que más recomiendan preparar es &amp;ldquo;Menciona el proyecto del que estés más orgulloso?&amp;rdquo;. Personalmente nunca me han hecho esa pregunta en una entrevista de trabajo pero me mantuvo pensando. Hace algunos años desarrollé el código en R para la creación de mapas de infraestructura para un proyecto de Ciencias Políticas, y puedo decir que este es uno de los proyectos de los que estoy más orgulloso. Sin embargo, también es cierto lo que comúnmente se dice entre los desarrolladores, que &lt;strong&gt;a nadie le importa cómo lo hiciste&lt;/strong&gt;. Al usuario final solo le interesa el producto final y cómo utilizarlo, mientras que al equipo de investigación le interesa saber las posibilidades que propone.&lt;/p&gt;
&lt;p&gt;El proyecto me enseñó tanto en términos de habilidades técnicas que he decidido compartir el &lt;strong&gt;cómo&lt;/strong&gt; en caso de que pueda ayudar a alguien más. También es mi forma de contribuir a la comunidad de R, ya que yo mismo aprendí R y programación gracias a las amables personas que publican su experiencia en la web (y también a los que tienen la paciencia de responder preguntas en StackOverflow). Debido al acuerdo de confidencialidad con mi cliente no puedo compartir el código completo o el repositorio de Git.&lt;/p&gt;
&lt;p&gt;Creamos mapas de datos que muestran los cambios durante un período de tiempo para diferentes países y orientados a todo tipo de ciudades. Esto básicamente significa que necesitamos &lt;strong&gt;mapear cualquier región del mundo con R&lt;/strong&gt;. Hoy en día existen todo tipo de paquetes y técnicas para hacerlo. Compartiré la estrategia que utilicé con &lt;a href=&#34;https://cran.r-project.org/web/packages/ggplot2/index.html&#34; target=&#34;_blank&#34;&gt;ggplot2&lt;/a&gt; y &lt;a href=&#34;https://cran.r-project.org/web/packages/maps/index.html&#34; target=&#34;_blank&#34;&gt;maps&lt;/a&gt;, utilizando el soporte de &lt;a href=&#34;https://www.openstreetmap.org/&#34; target=&#34;_blank&#34;&gt;Open Street Map&lt;/a&gt; para obtener las coordenadas de las ciudades y finalmente hacerlo interactivo con &lt;a href=&#34;https://shiny.rstudio.com/&#34; target=&#34;_blank&#34;&gt;shiny&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;El proyecto es bastante largo para una sola publicación. Por otro lado, recientemente logré extraer el código base y hacerlo público sin comprometer la privacidad. También es un proyecto vivo en el que estoy trabajando actualmente. Por lo que decidí compartir mis experiencias durante el proceso de creación de la aplicación Shiny. Estas publicaciones no son sólo acerca de Shiny apps, si no más bien sobre la creación del paquete detrás. Tocaré temas sobre la generación de funciones, creación de los mapas, clases de objetos, entre otros, incluyendo cualquier tema interesante que aparezca en el camino. Es mi manera de contribuir a la comunidad de R y al mismo tiempo documentar el proyecto en si mismo.&lt;/p&gt;
&lt;p&gt;Espero que lo disfruten. Siéntanse libres de dejar cualquier tipo de comentario y/o preguntas al final.&lt;/p&gt;
&lt;h2 id=&#34;motivación&#34;&gt;Motivación&lt;/h2&gt;
&lt;p&gt;Cuando me uní al equipo, todo lo que sabían era que querían hacer mapas de infraestructura (por ejemplo hospitales, cafés, iglesias, oficinas públicas, etc., pero el proyecto básicamente se puede aplicar a cualquier cosa contable en una ciudad dada). Los mapas deben cambiar en el tiempo de acuerdo con los datos (generalmente crecimiento) y debe ser posible aplicarlo para cualquier país y, por lo tanto, cualquier tipo de ciudad en dicho país. Este último punto representa un desafío porque para hacer un mapa se necesitan las coordenadas del punto en particular para mapear, pero en cambio obtuvimos las dirección postales en el mejor escenario, o solo el nombre de la ciudad en el peor. Por lo tanto, lo dejamos a nivel de ciudad y decidimos trabajar con eso.&lt;/p&gt;
&lt;p&gt;La mayoría de los paquetes de R para hacer mapas tienen granularidad hasta algunas regiones y ciudades importantes por país, y estamos hablando de países donde alguien ha desarrollado algún paquete de R para eso. Sin embargo, incluso a los mejores paquetes les faltan algunas ciudades en sus datos. Necesitábamos estandarizar todo sin necesidad de cambiar paquetes por país. Antes de unirme, el equipo intentaron usar Google Maps y Microsoft Excel, pero la cantidad de datos se volvió desastrosa y la flexibilidad para editar los mapas era bastante limitada. Además no querían agregar problemas de derechos de autor o copyright a la lista de limitaciones. Por lo tanto, propuse usar R. Por supuesto, nadie en el equipo había oído hablar de él antes. Podríamos haber usado cualquier otra herramienta, aprendí que tanto Python como JavaScript tienen algunas posibilidades decentes. Pero R es lo que he estado usando durante los últimos 10 años y es lo que quería utilizar para este proyecto. Y así comencé a escribir código.&lt;/p&gt;
&lt;p&gt;Los primeros mapas eran códigos personalizados para un país en particular con estilos decentes. Pero rápidamente se convirtió en un conjunto de funciones y argumentos para mantener los mismos estándares para cada mapa. El apoyo de los diseñadores gráficos también llevó los estilos a un nivel muy profesional. Después de unos meses teníamos mapas muy profesionales que se podían hacer en un par de horas (o menos) con un par de líneas de código. Cada mapa por cada país con el lapso de años deseado para ser impreso.&lt;/p&gt;
&lt;p&gt;No puedo compartir cada uno de los detalles, pero al menos quiero mostrar cómo pasamos del mapa básico a su forma dinámica de mapeo durante un período de tiempo, y cómo lo envolví todo en un par de funciones para que sea rápidamente replicable para cualquier conjunto de datos dado. Siéntanse libres de compartir su opinión.&lt;/p&gt;
&lt;h2 id=&#34;cómo-crear-un-mapa-de-cualquier-país-en-r-usando-la-librería-maps&#34;&gt;Cómo crear un mapa de cualquier país en R usando la librería maps&lt;/h2&gt;
&lt;p&gt;El primer paso es crear el mapa básico de un país. Aquí está la función para lograr exactamente eso.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(maps)
library(ggplot2)

## hacer un df con sólo pais para traslapar
map_data_es &amp;lt;- map_data(&#39;world&#39;)[map_data(&#39;world&#39;)$region == &amp;quot;Spain&amp;quot;,]

## El mapa (maps + ggplot2 )
ggplot() +
    ## Primera capa: mapa del mundo
    geom_polygon(data = map_data(&amp;quot;world&amp;quot;),
                 aes(x=long, y=lat, group = group),
                 color = &#39;#9c9c9c&#39;, fill = &#39;#f3f3f3&#39;) +
    ## Segunda capa: mapa del país
    geom_polygon(data = map_data_es,
                 aes(x=long, y=lat, group = group),
                 color = &#39;red&#39;, fill = &#39;pink&#39;) +
    coord_map() +
    coord_fixed(1.3,
                xlim = c(-13.5, 8.5),
                ylim = c(34, 45)) +
    ggtitle(&amp;quot;A map of Spain&amp;quot;) +
    theme(panel.background =element_rect(fill = &#39;blue&#39;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://blog.rwhitedwarf.com/post/2022/map_any_region_with_ggplot2_part_I/basic_map-1.png&#34; alt=&#34;plot of chunk basic_map&#34; /&gt;
&lt;/p&gt;
&lt;p&gt;Utilizamos la librería &lt;a href=&#34;https://cran.r-project.org/web/packages/maps/index.html&#34; target=&#34;_blank&#34;&gt;maps&lt;/a&gt; en combinación con [ggplot2](&lt;a href=&#34;https://cran.r-project.org/&#34; target=&#34;_blank&#34;&gt;https://cran.r-project.org/&lt;/a&gt; web/packages/ggplot2/index.html). El paquete &lt;code&gt;maps&lt;/code&gt; contiene un sistema de coordenadas para un mapa de todo el mundo separado por países (aunque es posible que las fronteras políticas no estén totalmente actualizadas). También puede hacer los mapas, pero para eso decidí hacer uso del soporte &lt;code&gt;ggplot2&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Empezamos extrayendo los datos relevantes del país que queremos mapear, en este caso &lt;code&gt;España&lt;/code&gt;. Por supuesto, es importante pasar el nombre del país de la misma manera que está escrito en &lt;code&gt;map_data(&#39;world&#39;)$region&lt;/code&gt;. Puedes usar la función &lt;code&gt;unique()&lt;/code&gt; para encontrar los nombres exactos de todos los países incluidos en los paquetes (si ejecutas &lt;code&gt;unique(map_data(&#39;world&#39;)$region)&lt;/code&gt; da 252 países al momento de escribir esta publicación).&lt;/p&gt;
&lt;p&gt;Una vez que tengamos los datos para un país en particular, podríamos simplemente mapearlo directamente usando &lt;code&gt;geom_polygon()&lt;/code&gt; sin embargo, eso mapearía a España rodeada por un espacio vacío a su alrededor. Para ubicarlo en el contexto de su vecindario, aplicamos dos capas de &lt;code&gt;geom_polygon()&lt;/code&gt;: la primera con el mapa de todo el mundo y la segunda con el mapa del país únicamente.&lt;/p&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://blog.rwhitedwarf.com/post/2022/map_any_region_with_ggplot2_part_I/maps_BasicMap.png&#34; alt=&#34;Explicación del código básico del mapa&#34; /&gt;
&lt;/p&gt;
&lt;p&gt;Luego necesitamos decirle a &lt;code&gt;ggplot&lt;/code&gt; que use un sistema de coordenadas para crear mapas en lugar de sólo polígonos. Para eso usamos la función &lt;a href=&#34;https://ggplot2.tidyverse.org/reference/coord_map.html&#34; target=&#34;_blank&#34;&gt;coord_map()&lt;/a&gt; y luego pasamos los detalles de la proporción del mapa y los límites en X e Y a la función &lt;code&gt;coord_fixed( )&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Hasta aquí podemos obtener nuestro mapa. &lt;code&gt;ggplot&lt;/code&gt; está básicamente trazando lo que estamos especificando dentro del sistema de coordenadas, todo a su alrededor (los océanos) estará vacío y el gráfico será completado con las cuadrículas predeterminadas y los colores grises de &lt;code&gt;ggplot()&lt;/code&gt;. Por lo tanto, necesitamos definir el color de los océanos como color de fondo para todo el gráfico. Eso es lo que hace la última línea de código.&lt;/p&gt;
&lt;p&gt;Por supuesto, hay muchas mejoras que hacer aún. Hasta ahora he dado colores exagerados para que el lector sepa qué fragmento de código controla qué. En ese sentido, puedes notar que se puede simplemente pasar los nombres de los colores, lo cual aplica los valores predeterminados, o se puede ser más específico y proporcionar la notación html del color (es decir, &lt;code&gt;&#39;#9c9c9c&#39;&lt;/code&gt;). Con esto podemos ahora mejorar las imágenes y al mismo tiempo crear una función para trazar cualquier país que queramos.&lt;/p&gt;
&lt;h2 id=&#34;función-para-crear-el-mapa-básico-en-r&#34;&gt;Función para crear el mapa básico en R&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;map_country &amp;lt;- function(country, x_limits = NULL, y_limits = NULL){
    ## Verificar los argumentos tomados por la función
    if(!is.character(country)) stop(&amp;quot;Nombre del país debe ser de tipo string&amp;quot;)
    if(length(country) != 1) stop(&amp;quot;La función soporta sólo un país por mapa&amp;quot;)
    ## Cargar las librerías
    require(maps)
    require(ggplot2)
  if(!country %in% map_data(&#39;world&#39;)$region) stop(&#39;Nombre del país no reconocido\nPara ver una lista de paises reconocidos ejecute &amp;lt;unique(maps::map_data(&amp;quot;world&amp;quot;)$region)&amp;gt;&#39;)
  ## Si no se proporcionaron los limites de las coordenadas, imprime el mapa mundial
    if(missing(x_limits) || missing(y_limits)) {
        warning(&amp;quot;Límites de X y/o Y no han sido encontrados.\nImprimiendo el mapa mundial&amp;quot;)
        map_country_theme &amp;lt;- theme(panel.background = element_rect(fill = &#39;#4e91d2&#39;))
    }
    else {
        if(length(x_limits) != 2 || length(y_limits) != 2 ||
           !all(grepl(&#39;^-?[0-9.]+$&#39;, c(x_limits, y_limits)))){
            stop(&amp;quot;Los límites de las coordenadas X y Y deben ser ingresadas como vectores con dos valores numéricos&amp;quot;)
        }
        else {
            ## Definiendo el tema seleccionado para el mapa final
            map_country_theme &amp;lt;- theme_bw() +
                theme(panel.background = element_rect(fill = &#39;#4e91d2&#39;),
                      legend.position = &#39;none&#39;,
                      panel.grid.major = element_blank(),
                      panel.grid.minor = element_blank(),
                      axis.line = element_line(colour = &amp;quot;black&amp;quot;),
                      axis.title.x=element_blank(),
                      axis.text.x=element_blank(),
                      axis.ticks.x=element_blank(),
                      axis.title.y=element_blank(),
                      axis.text.y=element_blank(),
                      axis.ticks.y=element_blank())
        }
    }
    ## Un df con el pais a agregar únicamente
    map_data_country &amp;lt;- map_data(&#39;world&#39;)[map_data(&#39;world&#39;)$region == country,]
    ## El mapa (maps + ggplot2 )
    ggplot() +
        ## Primera capa: mapa mundial
        geom_polygon(data = map_data(&amp;quot;world&amp;quot;),
                     aes(x=long, y=lat, group = group),
                     color = &#39;#9c9c9c&#39;, fill = &#39;#f3f3f3&#39;) +
        ## Segunda capa: mapa del país
        geom_polygon(data = map_data_country,
                     aes(x=long, y=lat, group = group),
                     color = &#39;#4d696e&#39;, fill = &#39;#8caeb4&#39;) +
        coord_map() +
        coord_fixed(1.3,
                    xlim = x_limits,
                    ylim = y_limits) +
        ggtitle(paste0(&amp;quot;A map of &amp;quot;, country)) +
        scale_x_continuous(n.breaks = 20) +
        scale_y_continuous(n.breaks = 20) +
        map_country_theme
}

## Probando la función con un país diferente
map_country(&amp;quot;Germany&amp;quot;, c(-2, 22), c(47, 55))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://blog.rwhitedwarf.com/post/2022/map_any_region_with_ggplot2_part_I/function_map-1.png&#34; alt=&#34;plot of chunk function_map&#34; /&gt;
&lt;/p&gt;
&lt;p&gt;Aunque la función puede parecer complicada al principio, de hecho es el mismo código que usamos para crear el mapa en un principio, pero en lugar de escribir directamente el nombre del país o los límites para X o Y, los reemplazamos con los argumentos &lt;code&gt;país &lt;/code&gt;, &lt;code&gt;x_limits&lt;/code&gt; y &lt;code&gt;y_limits&lt;/code&gt; respectivamente; de esa manera todas las partes donde teníamos el string &lt;code&gt;&amp;quot;España&amp;quot;&lt;/code&gt; ahora tenemos el argumento &lt;code&gt;país&lt;/code&gt;, y así sucesivamente. Ahora estos son los únicos argumentos que necesitamos cambiar cuando queremos mapear un país diferente. Puedes definir más argumentos en caso de que quieras tener más posibilidades de ser editable, por ejemplo, podríamos definir un argumento &lt;code&gt;country_color&lt;/code&gt; para especificar el color que queremos para el país de destino. En nuestro caso, queríamos mantener los mismos estándares para todos los mapas por motivos de control de calidad, por lo tanto, queríamos tener exactamente los mismos colores y estilos para todos nuestros mapas.&lt;/p&gt;
&lt;p&gt;También hay algunas adiciones en la parte superior antes del código inicial para hacer los mapas: son una serie de declaraciones &lt;code&gt;if&lt;/code&gt; y &lt;code&gt;else&lt;/code&gt; que simplemente se usan para validar que la información ingresada por el usuario es la información que realmente necesita la función para hacer su trabajo. Si se ingresa algún argumento incorrecto a la función, detenemos el proceso y escribimos un mensaje de lo que está mal utilizando la función &lt;code&gt;stop()&lt;/code&gt;. Para el caso de que no se definan límites de X o Y, se envía un mensaje de advertencia usando &lt;code&gt;warning()&lt;/code&gt;. En ese caso el proceso continúa pero definimos un &lt;code&gt;theme()&lt;/code&gt; que permite al usuario ver el país en el contexto del mapa mundial, con exceso de valores en los ejes X e Y para proporcionar los puntos de referencia y dar un idea de dónde poner los límites. Al final, cuando nos aseguramos de que todos los valores estén bien, definimos el tema final que realmente queremos aplicar. A este respecto debería hacer una mención especial sobre &lt;code&gt;!all(grepl(&#39;^-?[0-9.]+$&#39;, c(x_limits, y_limits))))&lt;/code&gt;: se usa para asegurar que tanto los valores de X como Y son de tipo numérico. Puedes ver la visualización del código a continuación junto con la ayuda de las funciones que no comprendes para obtener una explicación más detallada. Siéntete libre de probar los errores y advertencias proporcionando a la función nombres de países o letras donde debería haber números, etc.&lt;/p&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://blog.rwhitedwarf.com/post/2022/map_any_region_with_ggplot2_part_I/maps_FunctionMap.png&#34; alt=&#34;Código de la función explicada&#34; /&gt;
&lt;/p&gt;
&lt;p&gt;La parte inferior de la función es exactamente igual a nuestro primer mapa, reemplazando los valores reales con los argumentos. También hemos cambiado los colores por unos más específicos. Casi al final de la función hemos agregado &lt;code&gt;scale_x_continuous(n.breaks = 20)&lt;/code&gt; que agrega 20 marcas en la escala del eje X (y después, lo mismo para Y). Usamos esto para asegurarnos de que, en caso de que el usuario no tenga idea de qué valores límite elegir, pueda tener un buen enfoque con respecto a la posición del país objetivo. En caso de que ambos límites para X e Y se ingresen a la función, nuestro otro tema enmascarará estas 20 marcas con &lt;code&gt;axis.text.x = element_blank()&lt;/code&gt; y &lt;code&gt;axis.ticks.x = element_blank()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;La línea final es la prueba de que nuestra función puede trazar un mapa que no sea España, en este caso elegí Alemania. Básicamente, podemos elegir cualquier país incluido en el paquete &lt;code&gt;maps&lt;/code&gt; y entonces hacer el mapa con los mismos estándares en tan sólo una línea de código de R.&lt;/p&gt;
&lt;h2 id=&#34;observaciones-finales&#34;&gt;Observaciones finales&lt;/h2&gt;
&lt;p&gt;He querido mostrar aquí uno de los métodos que utilizo para crear funciones: básicamente escribo primero el código de lo que quiero lograr y, una vez que hace exactamente lo que quiero, lo envuelvo en una función, reemplazando valores por los argumentos que el usuario necesitará modificar más adelante. Luego pienso en qué podría salir mal y genero las advertencias y errores correspondientes. Es una buena práctica hacer eso no solo para que el usuario sepa mejor cómo usar la función, sino también para uno mismo, pues resulta muy útil cuando necesitamos depurar el código. Otra buena práctica en las funciones de R es la llamada a las librerías dentro de la función usando &lt;code&gt;require()&lt;/code&gt;. Incluso si se están escribiendo muchas funciones que usan las mismas bibliotecas, es bueno repetirlo en cada función, o al menos por script, para que se mantenga independiente y, nuevamente, nos ayude en el proceso de debug. No hace mucho comencé a colaborar en un proyecto donde no hacían la llamada a los paquetes de R por cada función, sino solo en el nivel superior cuando se llamaba al proceso principal del programa. Esto me hizo casi imposible probar y depurar el código, así que la primera actividad que hice como nuevo miembro del equipo fue pasar 2 días completos agregando &lt;code&gt;require()&lt;/code&gt; donde fuera necesario.&lt;/p&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://blog.rwhitedwarf.com/post/2022/map_any_region_with_ggplot2_part_I/maps_CompareCode.png&#34; alt=&#34;Código de la función explicada&#34; /&gt;
&lt;/p&gt;
&lt;p&gt;Espero que te diviertas mapeando diferentes países. Debido a que los diferentes países tienen diferentes tamaños y formas, una forma de mejorar las imágenes es ajustando la proporción (&lt;code&gt;prportion&lt;/code&gt;), por ejemplo, mi propio mapa de Alemania parece fuera de forma, pero mejora considerablemente si en lugar de 1.3 le damos una proporción de 1.4, consulta la documentación para obtener más información al respecto.&lt;/p&gt;
&lt;p&gt;Una vez que tengamos el mapa básico, podríamos agregar las ciudades donde queremos agregar valores de datos. Desafortunadamente, para las ciudades hay muchas limitaciones, especialmente para países donde no se tienen pquetes específicos. E incluso en los que se tienen, la mayoría de los paquetes tienen carencias de algunas ciudades, especialmente cuando son muy pequeñas. Por lo tanto, en la segunda parte se verá como enfrentar este problema haciendo un poco de web scrap utilizando open street maps.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Mini tutorial: hacer tipo lógico cualquier texto</title>
      <link>https://blog.rwhitedwarf.com/es/post/minitut_hacer_bool/</link>
      <pubDate>Sun, 18 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://blog.rwhitedwarf.com/es/post/minitut_hacer_bool/</guid>
      <description>&lt;h2 id=&#34;acerca-de-este-post&#34;&gt;Acerca de este post.&lt;/h2&gt;
&lt;p&gt;Este es mi primer post en español. Es en realidad la traducción de un post que escribí originalmente en inglés hace un par de meses. Pueden ver el post original &lt;a href=&#34;https://blog.rwhitedwarf.com/post/minitut_makebool/&#34; target=&#34;_blank&#34;&gt;aqui&lt;/a&gt;. Espero que sea útil para la comunidad hispanohablante de usuarios de R.&lt;/p&gt;
&lt;p&gt;Este post se basa en un trabajo reciente donde mi tarea fue la revisión y depuración de piezas de código pequeñas o simples que pueden resultar en consejos prácticos y rápidos para otros usuarios de R, especialmente principiantes o personas sin mucha experiencia en el uso de R.&lt;/p&gt;
&lt;p&gt;Con ese objetivo en mente, mientras recuperaba un poco de mi tiempo libre y un poco de estabilidad mental, y celebraba mi nuevo puesto como programador en R, decidí crear publicaciones simples pero útiles llamadas &lt;strong&gt;mini tutoriales&lt;/strong&gt;, comenzando con un ejemplo muy simple, incluso tonto, pero útil.&lt;/p&gt;
&lt;h2 id=&#34;mini-tutorial-hacer-lógico-cualquier-texto-make_logical_any_string&#34;&gt;Mini tutorial: Hacer lógico cualquier texto (make_logical_any_string).&lt;/h2&gt;
&lt;p&gt;Una función para hacer lógica cualquier texto en R.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;make_logical_any_string &amp;lt;- function(texto){
    texto &amp;lt;- as.character(texto)
    resultado_logico &amp;lt;- as.logical(texto)
    if(is.na(resultado_logico)){resultado_logico &amp;lt;- FALSE}
    return(resultado_logico)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;La función toma cualquier valor, lo convierte en texto (character) y devuelve &lt;code&gt;TRUE&lt;/code&gt; SÓLO SI el valor adopta cualquiera de las siguientes formas: &lt;code&gt;&amp;quot;T&amp;quot;&lt;/code&gt;, &lt;code&gt;&amp;quot;TRUE&amp;quot;&lt;/code&gt;, &lt;code&gt;&amp;quot;true&amp;quot;&lt;/code&gt;, &lt;code&gt;&amp;quot;true&amp;quot;&lt;/code&gt; o &lt;code&gt;TRUE&lt;/code&gt;, el último el valor lógico, no en formato texto.&lt;/p&gt;
&lt;h3 id=&#34;lógica-de-la-función&#34;&gt;Lógica de la función&lt;/h3&gt;
&lt;p&gt;La función &lt;code&gt;as.character()&lt;/code&gt; convierte cualquier forma de texto &amp;ldquo;true&amp;rdquo; listado arriba en un &lt;code&gt;TRUE&lt;/code&gt; lógico. Si el texto es &lt;code&gt;&amp;quot;False&amp;quot;&lt;/code&gt; o sus formas equivalentes, la función devolverá &lt;code&gt;FALSE&lt;/code&gt;. Si se pasa cualquier otro valor a la función, el resultado será &lt;code&gt;NA&lt;/code&gt;. Por lo tanto, necesitamos modificar los resultados cuando se producen NA, ya que necesitamos un resultado de Verdadero/Falso. Así que implementamos &lt;code&gt;if(is.na(resultado_logico)){resultado_logico &amp;lt;- FALSE}&lt;/code&gt; que obligará a cualquier otra cadena de texto a devolver &lt;code&gt;FALSE&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Estamos usando este código para ejecutar scripts de R en la consola que pasa una serie de argumentos para su funcionamiento, algunos de los cuales deben ser &amp;ldquo;TRUE&amp;rdquo; solo cuando se especifica, y &amp;ldquo;FALSE&amp;rdquo; en cualquier otro caso, de ahí el truco de convertir cualquier otro valor a &lt;code&gt;FALSE&lt;/code&gt; en lugar de &lt;code&gt;NA&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Algo importante a tomar en cuenta es que los argumentos siempre se pasan al script R como texto y, por lo tanto, escribí el ejemplo para esta publicación convirtiendo todo en texto en la primera línea de la función, lo cual no es necesario en nuestro código original ejecutado en el Terminal. De esta forma, si se le pasa algún número a la función, también devolverá &lt;code&gt;FALSE&lt;/code&gt;, emulando lo que pasaría si se ingresa un número en la consola. Este comportamiento &lt;strong&gt;es diferente para la función&lt;/strong&gt; &lt;code&gt;as.logical()&lt;/code&gt;, que devuelve &lt;code&gt;FALSE&lt;/code&gt; si ingresa el valor numérico &lt;code&gt;0&lt;/code&gt; y &lt;code&gt;TRUE&lt;/code&gt; si se ingresa cualquier otro valor numérico.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
